\chapter{语言交互接口}

\textbf{语言交互接口}（Foreign Function Interface, FFI）是不同语言之间交互的接口。Berry提供了一套FFI来实现与C语言之间的交互，这套接口也非常容易在C++中使用。大部分的FFI接口是一些函数，它们的声明都放在\textsl{berry.h}文件中。为了降低RAM的使用量，FFI还提供一套C编译期生成固定哈希表的机制，该机制必须要用到外部工具来生成C代码。

\section{基础}

FFI中最为重要的交互功能的应该是Berry代码与C函数相互调用的功能。为了实现两种语言互相调用对方的函数，我们要先了解Berry函数的参数传递机制。

\subsection{虚拟机}

与编译型语言不同，Berry语言不能直接在物理机器上运行，而是在特定的软件环境中运行，这个环境就是\textbf{虚拟机}（Virtual Machine, VM）。与真实的计算机相似，文本形式的源代码不能在虚拟机中执行，而要通过编译器将其转换为``字节码''才可以。Berry虚拟机定义为一个C结构体 \texttt{bvm}，这个结构体的内容对于FFI而言是不可见的。通过一些FFI函数，我们可以创建并初始化一个虚拟机。我们通过一个简单的例子来介绍虚拟机的使用：
\begin{lstlisting}[language=c, style=berry]
void berry_test(void)
{
    bvm *vm = be_vm_new();                     // Construct a VM
    be_loadstring(vm, "print('Hello Berry')"); // Compile test code
    be_pcall(vm, 0);                           // Call function
    be_vm_delete(vm);                          // Destroy the VM
}
\end{lstlisting}
这段代码给出了一个完整的使用虚拟机例子，首先，调用 \texttt{be\_vm\_new} 函数来构造一个新的虚拟机，之后所有的操作都在这个虚拟机对象中完成。\texttt{be\_vm\_new} 函数在创建虚拟机时还会自动链接标准库。4到5行的作用是将一个字符串中的源代码编译成Berry函数然后调用。最后在第6行调用 \texttt{be\_vm\_delete} 函数销毁虚拟机。执行该函数将会在终端中得到一行输出：
\begin{lstlisting}[numbers=none]
Hello Berry
\end{lstlisting}

在所有的场景之下，虚拟机的构造、库加载以及销毁的流程都和上面例子中的第3行、第4行和第6行一样。更具需要，编译或者加载源代码的方式可能会有所不同，例如，对于文件形式的源代码，可以通过 \texttt{be\_loadfile} 函数来编译。源代码会被编译成一个Berry函数，且该函数会被存放在栈顶，通过调用FFI函数 \texttt{be\_pcall} 或 \texttt{be\_call} 既可执行该Berry函数。你还可以通过 \texttt{be\_repl} 函数来使用REPL，REPL的接口将在相关的章节中描述。

\subsection{虚拟栈}

Berry使用一个虚拟栈（virtual stack）和C语言编写的原生函数传递值，栈中每个元素都是一个Berry值。Berry代码调用原生函数时总会创建一个新的栈，并把所有的参数压入栈中。在C代码中也可以使用这个虚拟栈来存储数据，存储在栈中的值不会被垃圾回收器回收。

\begin{wrapfigure}{r}{0.5\textwidth}
\centering
\begin{tikzpicture}
    \begin{scope}[
    start chain=1 going right,start chain=2 going below,node distance=-0.15mm,minimum width=0.5cm,minimum height=0.6cm,font=\small\ttfamily
  ]
  \node [on chain=1] at (-1.5, -0.4) {\ldots};
  \foreach \x in {-1,...,-7} {
      \x, \node at (3+\x*0.5, 0.2) {\x};
  }
  \node [draw,on chain=1] {};
  \foreach \x in {1,...,7} {
      \x, \node (\x) [draw,on chain=1] {\x};
  }
  \foreach \x in {8,...,10} {
      \x, \node (\x) [draw,on chain=1] {};
  }
  \node [on chain=1] {\ldots};
  \node (base) at (-0.5, -1.2) {base};
  \node (top)  at (3, -1.2) {top};

  \draw[->] (base) -- (1);
  \draw[->] (top) -- (8);
  \end{scope}
\end{tikzpicture}
\caption{虚拟栈}
\label{fig::virtual_stack}
\end{wrapfigure}

Berry使用的虚拟栈如图\ref{fig::virtual_stack}所示，虚拟栈从左往右增长。Berry代码调用一个原生函数时会得到一个初始的堆栈，该堆栈第一个值的位置称为\textbf{栈底}（\texttt{base}），而最后一个位置称为\textbf{栈顶}（\texttt{top}），原生函数只能访问从栈底到栈顶前一个位置间的值。栈底的位置是固定的，而栈顶的位置则可以移动，并且栈顶永远为空，产生这个性质的原因是：将新的值压入虚拟栈以后，原来栈顶的位置将会写入新的值，此时栈顶指针会向前挪到下一个位置；反过来，如果将虚拟栈顶部的值弹出，栈顶指针会减$1$，此时栈顶指针的位置虽然客观上有值，但是这个值是无效的，并随时可能被清除，因此栈顶指针位置依然是空的。虚拟栈为空时，栈底指针 \texttt{base} 等于栈顶指针 \texttt{top}。虚拟堆栈不严格遵循栈的操作规则：除了push和pop以外，虚拟栈还可以通过索引来访问，甚至可以在任意位置插入或者删除值。索引栈中元素的方法有两种：一种是以栈底为参考的\textbf{绝对索引}，绝对索引值是从$1$开始的正整数；另一种是以栈顶为参考的\textbf{相对索引}，相对索引值是从$-1$开始的负整数。以图\ref{fig::virtual_stack}为例，索引值$1,2\ldots 8$是绝对索引，元素的绝对索引就是该元素到栈底的距离。索引值$-1,-2\ldots -8$是相对索引，元素的相对索引值为该元素到栈顶距离的负数。如果一个索引值$index$有效，那么它所指的元素应该处于栈底到栈顶之间，也就是满足表达式$1\leqslant \mathrm{abs}(index)\leqslant top-base+1$。

为了方便起见，我们规定以栈底指针 \texttt{base} 作为参考，其绝对索引$1$，并且不考虑 \texttt{base} 前面的值（通常，\texttt{base} 并不是整个栈最底部的位置）。例如，原生函数返回时，存储返回值的位置就在 \texttt{base} 之前，这些位置通常不允许原生函数访问。

\subsection{操作虚拟栈}

\subsubsection{索引和栈尺寸}

前面已经提到，可以使用两种索引方式访问虚拟栈，并且要保证索引值有效。同时，在很多时候也需要将新的值压入堆栈，此时须要程序员自己保证堆栈不会溢出。默认情况下，Berry保证有 \texttt{BE\_STACK\_FREE\_MIN} 个空间供原生函数使用，这个值可以在文件\textsl{berry.h}中修改，它的默认值通常是$10$，在大多数情况下应该够用。如果确实需要扩充堆栈则，可以通过调用FFI函数 \texttt{be\_stack\_require} 来实现。该函数的原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
void be_stack_require(bvm *vm, int count)；
\end{lstlisting}
参数 \texttt{count} 为需要的空间数量，当虚拟栈剩余的空位不足时将会扩展堆栈容量，否则这个函数什么也不做。

\textbf{警告}：如果发生了堆栈溢出，或者使用无效的索引访问堆栈都会导致程序崩溃。你可以打开调试开关 \texttt{BE\_DEBUG}（\ref{section::BE_DEBUG}节），这会打开断言功能，可以在运行时得到一些调试信息，以便捕获堆栈溢出或者无效索引这类错误。

\subsubsection{从栈中获取值}

FFI中有一组函数用于从虚拟栈中获取值，这些函数通常会将栈中的值转换为C语言支持的简单值然后返回，以下是常用的从栈中获取值的FFI：
\begin{lstlisting}[language=c, style=berry, numbers=none]
bint be_toint(bvm *vm, int index);
breal be_toreal(bvm *vm, int index);
int be_tobool(bvm *vm, int index);
const char* be_tostring(bvm *vm, int index);
void* be_tocomptr(bvm *vm, int index);
\end{lstlisting}
这些函数的参数形式相同，只是返回值不同。前4个函数的作用和容易理解，就像它们的名字一样，\texttt{be\_toint} 的功能是将虚拟栈中的值转换为C的整型值（\texttt{bint} 通常是 \texttt{int} 类型的别名）并返回。最后一个函数 \texttt{be\_tocomptr} 的作用是从虚拟栈中取出一个通用类型的指针值，这个指针具体有何意义由C程序自己解释。

这些函数使用相同的方式去解释参数：参数 \texttt{vm} 是虚拟机实例的指针；\texttt{index} 为待取出元素的索引，它可以是相对索引或绝对索引。无法使用FFI将Berry的复杂数据类型从虚拟栈中取出，因此你无法将一个 \texttt{map} 类型或者 \texttt{class} 类型从栈中取出。这种设计的好处之一是不需要在原生函数中考虑垃圾回收的问题。

\subsection{原生函数}

\textbf{原生函数}是由C语言实现的，可供Berry代码调用的函数。原生函数可以是一个普通的函数，这种情况下，调用原生函数不会附加生成任何动态分配的空间，就像一般的C函数调用一样。原生函数也可以是闭包，在创建原生闭包时需要为自由变量分配空间。通常情况下，简单的原生函数就足够满足需求，它们比原生闭包更节省资源，同时使用上也更加简单。

\subsubsection{定义原生函数}

原生函数本身是一个C函数，不过它们都具有特定的形式。原生函数的定义形式为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
int a_native_function(bvm *vm)
{
    // do something ...
}
\end{lstlisting}
原生函数必须是参数是一个 \texttt{bvm} 指针，返回值为 \texttt{int} 类型的C函数。Berry的函数必须返回一个值，原生函数也不例外。与C语言的返回值不同，原生函数的返回值并不是C的 \texttt{return} 语句所携带的值。你可以使用这些FFI返回原生函数的值，同时它们也会使C函数返回：
\begin{lstlisting}[language=c, style=berry, numbers=none]
be_return(bvm *vm);
be_return_nil(bvm *vm);
\end{lstlisting}
这些FFI实际上是两个宏，使用它们的时候不需要再使用C的 \texttt{return} 语句。\texttt{be\_return} 会将虚拟栈中的顶部

\subsubsection{使用原生函数}

定义原生函数之后必须要使用某种方法添加到解释器中才能在Berry代码中调用。最简单的办法之一是把原生函数添加到Berry的内建对象表中。将原生对象设置为Berry内建对象的过程称为\textbf{注册}。注册原生函数的FFI为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
void be_regfunc(bvm *vm, const char *name, bntvfunc f);
\end{lstlisting}
\texttt{vm} 是当前的虚拟机实例，\texttt{name} 是该原生函数的名称，\texttt{f} 是原生函数的指针。该函数的具体行为跟 \texttt{BE\_USE\_PRECOMPILED\_OBJECT} 宏的取值有关（尽管在使用编译期构造技术时该 FFI 依然可用，但是并不能动态地注册内建变量，这种情况下注册内建对象的方法请参考\ref{section::precompiled_build}节）。原生函数类型 \texttt{bntvfunc} 的定义为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
typedef int (*bntvfunc)(bvm*);
\end{lstlisting}
实际上 \texttt{bntvfunc} 类型就是参数为 \texttt{bvm} 且返回值类型为 \texttt{int} 的函数指针类型。\texttt{be\_regfunc} 函数要在解析Berry源代码之前调用。

也可以将原生函数压入虚拟栈中，然后可以使用一个FFI函数 \texttt{be\_call} 来调用它，更常见的用法是把虚拟栈中原生函数对象作为返回值。

\subsubsection{完整的例子}

我们用一个简单的示例结束本节，在这里，我们呢要实现一个 \texttt{add} 函数，该函数用于将两个数相加，然后返回计算结果。首先，我们定义一个原生函数实现此功能：
\begin{lstlisting}[language=c, style=berry]
static int l_add(bvm *vm)
{
    int top = be_top(vm); // Get the number of arguments
    /* Verify the number and type of arguments */
    if (top == 2 && be_isnumber(vm, 1) && be_isnumber(vm, 2)) {
        breal x = be_toreal(vm, 1); // Get the first argument
        breal y = be_toreal(vm, 2); // Get the second argument
        be_pushreal(vm, x + y);     // Push the result onto the stack
        be_return(vm);              // Return the value at the top of the stack
    }
    be_return_nil(vm); // Return nil when something goes wrong
}
\end{lstlisting}
原生函数通常不需要在C文件外部使用，因此一般将它们声明为 \texttt{static} 类型。使用 \texttt{be\_top} 函数可以获得虚拟栈的栈顶绝对索引（\texttt{top} 值），也就是栈的容量。我们可以在原生函数进行虚拟栈的操作之前调用 \texttt{be\_top}，此时虚拟栈容量等于实参数量。对于 \texttt{add} 函数，我们需要两个参数参与运算，因此在第4行检查参数数量是否为2（\texttt{top == 2}）。并且我们需要检查两个参数是否都是数值类型，因此要调用 \texttt{be\_isnumber} 函数来检查。如果一切无误，就会从虚拟栈中取出参数，然后将计算结果入栈，最后使用 \texttt{be\_return} 返回。如果参数验证失败则会调用 \texttt{be\_return\_nil} 返回 \texttt{nil} 值。

接下来将这个原生函数注册到内建对象表中，简单起见，我们在加载库之后注册它：
\begin{lstlisting}[language=c, style=berry]
bvm *vm = be_vm_new();          // Construct a VM
be_regfunc(vm, "myadd", l_add); // Register the native function "myadd"
\end{lstlisting}
第2行就是注册该原生函数的位置，我们将它命名为 \texttt{myadd}。到此，原生函数的定义和注册就完成了。作为验证，你可以编译解释器，然后进入REPL，运行一些测试。你应该会得到这样的结果：
\begin{lstlisting}[language=berry, numbers=none]
> myadd
<function: 0x562a210f0f90>
> myadd(1.0, 2.5)
3.5
> myadd(2.5, 2)
4.5
> myadd(1, 2)
3
\end{lstlisting}

\section{类型和函数}

\subsection{类型}

本节将介绍FFI中需要使用的一些类型，这些类型一般由FFI函数使用。通常，FFI中的类型和声明都可以在 \textsl{berry.h} 文件中找到，本节内容如无特别说明，默认其定义或声明在 \textsl{berry.h} 中提供。

\ffititle{bvm}

\texttt{bvm} 类型用于存储Berry虚拟机的状态信息。这个类型的细节对外部程序不可见。因此只能在 \textsl{berry.h} 文件中找到这样的定义：
\begin{lstlisting}[language=c, numbers=none]
typedef struct bvm bvm;
\end{lstlisting}

大部分的FFI函数都使用 \texttt{bvm} 类型作为第一个参数，这是因为它们内部都要操作虚拟机。隐藏 \texttt{bvm} 的内部实现有利于降低 FFI 标准与 VM 之间的耦合性。在解释器外部，通常只用 \texttt{bvm} 的指针。创建一个新的 \texttt{bvm} 对象要使用 \texttt{be\_vm\_new} 函数，销毁 \texttt{bvm} 对象应使用 \texttt{be\_vm\_delete} 函数。

\ffititle{bntvfunc}

原生函数类型。该类型的定义为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
typedef int (*bntvfunc)(bvm*);
\end{lstlisting}
这个类型是原生函数指针，一些将原生函数注册或添加到虚拟机中的FFI使用该类型的参数。该类型的变量或参数需要使用参数为 \texttt{bvm} 类型，返回值为 \texttt{int} 类型的函数名来初始化。

\ffititle{bnfuncinfo}

该类型用于批量注册原生函数或是构建原生类时使用，其定义为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
typedef struct {
    const char *name;   // The name of the function or object
    bntvfunc function;  // The function pointer
} bnfuncinfo;
\end{lstlisting}
\texttt{bnfuncinfo} 的 \texttt{name} 成员表示函数或者对象的名字，而 \texttt{function} 成员为原生函数指针。

\ffititle{bint}

该类型是Berry内置的整数类型。其定义在 \textsl{berry.h} 文件中。默认情况下 \texttt{bint} 使用 \texttt{long long} 类型实现，可以通过修改配置文件来修改 \texttt{bint} 的实现方式。

\ffititle{breal}

这是 Berry 内置的实数类型，实际上就是C语言中的浮点类型。\texttt{breal} 的定义为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
#if BE_SINGLE_FLOAT != 0
    typedef float       breal;
#else
    typedef double      breal;
#endif
\end{lstlisting}
你可以使用宏 \texttt{BE\_SINGLE\_FLOAT} 来控制 \texttt{breal} 的具体实现：当 \texttt{BE\_SINGLE\_FLOAT} 的值为 \texttt{0} 时将使用 \texttt{double} 类型实现 \texttt{breal}，否则使用 \texttt{float} 类型实现 \texttt{breal}。

\ffititle{berrorcode} \label{section::errorcode}

这个枚举类型在一些 FFI 的返回值中使用，此类型的定义为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
enum berrorcode {
    BE_OK = 0,
    BE_IO_ERROR,
    BE_SYNTAX_ERROR,
    BE_EXEC_ERROR,
    BE_MALLOC_FAIL,
    BE_EXIT
};
\end{lstlisting}
这些枚举值的含义为：
\begin{itemize}
    \item \texttt{BE\_OK}：没有任何错误，函数执行成功。
    \item \texttt{BE\_IO\_ERROR}：解释器在读取源文件时发生文件读取错误，该错误一般是由于文件不存在而导致的。
    \item \texttt{BE\_SYNTAX\_ERROR}：解释器在编译源代码时发生语法错误。发生此错误以后解释器不会生成字节码，因此也不能继续执行字节码。
    \item \texttt{BE\_EXEC\_ERROR}：运行时错误。发生此错误时会停止执行 Berry 代码并将环境恢复到最近的恢复点。
    \item \texttt{BE\_MALLOC\_FAIL}：内存分配失败。此错误由堆空间不足导致。
    \item \texttt{BE\_EXIT}：表示程序退出，该枚举值不是错误。执行 Berry 的 \texttt{exit} 函数会使解释器返回这个值。
\end{itemize}

需要注意的是，发生 \texttt{BE\_MALLOC\_FAIL} 错误时不能够再进行动态内存分配，这意味着不能再分配字符串对象，因此返回这个错误的函数通常不会再给出更详细的错误信息。

\subsection{函数和宏}

\ffititle{be\_vm\_new}

该函数用于建立一个新的虚拟机实例。函数原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
bvm* be_vm_new(void);
\end{lstlisting}
函数的返回值是虚拟机实例的指针。\texttt{{be\_vm\_new}} 数是创建 Berry 解释器时调用的第一个函数，该函数会做大量的工作：为虚拟机申请内存、初始化虚拟机的状态和属性、初始化GC（垃圾回收器），以及将标准库加载到虚拟机实例中等。

\ffititle{be\_vm\_delete}

该函数用于销毁一个虚拟机实例，函数原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
void be_vm_delete(bvm *vm);
\end{lstlisting}
参数 \texttt{vm} 是待销毁的虚拟机对象指针。销毁虚拟机将会连带释放虚拟机中所有的对象，包括栈中的值以及由 GC 管理的对象。销毁后的虚拟机指针将是一个无效值，不可以再引用它。

\ffititle{be\_loadbuffer}

这个函数用于从缓冲区中加载一段源代码并将其编译为字节码。函数的原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
int be_loadbuffer(bvm *vm, const char *name, const char *buffer, size_t length);
\end{lstlisting}
参数 \texttt{vm} 为虚拟机指针。\texttt{name} 是一个字符串，它通常用来标记源代码的来源，例如从标准输入设备中输入的源代码可以把字符串 \texttt{"stdin"} 传给此参数，而从文件输入的源代码则可以将文件名传给此参数。\texttt{buffer} 参数是存放源代码的缓冲区，这个缓冲区的组织方式和C的字符串很相似，都是字符构成的连续序列，只是 \texttt{buffer} 指向的缓冲区不要求以 \texttt{'\textbackslash 0'} 字符作为结束符。\texttt{length} 参数表示缓冲区长度，这个长度是指缓冲区内源代码文本的字节数量。

举一个简单的例子，如果我们要使用 \texttt{be\_loadbuffer} 函数来编译一个字符串，一般的用法是：
\begin{lstlisting}[language=c, style=berry, numbers=none]
const char *str = "print('Hello Berry')";
be_loadbuffer(vm, "string", str, strlen(str));
\end{lstlisting}
这里我们使用字符串 \texttt{"string"} 来表示源码，你也可以把它修改为任何值。注意这里使用 C 标准库函数 \texttt{strlen} 函数来获取字符串缓冲区长度（其实就是字符串的字节数量）。

如果编译成功，\texttt{be\_loadbuffer} 会把源代码编译成一个 Berry 函数，并把它放在虚拟栈顶部。如果编译遇到错误，\texttt{be\_loadbuffer} 会返回 \texttt{berrorcode} 类型的错误值（\ref{section::errorcode}节），如果可以的话，还会把具体的错误信息字符串存放在虚拟栈顶部。

\ffititle{be\_loadstring}

\texttt{be\_loadstring}是一个宏，其定义为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
#define be_loadstring(vm, str)  be_loadbuffer((vm), "string", (str), strlen(str))
\end{lstlisting}
这个宏只是对 \texttt{be\_loadbuffer} 函数的简单封装。\texttt{vm} 参数是虚拟机实例的指针，\texttt{str} 参数是源代码字符串的指针。使用 \texttt{be\_loadstring} 来编译字符串十分方便，例如：
\begin{lstlisting}[language=c, style=berry, numbers=none]
be_loadstring(vm, "print('Hello Berry')");
\end{lstlisting}
这种写法要比使用 \texttt{be\_loadbuffer} 时简洁，但是必须保证字符串以 \texttt{'\textbackslash 0'} 字符结尾。

\ffititle{be\_loadfile}

这个函数用于编译一个源代码文件。其函数原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
int be_loadfile(bvm *vm, const char *name);
\end{lstlisting}
该函数的作用与 \texttt{be\_loadbuffer} 函数相似，只不过该函数会通过读取源代码文件来进行编译。参数 \texttt{vm} 为虚拟机实例的指针，参数 \texttt{name} 为源文件的文件名。这个函数会调用文件接口，默认情况下会使用 C 标准库中的 \texttt{fopen} 等函数来操作文件。

如果使用 C 标准库的文件接口，你可以使用相对路劲或者绝对路径的文件名。如果文件不存在，\texttt{be\_loadfile} 将返回一个 \texttt{BE\_IO\_ERROR} 错误（\ref{section::errorcode}节），同时会将错误信息压入栈顶。其他的错误信息与 \texttt{be\_loadbuffer} 函数相同。建议用 \texttt{be\_loadfile} 函数来编译源文件，而不要将源文件全部读取到一个缓冲区中，然后调用 \texttt{be\_loadbuffer} 函数编译源代码。前者会分段读取源文件，并只在内存中建立小的读取缓冲区，因而更加节约内存。

\ffititle{be\_top}

这个函数返回虚拟栈中栈顶元素的绝对索引值。这个值也是虚拟栈中的元素数量（虚拟栈的容量）。在未增减虚拟栈中的元素之前调用此函数可以得到原生函数的参数数量。该函数的原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
int be_top(bvm *vm);
\end{lstlisting}

这个函数通常用来获取原生函数的参数数量，用作此目的时，建议在原生函数体的最前面位置调用 \texttt{be\_top}。例如：
\begin{lstlisting}[language=c, style=berry, numbers=none]
static int native_function_example(bvm *vm)
{
    int argc = be_top(vm); // Get the number of arguments
    // ...
}
\end{lstlisting}

\ffititle{be\_typename}

该函数会把 Berry 对象的类型转换为字符串返回，例如对整型对象会返回 \texttt{"int"}，而函数对象会返回 \texttt{"function"}。该函数的原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
const char* be_typename(bvm *vm, int index);
\end{lstlisting}
参数 \texttt{vm} 为虚拟机实例的指针，\texttt{index} 为待操作对象的索引。Berry 标准库中的 \texttt{type} 函数就是通过调用 \texttt{be\_typename} 来实现的，参数类型对应的返回字符串请参看\ref{section::baselib_type}节。

\ffititle{be\_classname}

这个函数用于获取对象或者类的类名，函数原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
const char* be_classname(bvm *vm, int index);
\end{lstlisting}
参数 \texttt{vm} 为虚拟机实例的指针，\texttt{index} 为待操作对象的索引。如果 \texttt{index} 处的值为实例，\texttt{be\_classname} 函数会返回实例所属的类名称字符串，如果 \texttt{index} 处的值为类则直接返回类名称字符串。其他情况下 \texttt{be\_classname} 会返回 \texttt{NULL}。

\ffititle{be\_strlen}

这个函数返回指定 Berry 字符串的长度，函数原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
int be_strlen(bvm *vm, int index);
\end{lstlisting}
参数 \texttt{vm} 为虚拟机实例的指针，\texttt{index} 为待操作对象的索引。该函数返回 \texttt{index} 处字符串的字节数（Berry 字符串尾部的 \texttt{'\textbackslash 0'} 字符不计数）。如果 \texttt{index} 位置的值不是字符串，\texttt{be\_strlen} 函数会返回 \texttt{0}。

虽然 \texttt{Berry} 字符串兼容 C 的字符串格式，但是不建议使用 C 标准库的 \texttt{strlen} 函数来测量 Berry 字符串的长度。对于 Berry 字符串而言，\texttt{be\_strlen} 比 \texttt{strlen} 更快，并且兼容性更好。

\ffititle{be\_strconcat}

这个函数用于拼接两个 Berry 字符串的，函数原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
void be_strconcat(bvm *vm, int index);
\end{lstlisting}
参数 \texttt{vm} 为虚拟机实例的指针。该函数会将 \texttt{index} 参数位置的字符串与栈顶位置的字符串进行拼接，然后将所得的字符串放入 \texttt{index} 索引的位置。

\ffititle{be\_pop}

这个函数会将栈顶的值出栈，函数原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
void be_pop(bvm *vm, int n);
\end{lstlisting}
参数 \texttt{vm} 为虚拟机实例的指针，参数 \texttt{n} 为需要出栈值的数量。注意，\texttt{n} 的值不能超过栈的容量。

\ffititle{be\_remove}

这个函数会移除栈中的某个值，函数原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
void be_remove(bvm *vm, int index);
\end{lstlisting}
参数 \texttt{vm} 为虚拟机实例的指针，参数 \texttt{index} 为待移除对象的索引。将 \texttt{index} 处的值移出后，后面的值会向前填充，栈的容量也会减一。\texttt{index} 的值不能超过栈的容量。

\ffititle{be\_absindex}

这个函数返回给定索引值的绝对索引值，其函数原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
int be_absindex(bvm *vm, int index);
\end{lstlisting}
参数 \texttt{vm} 为虚拟机实例的指针，参数 \texttt{index} 为输入索引值。如果 \texttt{index} 为正值，\texttt{be\_absindex} 的返回值就是 \texttt{index} 的值。如果 \texttt{index} 为负值，texttt{be\_absindex} 的返回值为 \texttt{index} 对应的绝对索引值。当 \texttt{index} 为负值（是相对索引）时，其索引位置不能低于栈底。

\ffititle{be\_newlist}

该函数会建立一个新的 \texttt{list} 值，其函数原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
void be_newlist(bvm *vm);
\end{lstlisting}
参数 \texttt{vm} 为虚拟机实例的指针。该函数成功调用后会将新的 \texttt{list} 值压入栈顶。

\ffititle{be\_newmap}

该函数会建立一个新的 \texttt{map} 值，其函数原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
void be_newmap(bvm *vm);
\end{lstlisting}
参数 \texttt{vm} 为虚拟机实例的指针。该函数成功调用后会将新的 \texttt{map} 值压入栈顶。

\ffititle{be\_getglobal}

该函数会将指定名字的全局变量压入栈中，其函数原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
void be_getglobal(bvm *vm, const char *name);
\end{lstlisting}
参数 \texttt{vm} 为虚拟机实例的指针，参数 \texttt{name} 为全局变量的名字。该函数调用后，会将名为 \texttt{name} 的全局变量压入虚拟栈的栈顶。

\ffititle{be\_setmember}

该函数用于设置实例对象类成员变量的值，函数原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
void be_setmember(bvm *vm, int index, const char *k);
\end{lstlisting}
参数 \texttt{vm} 为虚拟机实例的指针，参数 \texttt{index} 为实例对象的索引，参数 \texttt{k} 为成员的名字。这个函数会把栈顶的值拷贝给索引位置实例的 \texttt{k} 的成员。注意栈顶元素不会自动弹出。

\ffititle{be\_getmember}

该函数用于获取实例对象类成员变量的值，函数原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
void be_getmember(bvm *vm, int index, const char *k);
\end{lstlisting}
参数 \texttt{vm} 为虚拟机实例的指针，参数 \texttt{index} 为实例对象的索引，参数 \texttt{k} 为成员的名字。这个函数会把索引位置实例的 \texttt{k} 的成员的值压入虚拟栈栈顶。

\ffititle{be\_getindex}

该函数用于获取 \texttt{list} 或者 \texttt{map} 中的一项值。函数原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
void be_getindex(bvm *vm, int index);
\end{lstlisting}
参数 \texttt{vm} 是虚拟机实例的指针，参数 \texttt{index} 为待操作对象的索引。这个函数用于从 \texttt{map} 或 \texttt{list} 容器获取一个元素，而元素的下标存储在栈顶（相对索引为 $-1$）。调用此函数后，从容器中获取的值将压入栈顶，如果容器中没有下标指向的则会将 \texttt{nil} 值压入栈顶。举个例子，如果虚拟栈中索引为 $1$ 的元素是一个 \texttt{list}，我们想从中取出下标为 $0$ 的元素，那么可以使用下面的代码：

\begin{lstlisting}[language=c, style=berry]
be_pushint(vm, 0); // Push the index value 0 onto the virtual-stack
be_getindex(vm, 1); // Get an element from the list container
\end{lstlisting}
我们首先将整数值 \texttt{0} 压入栈中，这个值将作为从 \texttt{list} 容器获取元素的下标。第 2 行代码实现了从 \texttt{list} 容器获取元素，示例里的 \texttt{list} 容器在虚拟栈中索引值为 $1$。获取的元素存储在栈顶，我们可以使用相对索引 $-1$ 来访问。

\ffititle{be\_setindex}

该函数用于设置 \texttt{list} 或者 \texttt{map} 中的一项值。函数原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
void be_setindex(bvm *vm, int index);
\end{lstlisting}
参数 \texttt{vm} 是虚拟机实例的指针，参数 \texttt{index} 为待操作对象的下标。这个函数用于写入 \texttt{map} 或 \texttt{list} 容器的一个元素。待写入的值在虚拟栈中的索引为 $-1$，写入位置的下标在虚拟栈中的索引为 $-2$。如果容器中不存在指定下标的元素，写入操作将会失败。

假设虚拟栈中索引为 \texttt{1} 的位置有一个 \texttt{map} 值，并且它有下标为 \texttt{"test"} 的元素，将 \texttt{"test"} 下标处的元素设置为 \texttt{100} 的示例为：
\begin{lstlisting}[language=c, style=berry]
be_pushstring(vm, "test"); // Push the index "index"
be_pushint(vm, 100); // Push the value 100
be_setindex(vm, 1); // Set the key-value pair to map["test"] = 100
\end{lstlisting}
我们要先按顺序将下标和要写入的值压栈，对于 \texttt{map} 来说是键值对（key-value pair），例中前两行代码完成这些工作。第三行调用 \texttt{be\_setindex} 函数将值写入 \texttt{map} 对象中。

\ffititle{be\_getupval}

该函数用于读取原生闭包的一个 Up Value。

\ffititle{be\_setupval}

该函数用于设置原生闭包的一个 Up Value。

\ffititle{be\_getsuper}

该函数用于获取类的基类或者实例的父对象。

\ffititle{be\_data\_size}

该函数用于获取容器的容量。

\ffititle{be\_data\_append}

该函数用于向容器尾部追加一个新的元素。

\ffititle{be\_data\_insert}

该函数用于向容器中插入一个元素。

\ffititle{be\_data\_remove}

该函数用于移除容器中的一个元素。

\ffititle{be\_data\_resize}

该函数用于重新设置容器的容量。

\ffititle{be\_iter\_next}

该函数用与获取迭代器的下一个元素。

\ffititle{be\_iter\_hasnext}

该函数用于测试迭代器中是否还有下一个元素。

\ffititle{be\_refcontains}

\ffititle{be\_refpush}

\ffititle{be\_refpop}

\ffititle{be\_stack\_require}

该函数测试堆栈空闲空间数量，如果不足则扩展堆栈空间。

\ffititle{be\_isnil}

该函数返回虚拟栈中由 \texttt{index} 参数索引的值是否为 \texttt{nil}，如果是则返回 \texttt{1}，否则返回 \texttt{0}。该函数的原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
int be_isnil(bvm *vm, int index);
\end{lstlisting}
参数 \texttt{vm} 为虚拟机实例的指针，\texttt{index} 为待测值的索引。

\ffititle{be\_isbool}

该函数返回虚拟栈中由 \texttt{index} 参数索引的值是否为 \texttt{bool} 类型，如果是则函数返回 \texttt{1}，否则返回 \texttt{0}。该函数的原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
int be_isbool(bvm *vm, int index);
\end{lstlisting}
参数 \texttt{vm} 为虚拟机实例的指针，\texttt{index} 为待测值的索引。

\ffititle{be\_isint}

该函数返回虚拟栈中由 \texttt{index} 参数索引的值是否为整数类型，如果是则返回 \texttt{1}，否则返回 \texttt{0}。该函数的原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
int be_isint(bvm *vm, int index);
\end{lstlisting}
参数 \texttt{vm} 为虚拟机实例的指针，\texttt{index} 为待测值的索引。

\ffititle{be\_isreal}

该函数返回虚拟栈中由 \texttt{index} 参数索引的值是否为实数类型，如果是则返回 \texttt{1}，否则返回 \texttt{0}。该函数的原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
int be_isreal(bvm *vm, int index);
\end{lstlisting}
参数 \texttt{vm} 为虚拟机实例的指针，\texttt{index} 为待测值的索引。

\ffititle{be\_isnumber}

该函数返回虚拟栈中由 \texttt{index} 参数索引的值是否为整数或实数类型，如果是则返回 \texttt{1}，否则返回 \texttt{0}。该函数的原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
int be_isnumber(bvm *vm, int index);
\end{lstlisting}
参数 \texttt{vm} 为虚拟机实例的指针，\texttt{index} 为待测值的索引。

\ffititle{be\_isstring}

该函数返回虚拟栈中由 \texttt{index} 参数索引的值是否为字符串类型，如果是则返回 \texttt{1}，否则返回 \texttt{0}。该函数的原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
int be_isstring(bvm *vm, int index);
\end{lstlisting}
参数 \texttt{vm} 为虚拟机实例的指针，\texttt{index} 为待测值的索引。

\ffititle{be\_isclosure}

该函数返回虚拟栈中由 \texttt{index} 参数索引的值是否为闭包类型，如果是则返回 \texttt{1}，否则返回 \texttt{0}。该函数的原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
int be_isclosure(bvm *vm, int index);
\end{lstlisting}
参数 \texttt{vm} 为虚拟机实例的指针，\texttt{index} 为待测值的索引。

\ffititle{be\_isntvclos}

该函数返回虚拟栈中由 \texttt{index} 参数索引的值是否为原生闭包类型，如果是则返回 \texttt{1}，否则返回 \texttt{0}。该函数的原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
int be_isntvclos(bvm *vm, int index);
\end{lstlisting}
参数 \texttt{vm} 为虚拟机实例的指针，\texttt{index} 为待测值的索引。

\ffititle{be\_isfunction}

该函数返回虚拟栈中由 \texttt{index} 参数索引的值是否为函数类型，如果是则返回 \texttt{1}，否则返回 \texttt{0}。该函数的原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
int be_isfunction(bvm *vm, int index);
\end{lstlisting}
参数 \texttt{vm} 为虚拟机实例的指针，\texttt{index} 为待测值的索引。函数类型包括闭包、原生函数和原生闭包 3 种。

\ffititle{be\_isproto}

该函数返回虚拟栈中由 \texttt{index} 参数索引的值是否为 \texttt{proto} 类型，如果是则返回 \texttt{1}，否则返回 \texttt{0}。该函数的原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
int be_isproto(bvm *vm, int index);
\end{lstlisting}
参数 \texttt{vm} 为虚拟机实例的指针，\texttt{index} 为待测值的索引。\texttt{proto} 类型是 Berry 闭包的函数原型。

\ffititle{be\_isclass}

该函数返回虚拟栈中由 \texttt{index} 参数索引的值是否为 \texttt{class} 类型，如果是则返回 \texttt{1}，否则返回 \texttt{0}。该函数的原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
int be_isclass(bvm *vm, int index);
\end{lstlisting}
参数 \texttt{vm} 为虚拟机实例的指针，\texttt{index} 为待测值的索引。

\ffititle{be\_isinstance}

该函数返回虚拟栈中由 \texttt{index} 参数索引的值是否为 \texttt{instance} 类型，如果是则返回 \texttt{1}，否则返回 \texttt{0}。该函数的原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
int be_isinstance(bvm *vm, int index);
\end{lstlisting}
参数 \texttt{vm} 为虚拟机实例的指针，\texttt{index} 为待测值的索引。

\ffititle{be\_islist}

该函数返回虚拟栈中由 \texttt{index} 参数索引的值是否为 \texttt{list} 类型，如果是则返回 \texttt{1}，否则返回 \texttt{0}。该函数的原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
int be_islist(bvm *vm, int index);
\end{lstlisting}
参数 \texttt{vm} 为虚拟机实例的指针，\texttt{index} 为待测值的索引。

\ffititle{be\_ismap}

该函数返回虚拟栈中由 \texttt{index} 参数索引的值是否为 \texttt{map} 类型，如果是则返回 \texttt{1}，否则返回 \texttt{0}。该函数的原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
int be_ismap(bvm *vm, int index);
\end{lstlisting}
参数 \texttt{vm} 为虚拟机实例的指针，\texttt{index} 为待测值的索引。

\ffititle{be\_iscomptr}

该函数返回虚拟栈中由 \texttt{index} 参数索引的值是否为通用指针类型，如果是则返回 \texttt{1}，否则返回 \texttt{0}。该函数的原型为：
\begin{lstlisting}[language=c, style=berry, numbers=none]
int be_iscomptr(bvm *vm, int index);
\end{lstlisting}
参数 \texttt{vm} 为虚拟机实例的指针，\texttt{index} 为待测值的索引。

\ffititle{be\_toint}

从虚拟栈中获取 \texttt{index} 索引位置的值并作为整数类型返回。该函数不检查类型的正确性。

\ffititle{be\_toreal}

从虚拟栈中获取 \texttt{index} 索引位置的值并作为浮点数类型返回。该函数不检查类型的正确性。

\ffititle{be\_toindex}

从虚拟栈中获取 \texttt{index} 索引位置的值并作为整数类型返回。该函数不检查类型的正确性。与 \texttt{be\_toint} 不同，\texttt{be\_toindex} 的返回值类型为 \texttt{int}，而前者的返回值为 \texttt{bint}。

\ffititle{be\_tobool}

从虚拟栈中获取 \texttt{index} 索引位置的值并作为布尔类型返回。如果被索引的值不是布尔类型，会按照 \ref{section::type_bool} 节的规则进行转换，转换过程不会导致被索引的值发生改变。

\ffititle{be\_tostring}

从虚拟栈中获取 \texttt{index} 索引位置的值并作为字符串类型返回。如果被索引的值不是字符串类型，则会将被索引的值转换为字符串，转换过程会将虚拟栈中被索引位置的值替换为转换后的字符串。该函数返回的字符串总是以 \texttt{'\textbackslash 0'} 字符结尾。

\ffititle{be\_tocomptr}

从虚拟栈中获取 \texttt{index} 索引位置的值并作为通用指针类型返回。该函数不检查类型的正确性。

\ffititle{be\_moveto}

\section{编译期构造技术} \label{section::precompiled_build}

编译期构造技术允许 Berry 解释器在编译时构造原生对象，以减少解释器运行时由于动态构造对象所造成的的内存开销。编译期构造技术带来了多项性能指标的提高，但是这项技术的实现需要依赖外部工具生成解释器的 C 代码，在使用上可能稍有门槛。

编译期构造技术主要由 \textsl{map\_build} 和 \textsl{str\_build} 工具实现，它们位于解释器源码目录的 \textsl{tools/map\_build} 路径和 \textsl{tools/str\_build} 路径下。\textsl{str\_build} 工具用于生成常量字符串，而 \textsl{map\_build} 用于生成常量对象。这些常量字符串和常量对象均会由这些工具生成为 C 代码，并在解释器被编译时一并被编译为常量。从原理上来讲，\textsl{map\_build} 和 \textsl{str\_build} 工具会从常量对象的声明信息（遵守特定的格式）生成代码，该过程会自动计算Hash值并生成Hash表。

解释器工程根目录下的 \textsl{Makefile} 会自动编译这些工具并在编译解释器源代码之前运行工具。该 \textsl{Makefile} 的内容保证了在使用 \texttt{make} 命令时总会通过工具更新编译期构造对象的代码（如果需要更新的话）。通过 \texttt{make prebuild} 命令可以手动生成编译期构造对象的代码，这些代码存储在 \textsl{generate} 文件夹中。

通过修改 \texttt{BE\_USE\_PRECOMPILED\_OBJECT} 宏可以打开或关闭编译期构造。不过无论如何，都会调用 \textsl{str\_build} 和 \textsl{map\_build} 工具来生成常数对象代码（关闭编译期构造时不会使用这些代码）。

\subsubsection{使用命令}

\texttt{map\_build} 工具用于生成常量对象的代码。该命令的使用格式为
\begin{lstlisting}[language=bash, numbers=none]
map_build dst_path src_path
\end{lstlisting}
输出路径 \textsl{dst\_path} 用于存储生成的代码，源路径 \textsl{src\_path} 为需要被扫描源代码的路径列表（多个路劲之间使用空格隔开）。由于解释器的源代码中使用 \textsl{generate} 作为生成代码路径，因此 \textsl{dst\_path} 必须是 \textsl{generate}。以标准的解释器工程为例，\texttt{map\_build} 工具的使用命令应当为
\begin{lstlisting}[language=bash, numbers=none]
map_build generate src default
\end{lstlisting}
该命令的含义是：输出路径为 \textsl{generate}，而源路径为 \textsl{src} 和 \textsl{default}。

\texttt{str\_build} 工具用于生成常量字符串表的代码。
\begin{lstlisting}[language=bash, numbers=none]
str_build dst_path src_path
\end{lstlisting}
与 \texttt{map\_build} 不同，\texttt{str\_build} 还需要扫描前者生成的常量对象代码以生成完整的常量字符串表，因此要在源路径列表中包含 \textsl{generate} 路径。
\begin{lstlisting}[language=bash, numbers=none]
str_build generate src default generate
\end{lstlisting}

\subsubsection{输出路径}

严格来说，用作输出路径的 \textsl{generate} 文件夹并不能放在任意位置，它必须存储在某个包含路径的父目录中。包含路径是指工程中会搜索头文件的路径，以标准的解释器源代码为例，包含路径为 \textsl{src} 和 \textsl{default}。因此标准解释器工程中会将 \textsl{generate} 文件夹存储在解释器源码的根目录中（\textsl{src} 和 \textsl{default} 的父目录）。

存在以上规则的原因是解释器源代码中使用以下代码来引用常量对象：
\begin{lstlisting}[language=c, numbers=none]
#include "../generate/be_fixed_xxx.h"
\end{lstlisting}

如果读者要自己定义常量对象，也需要用这样的代码来包含相应的头文件。本节将介绍如何利用这些工具来定义和使用常量对象。

\subsection{编译期字符串表}

编译期字符串表用于存储常量字符串。常量字符串是对脚本透明的一种对象，它们不会在解释器运行时创建或者销毁，而是一直作为常量存储在解释器程序的数据段中。如果需要将某个字符串作为常量字符串，可以在解释器源代码中在该字符串前加上 \texttt{be\_const\_str\_} 前缀，该声明可以放在源文件的任何位置（包括注释）。例如建立一个内容为 \texttt{"string"} 的常量字符串，需要在源文件中声明符号 \texttt{be\_const\_str\_string}，而该符号也是在 C 代码中引用常量字符串的变量名。

所有的关键字都会建立常量字符串，如果修改 Berry 解释器中关键字相关的代码，则 \textsl{str\_build} 中相应的代码也要修改。

如果字符串中包含特殊符号则无法表示为常量字符串，因为无法写出正确的 C 变量名称。不过某类包含特殊符号字符串可以写出名称，此时要对特殊符号进行转义。以下字符串可以被转义：

\begin{itemize}
    \item 以字符 \texttt{'.'} 开头的字符串，\texttt{'.'} 后的所有字符必须都是字母、数字或下划线。\texttt{'.'} 字符被转义为 \texttt{dot\_}。
    \item 可以被重载的运算符。
\end{itemize}

\subsubsection{使用常量字符串}

通常情况下不需要手动声明常量字符串，也不需要手动去使用它们。如果确实需要手动调用常量字符串，包含头文件 \textsl{be\_constobj.h} 即可使用所有常量字符串变量（这个头文件有所有常量字符串的声明）。常量字符串的典型用途是在编译期构造对象中使用，该过程对常量字符串的声明和定义是由工具自动处理的。

无论何种情况都应该直接用 FFI 函数 \texttt{be\_pushstring} 创建字符串。当一个字符串具有常量字符串时将不会重复创建新的字符串对象，而是直接使用对应的常量字符串。

\subsection{编译期构造对象}

编译期构造的对象也称为常量对象，这些对象的数据结构在编译解释器时构造，而运行时不能修改。\texttt{map\_build} 工具中定义了一套声明规则用于生成常量对象的 C 代码。常量对象的声明信息被直接存放在源文件（\textsl{*.c}）中，为了和其他内容区别，一段完整的声明信息应该包含在以下引导代码中：
\begin{lstlisting}[numbers=none]
@const_object_info_begin
@const_object_info_end
\end{lstlisting}
常量对象声明信息不符合 C 语言语法，因此它们应该放在多行注释中（用 \texttt{/* */} 包含）。所有的所有的常量对象都具有相同的声明形式，一个常量对象的声明结构称为``对象声明块''，其构成为
\begin{lstlisting}[numbers=none]
type object_name (attributes) {
    member_fields
}
\end{lstlisting}
\texttt{type} 为常量对象的类型，它可以是 \texttt{map}、\texttt{class}、\texttt{module} 或者 \texttt{vartab}。\texttt{object\_name} 为常量对象在 C 语言中的变量名。\texttt{attributes} 为常量对象的属性列表，一个属性由属性名和属性值构成，属性名和属性值之间使用分号分隔，多个属性之间使用逗号分隔。例如属性列表 \texttt{scope: global, name: map} 表示某个常量对象的 \texttt{scope} 属性为 \texttt{global}，\texttt{name} 属性为 \texttt{map}。\texttt{member\_fields} 为常量对象的成员域列表，一个成员由名称和值构成，其间使用逗号分隔，每一行可以声明一个成员，多个成员必须在多行中声明。

\textsl{map\_build} 工具使用正则表达式解析对象声明块，解析过程中首先会匹配出整个对象声明块，并从中匹配出 \texttt{type} 和 \texttt{object\_name} 信息，对 \texttt{attributes} 和 \texttt{member\_fields} 信息则要进一步的解析。为了实现方便，该工具对对象声明块的语法要求并不严格，并且缺少完善的错误处理机制，因此在编写对象声明块时应该确保语法正确。

为了方便理解，我们以一个简单的常量类进行说明：
\begin{lstlisting}[language=c]
/* @const_object_info_begin
class be_class_map (scope: global, name: map) {
    .data, var
    init, func(m_init)
    tostring, func(m_tostring)
}
@const_object_info_end */
#include "../generate/be_fixed_be_class_map.h"
\end{lstlisting}
在这个例子中，整个常量类的声明信息位于 C 语言的注释之中，因此不会影响到 C 代码的编译，将对象声明块放置在 \texttt{@const\_object\_info\_begin} 和 \texttt{@const\_object\_info\_end} 中间是为了保证 \textsl{map\_build} 工具能够识别出对象声明块。

由于是声明常量类，对象声明块中的 \textsl{type} 值为 \texttt{class}，\texttt{be\_class\_map} 为该常量对象在 C 代码中的变量名。该对象的属性列表（使用圆括号包围的部分）中声明了两个属性，在本节的``编译期构造类''小节中将会介绍这些属性的含义。使用花括号包围的成员列表中定义了 3 个成员，多个成员之间使用换行分隔，成员的名称和成员的值之间使用逗号分隔。

成员名有以下几种合法的格式：
\begin{itemize}
    \item Berry 变量名格式：使用字母或下划线开头，后面可跟随若干字母、下划线或者数字。
    \item 使用 ``\texttt{.}'' 作为第一个字符，后面跟随若干字母、下划线或者数字。
    \item 可重载的运算符，例如 ``\texttt{+}''、``\texttt{-}'' 和 ``\texttt{<<}'' 等。
\end{itemize}
成员的值则可以是以下类型：
\begin{itemize}
    \item \texttt{var}：这个符号将被编译成一个整数对象（\texttt{be\_const\_int}），整数对象的值从 \texttt{0} 开始自动递增。\texttt{var} 被设计用于类中的成员变量声明，其自动编号的特性用于实现成员变量的序号。
    \item \texttt{func(symbol)}：声明常量对象的原生成员函数或方法。该符号会被编译为一个原生函数值（\texttt{be\_const\_func}），\texttt{symbol} 为成员所对应的原生函数指针。例子中的 \texttt{m\_init} 和 \texttt{m\_tostring} 就是两个原生函数。
    \item \texttt{int(value)}：这个符号将被编译成一个整数对象（\texttt{be\_const\_int}），整数对象的值为 \texttt{value}。
    \item \texttt{real(value)}：这个符号将被编译成一个实数对象（\texttt{be\_const\_real}），实数对象的值为 \texttt{value}。
    \item \texttt{real(value)}：这个符号将被编译成一个实数对象（\texttt{be\_const\_int}），实数对象的值为 \texttt{value}。
    \item \texttt{class(symbol)}：这个符号将被编译成一个类对象（\texttt{be\_const\_class}）。\texttt{symbol} 为该类对象的指针，该指针需要指向一个常量类对象。
    \item \texttt{module(symbol)}：这个符号将被编译成一个模块对象（\texttt{be\_const\_module}）。\texttt{symbol} 为该模块对象的指针，该指针需要指向一个常量模块对象。
\end{itemize}

为了使用 \texttt{be\_class\_map} 对象，我们需要在 C 代码中包含对应的头文件才能保证该对象会被编译，通常的做法是在对象声明块的附近包含相应的头文件，例子中第 8 行就包含了相应的头文件以实现在编译期构造 \texttt{be\_class\_map} 对象。

经过 \textsl{map\_build} 工具的处理，每个对象声明块都会被编译成一个头文件，该文件的命名为 \textsl{be\_fixed\_be\_xxx.h}，\textsl{xxx} 为对象的 C 变量名。为了在 C 代码中编译常量对象，我们需要包含相应的头文件，通常建议在对象声明块的附近包含对应的头文件。例子中的第 8 行就包含了 \textsl{be\_fixed\_be\_class\_map.h} 以实现在编译期构造 \texttt{be\_class\_map} 对象。

\subsubsection{编译期构造 Map}

编译期构造的 Map 也就是常量 \texttt{map} 对象，它们一般不直接使用对象声明块进行声明，而是在其他的编译期构造结构中声明。进行常量 \texttt{map} 的构造时，将常量对象类型信息应当为 \texttt{map}，它支持一个 \texttt{scope} 属性，当 \texttt{scope} 属性值为 \texttt{local} 时，该常量对象是 \texttt{static} 的，属性为 \texttt{global} 时则是 \texttt{extern} 的，该属性的值默认为 \texttt{local}。常量 \texttt{map} 对象的 \texttt{member\_fields} 支持通用的成员名称/成员值规范，且成员值只作为数据存储而不做特殊的解释。下面是使用对象声明块直接声明常量 \texttt{map} 对象的例子：
\begin{lstlisting}
map map_name (scope: local/global) {
    init, func(m_init)
}
\end{lstlisting}

\subsubsection{编译期构造类}

编译期构造类要使用对象声明块进行声明，该对象的类型信息为 \texttt{class}。该对象的声明属性为 \texttt{scope} 和 \texttt{name}。\texttt{scope} 属性声明对象的 C 变量作用域，值为 \texttt{local}（默认）时作用域为 \texttt{static}，为 \texttt{global} 时作用域为 \texttt{extern}；\texttt{name} 属性的值是该类的名称，匿名类可以省略该参数。由于类的属性列表只存储方法和成员变量索引，因此编译期构造类的 \texttt{member\_fields} 只能使用 \texttt{var} 和 \texttt{func()} 值。一个简单的编译期构造类声明块为：
\begin{lstlisting}
class be_class_map (scope: global, name: map) {
    .data, var
    init, func(m_init)
    tostring, func(m_tostring)
}
\end{lstlisting}

\subsubsection{编译期构造模块}

编译期构造模块声明块的类型信息为 \texttt{module}。

\begin{lstlisting}
module math (scope: global) {
    sin, func(m_sin)
    cos, func(m_cos)
    pi, real(M_PI)
}
\end{lstlisting}

\subsubsection{编译期构造 Built-in 域}

\begin{lstlisting}
vartab m_builtin (scope: local) {
    assert, func(l_assert)
    print, func(l_print)
    list, class(be_class_list)
}
\end{lstlisting}
