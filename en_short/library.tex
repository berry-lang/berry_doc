\section*{Basic Library}

\subsection*{Global Functions}

\hangpar \texttt{assert(}\textib{expr} [\texttt{,} \textib{msg}]\texttt{)}\\
Throw \texttt{'assert\_failed'} when \textib{expr} is \textbf{false}, and \textib{msg} is an optional exception message.

\hangpar \texttt{print(}\dots\texttt{)}\\
Print all arguments to stdout.

\hangpar \texttt{input(}[\textib{prompt}]\texttt{)}\\
Read a line of text from stdin, \textib{prompt} is optional prompt message.

\hangpar \texttt{super(}\textib{object}\texttt{)}\\
Get the super class of \textib{object}. The \textib{object} is a class or an instance.

\hangpar \texttt{type(}\textib{expr}\texttt{)}\\
Get the type name string of \textib{expr}.

\hangpar \texttt{classname(}\textib{object}\texttt{)}\\
Get the class name of \textib{object}. The \textib{object} is a class or an instance.

\hangpar \texttt{classof(}\textib{object}\texttt{)}\\
Get the class of \textib{object}, and return nil when it fails.

\hangpar \texttt{number(}\textib{expr}\texttt{)}\quad \hangpar \texttt{int(}\textib{expr}\texttt{)}\quad \hangpar \texttt{real(}\textib{expr}\texttt{)}\\
Convert \textib{expr} to a number (automatically detect integer or real), integer or real respectively, and return \texttt{0} or \texttt{0.0} if the conversion fails.

\hangpar \texttt{str(}\textib{expr}\texttt{)}\\
Convert \textib{expr} to a string. For instance, it will try to call the \texttt{tostring} method.

\hangpar \texttt{bool(}\textib{expr}\texttt{)}\\
Convert \textib{expr} to a bool.

\hangpar \texttt{module(}[\textib{name}]\texttt{)}\\
Create an empty module, and name is an optional module name.

\hangpar \texttt{size(}\textib{expr}\texttt{)}\\
Get the length of the string or instance (by calling the \texttt{size} method).

\hangpar \texttt{compile(}\textib{text} [\texttt{,} \textib{mode}]\texttt{)}\\
When \textib{mode} is \texttt{'string'}, \textib{text} is evaluated as a script, and when \textib{mode} is \texttt{'file'}, a script file whose path is \textib{text} is read and evaluated. The mode is \texttt{'string'} by default.

\hangpar \texttt{issubclass(}\textib{sub}\texttt{,} \textib{sup}\texttt{)}\\
Returns \texttt{true} if \textib{sub} (class) is \textib{sup} (class or instance) or its derived class, otherwise return \texttt{false}.

\hangpar \texttt{isinstance(}\textib{obj}\texttt{,} \textib{base}\texttt{)}\\
Returns \texttt{true} if \textib{obj} is an instance of \textib{base} (class or instance) or its derived class, otherwise return \texttt{false}.

\hangpar \texttt{call(}\textib{function}\texttt{[, }\textib{args}\texttt{ ]}\texttt{[, }\textib{list}\texttt{ ]}\texttt{)}\\
Call a \textib{function} with arbitrary number of arguments, all \textib{args} are pushed as static arguments. If the last argument is a \textib{list}, all elements are pushed as elementary arguments.

\hangpar \texttt{open(}\textib{path}[\texttt{,} \textib{mode}]\texttt{)}\\
Open a file by \textib{path} and return an instance of this file. The file is opened in the specified \textib{mode}:\\
\begin{tabular}{@{}lp{0.82\columnwidth}}
    \texttt{'r'} & \textsf{read}-only mode, the file must exist. \\
    \texttt{'w'} & \textsf{write}-only mode, always create a empty file. \\
    \texttt{'a'} & Create a empty file or \textsf{append} to the end of an existing file. \\
    \texttt{'r+'} & \textsf{read}-\textsf{write} mode, the file must exist. \\
    \texttt{'w+'} & \textsf{read}-\textsf{write} mode, always create a empty file. \\
    \texttt{'a+'} & \textsf{read}-\textsf{write} mode, create a empty file or \textsf{append} to the end of an existing file. \\
    \texttt{'b'} & \textsf{binary} mode, it can be combined with other access modes. \\
\end{tabular}

\subsection*{File Members}

\hangpar \texttt{file.write(}\textib{string} | \textib{bytes}\texttt{)}\\
Write the \textib{text} or\textib{raw bytes} to the file.

\hangpar \texttt{file.read(}[\textib{count}]\texttt{)}\\
If the \textib{count} is specified, the number of bytes will be read, otherwise the entire file will be read.

\hangpar \texttt{file.readbytes(}[\textib{count}]\texttt{)}\\
Retruns raw bytes instead of string. If the \textib{count} is specified, the number of bytes will be read, otherwise the entire file will be read.

\hangpar \texttt{file.readline()}\\
Read a line from the file (the newline character is determined by the platform).

\hangpar \texttt{file.seek(}\textib{offset}\texttt{)}\\
Set the file pointer to \textib{offset}.

\hangpar \texttt{file.tell()}\\
Get the offset of the file pointer.

\hangpar \texttt{file.size()}\\
Get the size of the file.

\hangpar \texttt{file.flush()}\\
Flush the file buffer.

\hangpar \texttt{file.close()}\\
Close the file.

\subsection*{List Members}

\hangpar  \texttt{list[}\textib{index}\texttt{]}\\
Can be used to read or write at \textib{index}, raises an exception if index is out of bounds. Equivalent to \texttt{list.item()} and \texttt{list.setitem()}.

\hangpar  \texttt{list[}\textib{a} \texttt{..} \textib{b}\texttt{]}\\
Returns a sub-list containing elements from index \textib{a} to \textib{b} included. If \textib{b} is omitted it includes all elements to the end of thelist. If \textib{b} is negative, it counts from the end of the list (ex \texttt{list[1 .. -2]} removes the first and last elements). Equivalent to \texttt{list.item()}.

\hangpar  \texttt{list[}\textib{list}\texttt{]}\\
Returns a sub-list from the indices of the list, returns \texttt{nil} element if an index is out of bounds. Equivalent to \texttt{list.item()}.

\hangpar \texttt{list()} or \texttt{list(}\textib{args}\texttt{)}\\
Constructor, put the elements in \textib{args} into list one by one.

\hangpar \texttt{list.tostring()}\\
Serialized the list instance.

\hangpar \texttt{list.push(}\textib{value}\texttt{)}\\
Append the \textib{value} to the tail of the list.

\hangpar \texttt{list.pop(}[\textib{index}]\texttt{)}\\
Remove the element at \textib{index} (the default index is $-1$) from the list.

\hangpar \texttt{list.insert(}\textib{index}\texttt{,} \textib{value}\texttt{)}\\
Insert the \textib{value} before the element at \textib{index}.

\hangpar \texttt{list.item(}\textib{index}\texttt{)}\\
Get the element at \textib{index}. The \textib{index} can be an \textsf{integer}, and a \textsf{list} or \textsf{range} instance, raises an exception if index is out of bounds.

\hangpar \texttt{list.setitem(}\textib{index}\texttt{,} \textib{value}\texttt{)}\\
Set the element referenced at \textib{index} to \textib{value}, raises an exception if index is out of bounds.

\hangpar \texttt{list.size()}\\
Get the number of elements in the list instance.

\hangpar \texttt{list.resize(}\textib{expr}\texttt{)}\\
Modify the number of elements to the value of \textib{expr}. The added elements are set to \texttt{nil}, and the reduced elements are discarded.

\hangpar \texttt{list.clear()}\\
Clear all elements in the list instance.

\hangpar \texttt{list.iter()}\\
Get the iterator function of the list instance.

\hangpar \texttt{list.keys()}\\
Return a \texttt{range} object containing indices of the list.

\hangpar \texttt{list.concat()}\\
Serialize and concatenate all elements in the list instance into a string.

\hangpar \texttt{list.reverse()}\\
Reverse the order of all elements in the list instance.

\hangpar \texttt{list.copy()}\\
Copy the list instance, not copy the element but keep the reference.

\hangpar \texttt{list() .. }\textib{expr}\\
Append the value of \textib{expr} to the tail of the list instance and return that instance.

\hangpar \texttt{list() + }\texttt{list()}\\
Concatenate two list instances and return the left operand instance.

\hangpar \texttt{list() == }\textib{expr}\\
Check if two list instances are equal. It checks all elements one by one.

\hangpar \texttt{list() != }\textib{expr}\\
Check if two list instances are not equal. It checks all elements one by one.

\subsection*{Map Members}

\hangpar \texttt{map.init()}\\
Constructor.

\hangpar \texttt{map.tostring()}\\
Serialized the map instance.

\hangpar \texttt{map.insert(}\textib{key}\texttt{,} \textib{value}\texttt{)}\\
Insert a key-value pair and return \texttt{true}, and return \texttt{false} when the insertion fails (e.g. the pair already exists).

\hangpar \texttt{map.remove(}\textib{key}\texttt{)}\\
Remove the key-value pair by the \textib{key}.

\hangpar \texttt{map.item(}\textib{key}\texttt{)}\\
Get the value mapped by the \textib{key}. It will throw a \texttt{"key\_error"} exception when the key-value pair does not exist.

\hangpar \texttt{map.setitem(}\textib{key}\texttt{,} \textib{value}\texttt{)}\\
Set the \textib{value} mapped by the \textib{key}. If the key-value pair does not exist, a new one will be inserted.

\hangpar \texttt{map.insert(}\textib{key}\texttt{,} \textib{value}\texttt{)}\\
Set the \textib{value} mapped by the \textib{key} only if \textib{key} does not exist, and returns \texttt{true}. Returns \texttt{false} and do not update the value if \textib{key} already exists.

\hangpar \texttt{map.find(}\textib{key}\texttt{)}\\
Get the value mapped by the \textib{key}. It will return \texttt{nil} when the key-value pair does not exist.

\hangpar \texttt{map.size()}\\
Get the number of key-value pairs in the map instance.

\hangpar \texttt{map.iter()}\\
Get the iterator function over the values of the map instance. 

\hangpar \texttt{map.keys()}\\
Get the iterator function over the keys of the map instance. 

\hangpar \texttt{map.contains(}\textib{key}\texttt{)}\\
Returns \texttt{true} if the map contains the \textib{key}.

\subsection*{Range Members}

\hangpar \texttt{range.init(}\textib{lower}\texttt{,} \textib{upper}\{, \textib{increment}\}\texttt{)}\\
The constructor. The range is from \textib{lower} to \textib{upper}, and the step is $1$ or \textib{increment}. \textib{increment} can be negative.

\hangpar \texttt{range.tostring()}\\
Serialized the rang instance.
\hangpar \texttt{range.iter()}\\
Get the value iterator function of the range instance. 

\hangpar \texttt{range.lower()}\\
Get the \textib{lower} value of the range instance.

\hangpar \texttt{range.upper()}\\
Get the \textib{upper} value of the range instance.

\hangpar \texttt{range.incr()}\\
Get the \textib{increment} value of the range instance.

\hangpar \texttt{range.setrange(}\textib{lower}\texttt{,} \textib{upper}\{, \textib{increment}\}\texttt{)}\\
Changes the \textib{lower}, \textib{upper}, and \textib{increment}, does not change an existing iterator.

\section*{The String Library}

\subsection*{Import Module}

\hangpar \texttt{\textbf{import} string}

\subsection*{Basic operations}

\hangpar \texttt{string.count(}\textib{s}\texttt{,} \textib{sub}[\texttt{,} \textib{begin}[\texttt{,} \textib{end}]]\texttt{)}\\
Count the number of occurrences of the \textib{sub} string in the string \textib{s}. Search from the position between \textib{begin} and \textib{end} of \textib{s} (default is $0$ and \texttt{size(}\textib{s}\texttt{)}).

\hangpar \texttt{string.split(}\textib{s}\texttt{,} \textib{pos}\texttt{)}\\
Split the string \textib{s} into two substrings at position \textib{pos}, and returns the list of those strings.

\hangpar \texttt{string.split(}\textib{s}\texttt{,} \textib{sep}[\texttt{,} \textib{num}]\texttt{)}\\
Splits the string \textib{s} into substrings wherever \textib{sep} occurs, and returns the list of those strings. Split at most \textib{num} times (default is \texttt{string.count(}\textib{s}\texttt{,} \textib{sep}\texttt{)}).

\hangpar \texttt{string.find(}\textib{s}\texttt{,} \textib{sub}[\texttt{,} \textib{begin}[\texttt{,} \textib{end}]]\texttt{)}\\
Check whether the string \textib{s} contains the substring \textib{sub}. If the \textib{begin} and \textib{end} (default is $0$ and \texttt{size(}\textib{s}\texttt{)}) are specified, they will be searched in this range. Returns $-1$ if not found.

\hangpar \texttt{string.hex(}\textib{number}\texttt{)}\\
Convert \textib{number} to hexadecimal string.

\hangpar \texttt{string.byte(}\textib{s}\texttt{)}\\
Get the code value of the first byte of the string \textib{s}.

\hangpar \texttt{string.char(}\textib{number}\texttt{)}\\
Convert the \textib{number} used as the code to a character.

\subsection*{Transformation}

\hangpar \texttt{string.toupper(}\textib{text}\texttt{)} \texttt{string.tolower(}\textib{text}\texttt{)}\\
Convert the \textib{text} to uppercase or lowercase; ASCII only no support for Unicode.

\hangpar \texttt{string.tr(}\textib{char}\texttt{, }\textib{char\_or\_empty\_string}\texttt{)}\\
Replaces any occurrence of single character \textib{char} to another character, or remove if empty string.

\hangpar \texttt{string.replace(}\textib{text1}\texttt{, }\textib{text2}\texttt{)}\\
Replaces any occurrence of \textib{text1} with \textib{text2} (this is slower than \texttt{string.tr()}

\hangpar \texttt{string.escape(}\textib{text}\texttt{[, }\textib{berry\_mode}\texttt{] )}\\
Escapes the string with double quotes suitable for C, if \textib{berry\_mode} is \texttt{true} escape to single quotes suitable for Berry.

\subsection*{Formatting}

\hangpar \texttt{string.format(}\textib{fmt}[\texttt{,} \textib{args}]\texttt{)}

\hangpar \texttt{format(}\textib{fmt}[\texttt{,} \textib{args}]\texttt{)}\\
Returns a formatted string. The pattern starting with \texttt{'\%'} in the formatting template \textib{fmt} will be replaced by the value of [\textib{args}]: \texttt{\%}[\textsf{flags}][\textsf{fieldwidth}][\texttt{.}\textsf{precision}]\textsf{type}\\

\hangpar \textsf{Types}\\
\begin{tabular}{@{}llp{0.77\columnwidth}}
    \texttt{\%d} & & Decimal integer. \\
    \texttt{\%o} & & Octal integer. \\
    \texttt{\%x} & \texttt{\%X} & Hexadecimal integer lowercase, uppercase. \\
    \texttt{\%x} & \texttt{\%X} & Octal integer. \\
    \texttt{\%f} & & Floating-point in the form [-]nnnn.nnnn. \\
    \texttt{\%e} & \texttt{\%E} & Floating-point in exp. form [-]n.nnnn e [+|-]nnn,
    uppercase if \texttt{\%E}. \\
    \texttt{\%g} & \texttt{\%G} & Floating-point as \texttt{\%f} if $-4<\rm{exp.}\leq precision$, else as \texttt{\%e}; uppercase if \texttt{\%G}. \\
    \texttt{\%c} & & Character having the code passed as integer. \\
    \texttt{\%s} & & String with no embedded zeros. \\
    \texttt{\%\%} & & The \texttt{'\%'} character (escaped). \\
\end{tabular}\\

\hangpar \textsf{Flags}\\
\begin{tabular}{@{}lp{0.77\columnwidth}}
\texttt{-} & Left-justifies, default is right-justify. \\
\texttt{+} & Prepends sign (applies to numbers). \\
(space) & Prepends sign if negative, else space. \\
\texttt{\#} & Adds \texttt{"0x"} before \texttt{\%x}, force decimal point; for \texttt{\%e}, \texttt{\%f}, leaves trailing zeros for \texttt{\%g}. \\
\end{tabular}\\

\hangpar \textsf{Field width} and \textsf{precision}\\
\begin{tabular}{@{}lp{0.84\columnwidth}}
\textsf{n} & Puts at least \textsf{n} characters, pad with blanks. \\
\textsf{0n} & Puts at least \textsf{n} characters, left-pad with zeros. \\
\textsf{.n} & Use at least \textsf{n} digits for integers, rounds to \textsf{n} decimals for floating-point or no more than \textsf{n} chars. for strings. \\
\end{tabular}

\section*{The Global module}

\hangpar \texttt{\textbf{import} global}\\

\hangpar \texttt{global()}\\
Returns the list of all global variables.

\hangpar \texttt{global.contains(}\textib{id}\texttt{)} \\
Returns \texttt{true} if the global variables exists.

\hangpar \texttt{global.member(}\textib{id}\texttt{)}

\hangpar \texttt{global.}\textib{id} \\
Returns value of global variable \textib{id} or \texttt{nil} if it does not exists.

\hangpar \texttt{global.setmember(}\textib{id}\texttt{, }\textib{value}\texttt{)}

\hangpar \texttt{global.}\textib{id}\texttt{ = }\textib{value} \\
Sets global variable \textib{id} to \textib{value}, create the global variable if needed.

\section*{The JSON Library}

\hangpar \texttt{json.load(}\textib{string}\texttt{)} \\
Concatenate \textib{string} into a complete path.

\hangpar \texttt{json.dump(}\textib{any}\texttt{)} \\
Converts \textib{ant} to a JSON string.

\section*{The Instrospect Library}

\hangpar \texttt{\textbf{import} introspect}\\

\hangpar \texttt{introspect.members(}\textib{any}\texttt{)} \\
Returns the list of names of members for the \texttt{class}, \texttt{instance} or \texttt{module}.

\hangpar \texttt{introspect.members()} \\
Returns the list of global variables, equivalent to \texttt{global()}.

\hangpar \texttt{introspect.get(}\textib{any}\texttt{, }\textib{id}\texttt{)} \\
Reads the attribute \textib{id} for \textib{any}, returns \texttt{nil} if key does not exist.

\hangpar \texttt{introspect.set(}\textib{any}\texttt{, }\textib{id}\texttt{, }\textib{value}\texttt{)} \\
Sets the attribute \textib{id} for \textib{any} to \textib{value}.

\hangpar \texttt{introspect.name(}\textib{any}\texttt{)} \\
Returns the name of \texttt{any} (function, class or module) or \textib{nil}.

\hangpar \texttt{introspect.ismethod(}\textib{function}\texttt{)} \\
Returns \texttt{true} if the \textib{function} is a method of a class, \texttt{false} it it's a standalone function.

\hangpar \texttt{introspect.module(}\textib{name}\texttt{)} \\
Imports module passed by \textib{name}.

\hangpar \texttt{introspect.setmodule(}\textib{name}\texttt{, }\textib{any}\texttt{)} \\
Changes the value for module \textib{name}; use with caution as it can disrupt the runtime.

\hangpar \texttt{introspect.toptr(}\textib{int}\texttt{)}  \texttt{introspect.fromptr(}\textib{comptr}\texttt{)} \\
Converts an \textib{int} to \textib{comptr} and backwards, works only for platforms where integers and pointers are the same size.

\section*{The OS Library}

\hangpar \texttt{os.getcmd()} \\
Get the path of the current directory.

\hangpar \texttt{os.chdir(}\textib{path}\texttt{)} \\
Switch the current folder to the \textib{path}.

\hangpar \texttt{os.mkdir(}\textib{path}\texttt{)} \\
Create a level of directory (with \textib{path}).

\hangpar \texttt{os.remove(}\textib{path}\texttt{)} \\
Delete file of directory form \textib{path}.

\hangpar \texttt{os.listdir(}[\textib{path}]\texttt{)} \\
Return a list of file and folder names contained in the specified \textib{path} (the default is \texttt{'.'}).

\hangpar \texttt{os.system(}\textib{cmd}[\texttt{,} \textib{args}]\texttt{)} \\
Execute a system command.

\hangpar \texttt{os.exit()}\\
Exit the interpreter process.

\subsection*{The \texttt{os.path} Module}

\hangpar \texttt{os.path.isdir(}\textib{path}\texttt{)} \\
Check if the \textib{path} is a folder.

\hangpar \texttt{os.path.isfile(}\textib{path}\texttt{)} \\
Check if the \textib{path} is a file.

\hangpar \texttt{os.path.exists(}\textib{path}\texttt{)} \\
Check if the \textib{path} already exists.

\hangpar \texttt{os.path.split(}\textib{path}\texttt{)} \\
Split the \textib{path} into dir-name and base-name.

\hangpar \texttt{os.path.splitext(}\textib{path}\texttt{)} \\
Split the \textib{path} into file-name and ext-name.

\hangpar \texttt{os.path.splitext(}\textib{args}\texttt{)} \\
Concatenate \textib{args} into a complete path.
