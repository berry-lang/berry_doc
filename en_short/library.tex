\section*{Basic Library}

\subsection*{Global Functions}

\hangpar \texttt{assert(}\textib{expr} [\texttt{,} \textib{msg}]\texttt{)}\\
Throw \texttt{'assert\_failed'} when \textib{expr} is \textbf{false}, and \textib{msg} is an optional exception message.

\hangpar \texttt{print(}\dots\texttt{)}\\
Print all arguments to stdout.

\hangpar \texttt{input(}[\textib{prompt}]\texttt{)}\\
Read a line of text from stdin, \textib{prompt} is optional prompt message.

\hangpar \texttt{super(}\textib{object}\texttt{)}\\
Get the super class of \textib{object}. The \textib{object} is a class or an instance.

\hangpar \texttt{type(}\textib{expr}\texttt{)}\\
Get the type name string of \textib{expr}.

\hangpar \texttt{classname(}\textib{object}\texttt{)}\\
Get the class name of \textib{object}. The \textib{object} is a class or an instance.

\hangpar \texttt{classof(}\textib{object}\texttt{)}\\
Get the class of \textib{object}, and return nil when it fails.

\hangpar \texttt{number(}\textib{expr}\texttt{)}\quad \hangpar \texttt{int(}\textib{expr}\texttt{)}\quad \hangpar \texttt{real(}\textib{expr}\texttt{)}\\
Convert \textib{expr} to a number (automatically detect integer or real), integer or real respectively, and return \texttt{0} or \texttt{0.0} if the conversion fails.

\hangpar \texttt{str(}\textib{expr}\texttt{)}\\
Convert \textib{expr} to a string. For instance, it will try to call the \texttt{tostring} method.

\hangpar \texttt{module(}[\textib{name}]\texttt{)}\\
Create an empty module, and name is an optional module name.

\hangpar \texttt{size(}\textib{expr}\texttt{)}\\
Get the length of the string or instance (by calling the \texttt{size} method).

\hangpar \texttt{compile(}\textib{text} [\texttt{,} \textib{mode}]\texttt{)}\\
When \textib{mode} is \texttt{'string'}, \textib{text} is evaluated as a script, and when \textib{mode} is \texttt{'file'}, a script file whose path is \textib{text} is read and evaluated. The mode is \texttt{'string'} by default.

\hangpar \texttt{issubclass(}\textib{sub}\texttt{,} \textib{sup}\texttt{)}\\
Returns \texttt{true} if \textib{sub} (class) is \textib{sup} (class or instance) or its derived class, otherwise return \texttt{false}.

\hangpar \texttt{isinstance(}\textib{obj}\texttt{,} \textib{base}\texttt{)}\\
Returns \texttt{true} if \textib{obj} is an instance of \textib{base} (class or instance) or its derived class, otherwise return \texttt{false}.

\hangpar \texttt{open(}\textib{path}[\texttt{,} \textib{mode}]\texttt{)}\\
Open a file by \textib{path} and return an instance of this file. The file is opened in the specified \textib{mode}:\\
\begin{tabular}{@{}lp{0.82\columnwidth}}
    \texttt{'r'} & \textsf{read}-only mode, the file must exist. \\
    \texttt{'w'} & \textsf{write}-only mode, always create a empty file. \\
    \texttt{'a'} & Create a empty file or \textsf{append} to the end of an existing file. \\
    \texttt{'r+'} & \textsf{read}-\textsf{write} mode, the file must exist. \\
    \texttt{'w+'} & \textsf{read}-\textsf{write} mode, always create a empty file. \\
    \texttt{'a+'} & \textsf{read}-\textsf{write} mode, create a empty file or \textsf{append} to the end of an existing file. \\
    \texttt{'b'} & \textsf{binary} mode, it can be combined with other access modes. \\
\end{tabular}

\subsection*{File Members}

\hangpar \texttt{file.write(}\textib{text}\texttt{)}\\
Write the \textib{text} to the file.

\hangpar \texttt{file.read(}[\textib{count}]\texttt{)}\\
If the \textib{count} is specified, the number of bytes will be read, otherwise the entire file will be read.

\hangpar \texttt{file.readline()}\\
Read a line from the file (the newline character is determined by the platform).

\hangpar \texttt{file.seek(}\textib{offset}\texttt{)}\\
Set the file pointer to \textib{offset}.

\hangpar \texttt{file.tell()}\\
Get the offset of the file pointer.

\hangpar \texttt{file.size()}\\
Get the size of the file.

\hangpar \texttt{file.flush()}\\
Flush the file buffer.

\hangpar \texttt{file.close()}\\
Close the file.

\subsection*{List Members}

\hangpar \texttt{list.init(}\textib{args}\texttt{)}\\
Constructor, put the elements in \textib{args} into list one by one.

\hangpar \texttt{list.tostring()}\\
Serialized the list instance.

\hangpar \texttt{list.push(}\textib{value}\texttt{)}\\
Append the \textib{value} to the tail of the list.

\hangpar \texttt{list.pop(}[\textib{index}]\texttt{)}\\
Remove the element at \textib{index} (the default index is $-1$) from the list.

\hangpar \texttt{list.insert(}\textib{index}\texttt{,} \textib{value}\texttt{)}\\
Insert the \textib{value} before the element at \textib{index}.

\hangpar \texttt{list.item(}\textib{index}\texttt{)}\\
Get the element at \textib{index}. The \textib{index} can be an \textsf{integer}, and a \textsf{list} or \textsf{range} instance.

\hangpar \texttt{list.setitem}\textib{index}\texttt{,} \textib{value}\texttt{)}\\
Set the element referenced at \textib{index} to \textib{value}.

\hangpar \texttt{list.size()}\\
Get the number of elements in the list instance.

\hangpar \texttt{list.resize(}\textib{expr}\texttt{)}\\
Modify the number of elements to the value of \textib{expr}. The added elements are set to \texttt{nil}, and the reduced elements are discarded.

\hangpar \texttt{list.clear()}\\
Clear all elements in the list instance.

\hangpar \texttt{list.iter()}\\
Get the iterator function of the list instance.

\hangpar \texttt{list.concat()}\\
Serialize and concatenate all elements in the list instance into a string.

\hangpar \texttt{list.reverse()}\\
Reverse the order of all elements in the list instance.

\hangpar \texttt{list.copy()}\\
Copy the list instance, not copy the element but keep the reference.

\hangpar \texttt{list() .. }\textib{expr}\\
Append the value of \textib{expr} to the tail of the list instance and return that instance.

\hangpar \texttt{list() + }\texttt{list()}\\
Concatenate two list instances and return the left operand instance.

\hangpar \texttt{list() == }\textib{expr}\\
Check if two list instances are equal. It checks all elements one by one.

\hangpar \texttt{list() != }\textib{expr}\\
Check if two list instances are not equal. It checks all elements one by one.

\subsection*{Map Members}

\hangpar \texttt{map.init()}\\
Constructor.

\hangpar \texttt{map.tostring()}\\
Serialized the map instance.

\hangpar \texttt{map.insert(}\textib{key}\texttt{,} \textib{value}\texttt{)}\\
Insert a key-value pair and return \texttt{true}, and return \texttt{false} when the insertion fails (e.g. the pair already exists).

\hangpar \texttt{map.remove(}\textib{key}\texttt{)}\\
Remove the key-value pair by the \textib{key}.

\hangpar \texttt{map.item(}\textib{key}\texttt{)}\\
Get the value mapped by the \textib{key}. It will throw a \texttt{"key\_error"} exception when the key-value pair does not exist.

\hangpar \texttt{map.setitem(}\textib{key}\texttt{,} \textib{value}\texttt{)}\\
Set the \textib{value} mapped by the \textib{key}. If the key-value pair does not exist, a new one will be inserted.

\hangpar \texttt{map.find(}\textib{key}\texttt{)}\\
Get the value mapped by the \textib{key}. It will return \texttt{nil} when the key-value pair does not exist.

\hangpar \texttt{map.size()}\\
Get the number of key-value pairs in the map instance.

\hangpar \texttt{map.iter()}\\
Get the value iterator function of the map instance. 

\subsection*{Range Members}

\hangpar \texttt{rang.init(}\textib{lower}\texttt{,} \textib{upper}\texttt{)}\\
The constructor. The range is from \textib{lower} to \textib{upper}, and the step is $1$.

\hangpar \texttt{rang.tostring()}\\
Serialized the rang instance.

\hangpar \texttt{rang.lower()}\\
Get the \textib{lower} value of the range instance.

\hangpar \texttt{rang.upper()}\\
Get the \textib{upper} value of the range instance.

\hangpar \texttt{rang.iter()}\\
Get the value iterator function of the range instance. 

\section*{The String Library}

\subsection*{Import Module}

\hangpar \texttt{\textbf{import} string}

\subsection*{Basic operations}

\hangpar \texttt{string.count(}\textib{s}\texttt{,} \textib{sub}[\texttt{,} \textib{begin}[\texttt{,} \textib{end}]]\texttt{)}\\
Count the number of occurrences of the \textib{sub} string in the string \textib{s}. Search from the position between \textib{begin} and \textib{end} of \textib{s} (default is $0$ and \texttt{size(}\textib{s}\texttt{)}).

\hangpar \texttt{string.split(}\textib{s}\texttt{,} \textib{pos}\texttt{)}\\
Split the string \textib{s} into two substrings at position \textib{pos}, and returns the list of those strings.

\hangpar \texttt{string.split(}\textib{s}\texttt{,} \textib{sep}[\texttt{,} \textib{num}]\texttt{)}\\
Splits the string \textib{s} into substrings wherever \textib{sep} occurs, and returns the list of those strings. Split at most \textib{num} times (default is \texttt{string.count(}\textib{s}\texttt{,} \textib{sep}\texttt{)}).

\hangpar \texttt{string.find(}\textib{s}\texttt{,} \textib{sub}[\texttt{,} \textib{begin}[\texttt{,} \textib{end}]]\texttt{)}\\
Check whether the string \textib{s} contains the substring \textib{sub}. If the \textib{begin} and \textib{end} (default is $0$ and \texttt{size(}\textib{s}\texttt{)}) are specified, they will be searched in this range.

\hangpar \texttt{hex(}\textib{number}\texttt{)}\\
Convert \textib{number} to hexadecimal string.

\hangpar \texttt{byte(}\textib{s}\texttt{)}\\
Get the code value of the first byte of the string \textib{s}.

\hangpar \texttt{char(}\textib{number}\texttt{)}\\
Convert the \textib{number} used as the code to a character.

\subsection*{Formatting}

\hangpar \texttt{string.format(}\textib{fmt}[\texttt{,} \textib{args}]\texttt{)}\\
Returns a formatted string. The pattern starting with \texttt{'\%'} in the formatting template \textib{fmt} will be replaced by the value of [\textib{args}]: \texttt{\%}[\textsf{flags}][\textsf{fieldwidth}][\texttt{.}\textsf{precision}]\textsf{type}

\hangpar \textsf{Types}\\
\begin{tabular}{@{}llp{0.77\columnwidth}}
    \texttt{\%d} & & Decimal integer. \\
    \texttt{\%o} & & Octal integer. \\
    \texttt{\%x} & \texttt{\%X} & Hexadecimal integer lowercase, uppercase. \\
    \texttt{\%x} & \texttt{\%X} & Octal integer. \\
    \texttt{\%f} & & Floating-point in the form [-]nnnn.nnnn. \\
    \texttt{\%e} & \texttt{\%E} & Floating-point in exp. form [-]n.nnnn e [+|-]nnn,
    uppercase if \texttt{\%E}. \\
    \texttt{\%g} & \texttt{\%G} & Floating-point as \texttt{\%f} if $-4<\rm{exp.}\leq precision$, else as \texttt{\%e}; uppercase if \texttt{\%G}. \\
    \texttt{\%c} & & Character having the code passed as integer. \\
    \texttt{\%s} & & String with no embedded zeros. \\
    \texttt{\%q} & & String between double quotes, with special characters escaped. \\
    \texttt{\%\%} & & The \texttt{'\%'} character (escaped). \\
\end{tabular}

\hangpar \textsf{Flags}\\
\begin{tabular}{@{}lp{0.77\columnwidth}}
\texttt{-} & Left-justifies, default is right-justify. \\
\texttt{+} & Prepends sign (applies to numbers). \\
(space) & Prepends sign if negative, else space. \\
\texttt{\#} & Adds \texttt{"0x"} before \texttt{\%x}, force decimal point; for \texttt{\%e}, \texttt{\%f}, leaves trailing zeros for \texttt{\%g}. \\
\end{tabular}

\hangpar \textsf{Field width} and \textsf{precision}\\
\begin{tabular}{@{}lp{0.84\columnwidth}}
\textsf{n} & Puts at least \textsf{n} characters, pad with blanks. \\
\textsf{0n} & Puts at least \textsf{n} characters, left-pad with zeros. \\
\textsf{.n} & Use at least \textsf{n} digits for integers, rounds to \textsf{n} decimals for floating-point or no more than \textsf{n} chars. for strings. \\
\end{tabular}

\section*{The JSON Library}

\hangpar \texttt{json.load(}\textib{string}\texttt{)} \\
Concatenate \textib{string} into a complete path.

\section*{The OS Library}

\hangpar \texttt{os.getcmd()} \\
Get the path of the current directory.

\hangpar \texttt{os.chdir(}\textib{path}\texttt{)} \\
Switch the current folder to the \textib{path}.

\hangpar \texttt{os.mkdir(}\textib{path}\texttt{)} \\
Create a level of directory (with \textib{path}).

\hangpar \texttt{os.remove(}\textib{path}\texttt{)} \\
Delete file of directory form \textib{path}.

\hangpar \texttt{os.listdir(}[\textib{path}]\texttt{)} \\
Return a list of file and folder names contained in the specified \textib{path} (the default is \texttt{'.'}).

\hangpar \texttt{os.system(}\textib{cmd}[\texttt{,} \textib{args}]\texttt{)} \\
Execute a system command.

\hangpar \texttt{os.exit()}\\
Exit the interpreter process.

\subsection*{The \texttt{os.path} Module}

\hangpar \texttt{os.path.isdir(}\textib{path}\texttt{)} \\
Check if the \textib{path} is a folder.

\hangpar \texttt{os.path.isfile(}\textib{path}\texttt{)} \\
Check if the \textib{path} is a file.

\hangpar \texttt{os.path.exists(}\textib{path}\texttt{)} \\
Check if the \textib{path} already exists.

\hangpar \texttt{os.path.split(}\textib{path}\texttt{)} \\
Split the \textib{path} into dir-name and base-name.

\hangpar \texttt{os.path.splitext(}\textib{path}\texttt{)} \\
Split the \textib{path} into file-name and ext-name.

\hangpar \texttt{os.path.splitext(}\textib{args}\texttt{)} \\
Concatenate \textib{args} into a complete path.
