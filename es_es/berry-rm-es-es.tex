% This file was converted to LaTeX by Writer2LaTeX ver. 1.6.1
% see http://writer2latex.sourceforge.net for more info
\documentclass[a4paper]{article}
\usepackage[latin1]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb,amsfonts,textcomp}
\usepackage[T1]{fontenc}
\usepackage[english,spanish]{babel}
\usepackage{color}
\usepackage{array}
\usepackage{supertabular}
\usepackage{hhline}
\usepackage{hyperref}
\hypersetup{pdftex, colorlinks=true, linkcolor=blue, citecolor=blue, filecolor=blue, urlcolor=blue, pdftitle=, pdfauthor=, pdfsubject=, pdfkeywords=}
\usepackage[pdftex]{graphicx}
% Text styles
\newcommand\textstyleDefinition[1]{#1}
\newcommand\textstyleSourceText[1]{\texttt{#1}}
% Outline numbering
\setcounter{secnumdepth}{0}
\makeatletter
\newcommand\arraybslash{\let\\\@arraycr}
\makeatother
% Page layout (geometry)
\setlength\voffset{-1in}
\setlength\hoffset{-1in}
\setlength\topmargin{2.54cm}
\setlength\oddsidemargin{2.54cm}
\setlength\textheight{23.096cm}
\setlength\textwidth{15.920999cm}
\setlength\footskip{1.524cm}
\setlength\headheight{0cm}
\setlength\headsep{0cm}
% Footnote rule
\setlength{\skip\footins}{0.119cm}
\renewcommand\footnoterule{\vspace*{-0.018cm}\setlength\leftskip{0pt}\setlength\rightskip{0pt plus 1fil}\noindent\textcolor{black}{\rule{0.25\columnwidth}{0.018cm}}\vspace*{0.101cm}}
% Pages styles
\makeatletter
\newcommand\ps@Standard{
  \renewcommand\@oddhead{}
  \renewcommand\@evenhead{}
  \renewcommand\@oddfoot{\thepage{}\ }
  \renewcommand\@evenfoot{\@oddfoot}
  \renewcommand\thepage{\arabic{page}}
}
\newcommand\ps@FirstPage{
  \renewcommand\@oddhead{}
  \renewcommand\@evenhead{}
  \renewcommand\@oddfoot{}
  \renewcommand\@evenfoot{}
  \renewcommand\thepage{\arabic{page}}
}
\makeatother
\pagestyle{Standard}
\setlength\tabcolsep{1mm}
\renewcommand\arraystretch{1.3}
% List styles
\newcommand\liststyleLii{%
\renewcommand\labelitemi{{\textbullet}}
\renewcommand\labelitemii{${\circ}$}
\renewcommand\labelitemiii{${\blacksquare}$}
\renewcommand\labelitemiv{{\textbullet}}
}
\newcommand\liststyleLiii{%
\renewcommand\labelitemi{{\textbullet}}
\renewcommand\labelitemii{${\circ}$}
\renewcommand\labelitemiii{${\blacksquare}$}
\renewcommand\labelitemiv{{\textbullet}}
}
\newcommand\liststyleLiv{%
\renewcommand\labelitemi{{\textbullet}}
\renewcommand\labelitemii{${\circ}$}
\renewcommand\labelitemiii{${\blacksquare}$}
\renewcommand\labelitemiv{{\textbullet}}
}
\newcommand\liststyleLv{%
\renewcommand\labelitemi{{\textbullet}}
\renewcommand\labelitemii{${\circ}$}
\renewcommand\labelitemiii{${\blacksquare}$}
\renewcommand\labelitemiv{{\textbullet}}
}
\newcommand\liststyleLvi{%
\renewcommand\labelitemi{{\textbullet}}
\renewcommand\labelitemii{${\circ}$}
\renewcommand\labelitemiii{${\blacksquare}$}
\renewcommand\labelitemiv{{\textbullet}}
}
\newcommand\liststyleLvii{%
\renewcommand\labelitemi{{\textbullet}}
\renewcommand\labelitemii{${\circ}$}
\renewcommand\labelitemiii{${\blacksquare}$}
\renewcommand\labelitemiv{{\textbullet}}
}
\newcommand\liststyleLviii{%
\renewcommand\labelitemi{{\textbullet}}
\renewcommand\labelitemii{${\circ}$}
\renewcommand\labelitemiii{${\blacksquare}$}
\renewcommand\labelitemiv{{\textbullet}}
}
\newcommand\liststyleLix{%
\renewcommand\labelitemi{{\textbullet}}
\renewcommand\labelitemii{${\circ}$}
\renewcommand\labelitemiii{${\blacksquare}$}
\renewcommand\labelitemiv{{\textbullet}}
}
\newcommand\liststyleLx{%
\renewcommand\labelitemi{{\textbullet}}
\renewcommand\labelitemii{${\circ}$}
\renewcommand\labelitemiii{${\blacksquare}$}
\renewcommand\labelitemiv{{\textbullet}}
}
\newcommand\liststyleLxiii{%
\renewcommand\labelitemi{{\textbullet}}
\renewcommand\labelitemii{${\circ}$}
\renewcommand\labelitemiii{${\blacksquare}$}
\renewcommand\labelitemiv{{\textbullet}}
}
\newcommand\liststyleLxiv{%
\renewcommand\theenumi{\arabic{enumi}}
\renewcommand\theenumii{\arabic{enumii}}
\renewcommand\theenumiii{\arabic{enumiii}}
\renewcommand\theenumiv{\arabic{enumiv}}
\renewcommand\labelenumi{\theenumi.}
\renewcommand\labelenumii{\theenumii.}
\renewcommand\labelenumiii{\theenumiii.}
\renewcommand\labelenumiv{\theenumiv.}
}
\newcommand\liststyleLxv{%
\renewcommand\labelitemi{{\textbullet}}
\renewcommand\labelitemii{${\circ}$}
\renewcommand\labelitemiii{${\blacksquare}$}
\renewcommand\labelitemiv{{\textbullet}}
}
\newcommand\liststyleLxvi{%
\renewcommand\labelitemi{{\textbullet}}
\renewcommand\labelitemii{${\circ}$}
\renewcommand\labelitemiii{${\blacksquare}$}
\renewcommand\labelitemiv{{\textbullet}}
}
\newcommand\liststyleLxvii{%
\renewcommand\labelitemi{{\textbullet}}
\renewcommand\labelitemii{${\circ}$}
\renewcommand\labelitemiii{${\blacksquare}$}
\renewcommand\labelitemiv{{\textbullet}}
}
\newcommand\liststyleLxviii{%
\renewcommand\labelitemi{{\textbullet}}
\renewcommand\labelitemii{${\circ}$}
\renewcommand\labelitemiii{${\blacksquare}$}
\renewcommand\labelitemiv{{\textbullet}}
}
\newcommand\liststyleLxix{%
\renewcommand\labelitemi{{\textbullet}}
\renewcommand\labelitemii{${\circ}$}
\renewcommand\labelitemiii{${\blacksquare}$}
\renewcommand\labelitemiv{{\textbullet}}
}
\newcommand\liststyleLxx{%
\renewcommand\labelitemi{{\textbullet}}
\renewcommand\labelitemii{${\circ}$}
\renewcommand\labelitemiii{${\blacksquare}$}
\renewcommand\labelitemiv{{\textbullet}}
}
\newcommand\liststyleLxxi{%
\renewcommand\labelitemi{{\textbullet}}
\renewcommand\labelitemii{${\circ}$}
\renewcommand\labelitemiii{${\blacksquare}$}
\renewcommand\labelitemiv{{\textbullet}}
}
\newcommand\liststyleLxxii{%
\renewcommand\theenumi{\arabic{enumi}}
\renewcommand\theenumii{\arabic{enumii}}
\renewcommand\theenumiii{\arabic{enumiii}}
\renewcommand\theenumiv{\arabic{enumiv}}
\renewcommand\labelenumi{\theenumi.}
\renewcommand\labelenumii{\theenumii.}
\renewcommand\labelenumiii{\theenumiii.}
\renewcommand\labelenumiv{\theenumiv.}
}
\newcommand\liststyleLxxiii{%
\renewcommand\labelitemi{{\textbullet}}
\renewcommand\labelitemii{${\circ}$}
\renewcommand\labelitemiii{${\blacksquare}$}
\renewcommand\labelitemiv{{\textbullet}}
}
\title{}
\author{}
\date{2022-08-26}
\begin{document}
\clearpage\setcounter{page}{1}\pagestyle{Standard}
\thispagestyle{FirstPage}

\bigskip


\bigskip


\bigskip


\bigskip

{\centering\sffamily\bfseries
Manual de referencia del lenguaje Berry Script
\par}


\bigskip

{\centering\selectlanguage{spanish}
V1.0.0
\par}

{\centering\selectlanguage{spanish}
Guan Wenliang y Stephan Hadinger
\par}

{\centering
\foreignlanguage{spanish}{5 de julio de 2022}
\par}


\bigskip


\bigskip


\bigskip


\bigskip


\bigskip


\bigskip


\bigskip


\bigskip


\bigskip


\bigskip


\bigskip


\bigskip


\bigskip

{\centering\selectlanguage{spanish}
Traducción al Español: Emiliano González (egonzalez.hiperion@gmail.com)
\par}

\clearpage\clearpage\setcounter{page}{1}\pagestyle{Standard}
\section{Prefacio}
\hypertarget{RefHeadingToc354593639824055}{}
\bigskip

{\selectlanguage{spanish}
Hace algunos años, intenté portar el lenguaje de script Lua al microcontrolador STM32F4 y luego experimenté un firmware
basado en Lua en ESP8266: NodeMCU. Estas experiencias me hicieron experimentar la conveniencia del desarrollo de
guiones. Más tarde, entré en contacto con algunos lenguajes de script, como Python, JavaScript, Basic y MATLAB. En la
actualidad, solo unos pocos lenguajes son adecuados para portar a la plataforma de microcontroladores. Solía prestar
más atención a Lua porque es un lenguaje de script integrado muy compacto y su objetivo de diseño es estar integrado en
el programa host. Sin embargo, para el microcontrolador, el intérprete de Lua puede no ser lo suficientemente pequeño y
no puede ser ejecutado en un microcontrolador de 32 bits con una memoria relativamente pequeña. Con este fin, comencé a
leer el código Lua y desarrollé mi propio lenguaje de script, Berry, sobre esta base.}

{\selectlanguage{spanish}
Este es un lenguaje de script integrado ultraligero, también es un lenguaje dinámico multiparadigma. Admite estilos
orientados a objetos, orientados a procesos y funcionales (menos soportado). Muchos aspectos de este lenguaje se
refieren a Lua, pero su sintaxis también se inspira en el diseño de otros lenguajes. Si el lector ya conoce un lenguaje
de alto nivel, la gramática de Berry debería ser muy fácil de entender: el lenguaje tiene solo algunas reglas simples y
un diseño de alcance muy natural.}

{\selectlanguage{spanish}
El principal escenario de aplicación que considero son los sistemas integrados con bajo rendimiento. La memoria de estos
sistemas puede ser muy pequeña, por lo que es muy difícil ejecutar un lenguaje de script con todas las funciones. Esto
significa que es posible que tengamos que hacer una elección. Es posible que Berry solo proporcione las funciones
principales básicas y más utilizadas, mientras que otras características innecesarias solo se usan como módulos
opcionales. Esto conducirá inevitablemente a que la biblioteca estándar del idioma sea demasiado pequeña, incluso el
lenguaje. También habrá diseños inciertos (como la implementación de números de punto flotante y enteros, etc.). Los
beneficios de estas compensaciones son más espacio para la optimización, mientras que la desventaja es obviamente la
inconsistencia de los estándares del idioma. El intérprete de Berry se refiere a la implementación del intérprete de
Lua, que se divide principalmente en dos partes: compilador y máquina virtual. El compilador de Berry es un compilador
de un solo paso para generar bytecode. Esta solución no genera un árbol de sintaxis abstracto, por lo que ahorra
memoria. La máquina virtual es de tipo registro. En términos generales, la máquina virtual de tipo registro es más
eficiente que la máquina virtual de tipo pila. Además de implementar funciones de lenguaje, también esperamos optimizar
el uso de la memoria y la eficiencia operativa del intérprete. En la actualidad, los indicadores de rendimiento del
intérprete de Berry no son comparables con los de los lenguajes principales, pero la huella de memoria es muy pequeña.}

{\selectlanguage{spanish}
No fue hasta más tarde que me enteré del proyecto MicroPython: un intérprete de Python simplificado diseñado para
microcontroladores. Hoy en día, Python está muy de moda, y este intérprete de Python diseñado para microcontroladores
también es muy popular. En comparación con la tecnología madura actual, Berry es un lenguaje nuevo sin una base de
usuarios suficiente. Su ventaja es que es fácil de dominar la gramática y puede tener ventajas en términos de consumo
de recursos y rendimiento.}

{\selectlanguage{spanish}
Si necesita migrar el intérprete de Berry, debe asegurarse de que el compilador que usa brinde soporte para el estándar
C99 (anteriormente cumplia completamente con C89, y algunos trabajos de optimización más tarde me hicieron renunciar a
esta decisión). En la actualidad, la mayoría de los compiladores brindan soporte para C99, y los compiladores comunes
como ARMCC (KEIL MDK), ICC (IAR) y GCC en el desarrollo de procesadores ARM también admiten C99. Este documento
presenta las reglas gramaticales de Berry, la biblioteca estándar y otras instalaciones, y finalmente guía a los
lectores para trasplantar y ampliar Berry. Este documento no explica el mecanismo de implementación del intérprete, y
puede ser explicado en otros documentos, si tenemos tiempo.}

{\selectlanguage{spanish}
El nivel del autor es limitado y la escritura apresurada. Si hay omisiones o errores en el artículo, espero que los
lectores no duden en corregirlos.}

{\selectlanguage{spanish}
Guan Wenliang}

{\selectlanguage{spanish}
abril 2019}

\setcounter{tocdepth}{10}
\renewcommand\contentsname{Sumario}
\tableofcontents

\bigskip

\clearpage\section[Capítulo 1: Información básica]{Capítulo 1: \foreignlanguage{spanish}{Información básica}}
\hypertarget{RefHeadingToc354613639824055}{}
\bigskip

\subsection[1.1 Introducción]{\selectlanguage{spanish} 1.1 Introducción}
\hypertarget{RefHeadingToc354633639824055}{}{\selectlanguage{spanish}
Berry es un lenguaje de script integrado de tipo dinámico ultraligero. El lenguaje admite principalmente programación
procedural, así como programación orientada a objetos y programación funcional. Un objetivo de diseño importante de
Berry es poder ejecutarse en dispositivos integrados con muy poca memoria, por lo que el lenguaje está muy optimizado.
Sin embargo, Berry sigue siendo un lenguaje de secuencias de comandos rico en funciones.}

\subsection[1.2 Empezar a usar]{\selectlanguage{spanish} 1.2 Empezar a usar}
\hypertarget{RefHeadingToc354653639824055}{}\subsubsection[1.2.1 Obtener el intérprete]{\selectlanguage{spanish} 1.2.1
Obtener el intérprete}
\hypertarget{RefHeadingToc354673639824055}{}\foreignlanguage{spanish}{Los lectores pueden ir a la página de GitHub del
proyecto:
}\textstyleDefinition{\foreignlanguage{spanish}{https://github.com/berry-lang/berry}}\foreignlanguage{spanish}{ para
obtener el código fuente del intérprete de Berry. Los lectores necesitan compilar el intérprete de Berry por sí mismos.
El método de compilación específico se puede encontrar en el documento README.md en el directorio raíz del código
fuente, que también se puede ver en la página de GitHub del proyecto.}

\foreignlanguage{spanish}{Primero, debe instalar un software como GCC, git y make. Si no usa el control de versiones,
puede descargar el código fuente directamente en GitHub sin instalar git. Los lectores pueden usar motores de búsqueda
para recuperar información sobre este software. Los lectores que utilizan sistemas Linux y macOS también deben instalar
la biblioteca GNU Readline[1]. Use el comando
}\textstyleSourceText{\foreignlanguage{spanish}{git}}\foreignlanguage{spanish}{ [2] Clone el código fuente del
intérprete del almacén remoto al local:}


\bigskip

{\selectlanguage{spanish}\ttfamily
git clone https://github.com/berry-lang/berry}


\bigskip

\foreignlanguage{spanish}{Ingrese al directorio berry y use el comando
}\textstyleSourceText{\foreignlanguage{spanish}{make}}\foreignlanguage{spanish}{ para compilar el intérprete:}


\bigskip

{\selectlanguage{spanish}\ttfamily
cd berry}

{\selectlanguage{spanish}\ttfamily
make}


\bigskip

\foreignlanguage{spanish}{Ahora debería poder encontrar el archivo ejecutable del intérprete en el directorio
}\foreignlanguage{spanish}{\textit{berry}}\foreignlanguage{spanish}{ (en los sistemas Windows, el nombre del archivo
del programa intérprete es ``}\foreignlanguage{spanish}{\textit{berry.exe}}\foreignlanguage{spanish}{{}'', mientras que
en los sistemas Linux y macOS el nombre del archivo es
``}\foreignlanguage{spanish}{\textit{berry}}\foreignlanguage{spanish}{{}''), puede ejecutar el archivo ejecutable
directamente. Para iniciar el intérprete: En Linux o macOS, puede usar el comando
}\textstyleSourceText{\foreignlanguage{spanish}{sudo make install}}\foreignlanguage{spanish}{ para instalar el
intérprete, y luego puede iniciar el intérprete con el comando
}\textstyleSourceText{\foreignlanguage{spanish}{berry}}\foreignlanguage{spanish}{ en la terminal.}

\subsubsection[1.2.2 Entorno REPL]{\selectlanguage{spanish} 1.2.2 Entorno REPL}
\hypertarget{RefHeadingToc354693639824055}{}{\selectlanguage{spanish}
REPL (Leer Evaluar Imprimir Bucle) generalmente se traduce como un intérprete interactivo, y este elemnto también se ha
convertido en el modo interactivo del intérprete. Este modo consta de cuatro elementos: \textbf{Leer}, lee el código
fuente ingresado por el usuario desde el dispositivo de entrada; \textbf{Evaluar}, compila y ejecuta el código fuente
ingresado por el usuario; \textbf{Imprimir}, muestra el resultado del proceso de evaluación; \textbf{Bucle}, realiza un
ciclo de las operaciones anteriores.}

\foreignlanguage{spanish}{Inicie el intérprete directamente (ingrese
}\textstyleSourceText{\foreignlanguage{spanish}{berry}}\foreignlanguage{spanish}{ en la terminal o en la ventana de
comandos sin parámetros, o haga doble clic en berry.exe en Windows) para ingresar al modo REPL y verá la siguiente
interfaz:}


\bigskip

{\selectlanguage{spanish}\ttfamily
Berry 1.0.0 (build in Feb 1 2022, 13:14:04)}

{\selectlanguage{spanish}\ttfamily
[GCC 8.1.0] on Windows (default)}

{\selectlanguage{spanish}\ttfamily
{\textgreater}}


\bigskip

\foreignlanguage{spanish}{Las dos primeras líneas de la interfaz muestran la versión, el tiempo de compilación, el
compilador y el sistema operativo del intérprete de Berry. El símbolo
``}\textstyleSourceText{\foreignlanguage{spanish}{{\textgreater}}}\foreignlanguage{spanish}{{}'' en la tercera línea se
llama indicador y el cursor se muestra detrás del indicador. Al usar el modo REPL, después de ingresar el código
fuente, al presionar la tecla {\textquotedbl}Enter{\textquotedbl} se ejecutará inmediatamente el código y se generará
el resultado. Presione la combinación de teclas }\textstyleSourceText{\foreignlanguage{spanish}{Ctrl +
C}}\foreignlanguage{spanish}{ para salir de REPL. En el caso de usar la biblioteca Readline, use la combinación de
teclas }\textstyleSourceText{\foreignlanguage{spanish}{Ctrl + D}}\foreignlanguage{spanish}{ para salir de REPL cuando
la entrada esté vacía. Dado que no hay necesidad de editar archivos de secuencias de comandos, el modo REPL se puede
utilizar para un desarrollo rápido o verificación de ideas.}

\paragraph[Programa Hola Mundo]{\selectlanguage{spanish} Programa Hola Mundo}
\hypertarget{RefHeadingToc354713639824055}{}\foreignlanguage{spanish}{Tomemos como ejemplo el clásico programa ``Hola
Mundo''. Introduzca }\textstyleSourceText{\foreignlanguage{spanish}{print('Hola Mundo')}}\foreignlanguage{spanish}{ en
el REPL y ejecútelo. Los resultados son los siguientes:}


\bigskip

{\selectlanguage{spanish}\ttfamily
Berry 1.0.0 (build in Feb 1 2022, 13:14:04)}

{\selectlanguage{spanish}\ttfamily
[GCC 8.1.0] on Windows (default)}

{\selectlanguage{spanish}\ttfamily
{\textgreater} print('Hola Mundo')}

{\selectlanguage{spanish}\ttfamily
Hola Mundo}

{\selectlanguage{spanish}\ttfamily
{\textgreater}}


\bigskip

\foreignlanguage{spanish}{El intérprete emite el texto ``}\textstyleSourceText{\foreignlanguage{spanish}{Hola
Mundo}}\foreignlanguage{spanish}{{}''. Esta línea de código realiza la salida de la cadena
}\textstyleSourceText{\foreignlanguage{spanish}{{}'Hola Mundo'}}\foreignlanguage{spanish}{ llamando a la función
}\textstyleSourceText{\foreignlanguage{spanish}{print}}\foreignlanguage{spanish}{. En REPL, si el valor de retorno de
la expresión no es }\textstyleSourceText{\foreignlanguage{spanish}{nil}}\foreignlanguage{spanish}{, se mostrará el
valor de retorno. Por ejemplo, ingresar la expresión }\textstyleSourceText{\foreignlanguage{spanish}{1 +
2}}\foreignlanguage{spanish}{ mostrará el resultado del cálculo
}\textstyleSourceText{\foreignlanguage{spanish}{3}}\foreignlanguage{spanish}{:}


\bigskip

{\selectlanguage{spanish}\ttfamily
{\textgreater} 1 + 2}

{\selectlanguage{spanish}\ttfamily
3}


\bigskip

\foreignlanguage{spanish}{Por lo tanto, el programa ``Hola Mundo'' más simple bajo REPL es ingresar directamente la
cadena }\textstyleSourceText{\foreignlanguage{spanish}{{}'Hola Mundo'}}\foreignlanguage{spanish}{ y ejecutar:}


\bigskip

{\selectlanguage{spanish}\ttfamily
{\textgreater} 'Hola Mundo'}

{\selectlanguage{spanish}\ttfamily
Hola Mundo}

\paragraph[Más uso de REPL]{\selectlanguage{spanish} Más uso de REPL}
\hypertarget{RefHeadingToc354733639824055}{}\foreignlanguage{spanish}{También puede utilizar el modo interactivo del
intérprete de Berry como calculadora científica. Sin embargo, algunas funciones matemáticas no se pueden utilizar
directamente. }\foreignlanguage{spanish}{En su lugar, use la declaración
}\textstyleSourceText{\foreignlanguage{spanish}{import math}}\foreignlanguage{spanish}{ para importar la biblioteca
matemática y luego use las funciones en la biblioteca. Utilice
``}\textstyleSourceText{\foreignlanguage{spanish}{math.}}\foreignlanguage{spanish}{{}'' como prefijo, por ejemplo, la
función }\textstyleSourceText{\foreignlanguage{spanish}{sin}}\foreignlanguage{spanish}{ debe escribirse como
}\textstyleSourceText{\foreignlanguage{spanish}{math.sin}}\foreignlanguage{spanish}{:}


\bigskip

{\selectlanguage{spanish}\ttfamily
{\textgreater} import math}

{\selectlanguage{spanish}\ttfamily
{\textgreater} math.pi}

{\selectlanguage{spanish}\ttfamily
3.14159}

{\selectlanguage{spanish}\ttfamily
{\textgreater} math.sin(math.pi / 2)}

{\selectlanguage{spanish}\ttfamily
1}

{\selectlanguage{spanish}\ttfamily
{\textgreater} math.sqrt(2)}

{\selectlanguage{spanish}\ttfamily
1.41421}

\subsubsection[1.2.3 Archivo de comandos]{\selectlanguage{spanish} 1.2.3 Archivo de comandos}
\hypertarget{RefHeadingToc354753639824055}{}{\selectlanguage{spanish}
El archivo de secuencia de comandos de Berry es un archivo que almacena el código de Berry, y un intérprete puede
ejecutar el archivo de script. Normalmente, el archivo de script es un archivo de texto con la extensión
{\textquotedbl}.be{\textquotedbl}. El comando para ejecutar el script usando el intérprete es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
berry script\_file}


\bigskip

\textstyleSourceText{\foreignlanguage{spanish}{script\_file}}\foreignlanguage{spanish}{ es el nombre de archivo del
archivo de script. El uso de este comando ejecutará el intérprete para ejecutar el código Berry en el archivo de script
}\textstyleSourceText{\foreignlanguage{spanish}{script\_file}}\foreignlanguage{spanish}{ y el intérprete se cerrará
después de la ejecución.}

\foreignlanguage{spanish}{Si desea que el intérprete ingrese al modo REPL después de ejecutar el archivo de script,
puede agregar el parámetro }\textstyleSourceText{\foreignlanguage{spanish}{{}-i}}\foreignlanguage{spanish}{ al comando
para llamar al intérprete:}


\bigskip

{\selectlanguage{spanish}\ttfamily
berry script\_file}


\bigskip

\foreignlanguage{spanish}{Este comando primero ejecutará el código en el archivo
}\textstyleSourceText{\foreignlanguage{spanish}{script\_file}}\foreignlanguage{spanish}{ y luego ingresará al modo
REPL.}

\subsection[1.3 Palabras (Words)]{\selectlanguage{spanish} 1.3 Palabras (Words)}
\hypertarget{RefHeadingToc354773639824055}{}{\selectlanguage{spanish}
Antes de presentar la sintaxis de Berry, echemos un vistazo a un código simple (puede ejecutar este código en modo
REPL):}


\bigskip

{\selectlanguage{spanish}\ttfamily
def func(x) \# una función ejemplo}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ return x + 1.5}

{\selectlanguage{spanish}\ttfamily
end}

{\selectlanguage{spanish}\ttfamily
print('func(10) =', func(10))}


\bigskip

\foreignlanguage{spanish}{Este código define una función
}\textstyleSourceText{\foreignlanguage{spanish}{func}}\foreignlanguage{spanish}{ y la llama más tarde. Antes de
entender cómo funciona este código, primero presentaremos los elementos de sintaxis del lenguaje Berry.}

\foreignlanguage{spanish}{En el código anterior, la clasificación específica de los elementos gramaticales es:
}\textstyleSourceText{\foreignlanguage{spanish}{def}}\foreignlanguage{spanish}{,
}\textstyleSourceText{\foreignlanguage{spanish}{return}}\foreignlanguage{spanish}{ y
}\textstyleSourceText{\foreignlanguage{spanish}{end}}\foreignlanguage{spanish}{. Estas son palabras clave del lenguaje
Berry; y ``}\textstyleSourceText{\foreignlanguage{spanish}{\# una función ejemplo}}\foreignlanguage{spanish}{{}'' en la
primera línea se llama comentario; }\textstyleSourceText{\foreignlanguage{spanish}{print}}\foreignlanguage{spanish}{,
}\textstyleSourceText{\foreignlanguage{spanish}{func}}\foreignlanguage{spanish}{ y
}\textstyleSourceText{\foreignlanguage{spanish}{x}}\foreignlanguage{spanish}{ son algunos identificadores, generalmente
se usan para representar una variable; }\textstyleSourceText{\foreignlanguage{spanish}{1.5}}\foreignlanguage{spanish}{
y }\textstyleSourceText{\foreignlanguage{spanish}{10}}\foreignlanguage{spanish}{ estos números se llaman
}\foreignlanguage{spanish}{literales numéricos, son equivalentes a los números usados en la vida diaria;
}\textstyleSourceText{\foreignlanguage{spanish}{{}'func(10) ='}}\foreignlanguage{spanish}{ Es un literal de cadena, se
usan en lugares donde necesitas representar texto;
}\textstyleSourceText{\foreignlanguage{spanish}{+}}\foreignlanguage{spanish}{ es un operador de suma, aquí el operador
de suma se puede usar para sumar la variable
}\textstyleSourceText{\foreignlanguage{spanish}{x}}\foreignlanguage{spanish}{ y el valor
}\textstyleSourceText{\foreignlanguage{spanish}{1.5}}\foreignlanguage{spanish}{.}

{\selectlanguage{spanish}
La clasificación anterior se realiza en realidad desde la perspectiva de un analizador lexicográfico. El análisis
lexicográfico es el primer paso en el análisis del código fuente de Berry. Para escribir el código fuente correcto,
comenzamos con la introducción lexicográfica más básica.}

\subsubsection[1.3.1 Comentario]{\selectlanguage{spanish} 1.3.1 Comentario}
\hypertarget{RefHeadingToc354793639824055}{}\foreignlanguage{spanish}{Los comentarios son textos que no genera ningún
código. Se utilizan para hacer comentarios en el código fuente y ser leídos por personas, mientras que el compilador no
interpretará su contenido. Berry admite comentarios de una sola línea y comentarios de bloque de líneas cruzadas. Los
comentarios de una sola línea comienzan con el carácter
``}\textstyleSourceText{\foreignlanguage{spanish}{\#}}\foreignlanguage{spanish}{{}' hasta el final del carácter de
nueva línea. La nota rápida comienza con el texto
``}\textstyleSourceText{\foreignlanguage{spanish}{\#-}}\foreignlanguage{spanish}{{}'' y termina con el texto
``}\textstyleSourceText{\foreignlanguage{spanish}{{}-\#}}\foreignlanguage{spanish}{{}''. El siguiente es un ejemplo del
uso de anotaciones:}


\bigskip

{\selectlanguage{spanish}\ttfamily
\# \ Este es un comentario de línea}

{\selectlanguage{spanish}\ttfamily
\#- Este es un}

{\selectlanguage{spanish}\ttfamily
\ \ \ bloque de comentario}

{\selectlanguage{spanish}\ttfamily
{}-\#}


\bigskip

\foreignlanguage{spanish}{Similar al lenguaje C, los comentarios rápidos no admiten el anidamiento. El siguiente código
terminará el análisis de los comentarios en el primer texto
``}\textstyleSourceText{\foreignlanguage{spanish}{{}-\#}}\foreignlanguage{spanish}{{}'':}


\bigskip

{\selectlanguage{spanish}\ttfamily
\#- - Algunos comentarios -\# ... -\#}

\subsubsection[1.3.2 Valor literal]{\selectlanguage{spanish} 1.3.2 Valor literal}
\hypertarget{RefHeadingToc354813639824055}{}\foreignlanguage{spanish}{El valor literal es un valor fijo escrito
directamente en el código fuente durante la programación. Los literales de Berry son números enteros, números reales,
booleanos, cadenas y nil. Por ejemplo, el valor
}\textstyleSourceText{\foreignlanguage{spanish}{34}}\foreignlanguage{spanish}{ es una denominación entera.}

\paragraph[Valor literal numérico]{\selectlanguage{spanish} Valor literal numérico}
\hypertarget{RefHeadingToc354833639824055}{}{\selectlanguage{spanish}
Los literales numéricos incluyen literales \textbf{Integer} (entero) y literales \textbf{Número real} (real).}


\bigskip

{\selectlanguage{spanish}\ttfamily
40 \# \ Literal entero}

{\selectlanguage{spanish}\ttfamily
0x80 \# Literal hexadecimal (entero)}

{\selectlanguage{spanish}\ttfamily
3.14 \# \ Literal real}

{\selectlanguage{spanish}\ttfamily
1.1e-6 \# \ Literal real}


\bigskip

\foreignlanguage{spanish}{Los literales numéricos se escriben de manera similar a la escritura cotidiana. Berry admite
denominaciones enteras hexadecimales. Los literales hexadecimales comienzan con el prefijo
}\textstyleSourceText{\foreignlanguage{spanish}{0x}}\foreignlanguage{spanish}{ o
}\textstyleSourceText{\foreignlanguage{spanish}{0X}}\foreignlanguage{spanish}{, seguido de un número hexadecimal.}

\paragraph[Valor literal booleano]{\selectlanguage{spanish} Valor literal booleano}
\hypertarget{RefHeadingToc354853639824055}{}\foreignlanguage{spanish}{Los valores booleanos (booleanos) se utilizan para
representar verdadero y falso en el estado }\foreignlanguage{spanish}{lógico. Puede utilizar las palabras clave
}\textstyleSourceText{\foreignlanguage{spanish}{true}}\foreignlanguage{spanish}{ y
}\textstyleSourceText{\foreignlanguage{spanish}{false}}\foreignlanguage{spanish}{ para representar literales
booleanos.}

\paragraph[Literal de cadena]{\selectlanguage{spanish} Literal de cadena}
\hypertarget{RefHeadingToc354873639824055}{}\foreignlanguage{spanish}{Una cadena es un fragmento de texto, y su
escritura literal consiste en usar un par de
}\textstyleSourceText{\foreignlanguage{spanish}{{}'}}\foreignlanguage{spanish}{ o
}\textstyleSourceText{\foreignlanguage{spanish}{{\textquotedbl}}}\foreignlanguage{spanish}{ para rodear el texto de la
cadena:}


\bigskip

{\selectlanguage{spanish}\ttfamily
{}'esto es una cadena'}

{\selectlanguage{spanish}\ttfamily
{\textquotedbl}esto es una cadena{\textquotedbl}}


\bigskip

\foreignlanguage{spanish}{Los literales de cadena proporcionan algunas secuencias de escape para representar caracteres
que no se pueden ingresar directamente. La secuencia de escape comienza con el carácter
}\textstyleSourceText{\foreignlanguage{spanish}{{}'{\textbackslash}'}}\foreignlanguage{spanish}{ y luego sigue una
secuencia específica de caracteres para lograr el escape. Las secuencias de escape especificadas por Berry son:}


\bigskip

\begin{center}
\tablefirsthead{\centering{\selectlanguage{spanish}\bfseries Caracter de Escape} &
{\selectlanguage{spanish}\bfseries significado} &
\centering{\selectlanguage{spanish}\bfseries Caracter de Escape} &
{\selectlanguage{spanish}\bfseries significado}\\}
\tablehead{\centering{\selectlanguage{spanish}\bfseries Caracter de Escape} &
{\selectlanguage{spanish}\bfseries significado} &
\centering{\selectlanguage{spanish}\bfseries Caracter de Escape} &
{\selectlanguage{spanish}\bfseries significado}\\}
\tabletail{}
\tablelasttail{}
\begin{supertabular}{m{3.779cm}m{3.779cm}m{3.779cm}m{3.781cm}}
\centering \textstyleSourceText{\foreignlanguage{spanish}{{\textbackslash}a}} &
{\selectlanguage{spanish} Suena la campana} &
\centering \textstyleSourceText{\foreignlanguage{spanish}{{\textbackslash}b}} &
{\selectlanguage{spanish} Retroceso}\\
\centering \textstyleSourceText{\foreignlanguage{spanish}{{\textbackslash}f}} &
{\selectlanguage{spanish} Alimentación de formulario.} &
\centering \textstyleSourceText{\foreignlanguage{spanish}{{\textbackslash}n}} &
{\selectlanguage{spanish} Nueva línea}\\
\centering \textstyleSourceText{\foreignlanguage{spanish}{{\textbackslash}r}} &
{\selectlanguage{spanish} Retorno de carro} &
\centering \textstyleSourceText{\foreignlanguage{spanish}{{\textbackslash}t}} &
{\selectlanguage{spanish} Tabulación Horizontal}\\
\centering \textstyleSourceText{\foreignlanguage{spanish}{{\textbackslash}v}} &
{\selectlanguage{spanish} Tabulación Vertical} &
\centering \textstyleSourceText{\foreignlanguage{spanish}{{\textbackslash}{\textbackslash}}} &
{\selectlanguage{spanish} Barra invertida}\\
\centering \textstyleSourceText{\foreignlanguage{spanish}{{\textbackslash}'}} &
{\selectlanguage{spanish} Apóstrofe} &
\centering \textstyleSourceText{\foreignlanguage{spanish}{{\textbackslash}{\textquotedbl}}} &
{\selectlanguage{spanish} Comillas dobles}\\
\centering \textstyleSourceText{\foreignlanguage{spanish}{{\textbackslash}?}} &
{\selectlanguage{spanish} Signo de interrogación} &
\centering \textstyleSourceText{\foreignlanguage{spanish}{{\textbackslash}0}} &
{\selectlanguage{spanish} Caracter Null}\\
\end{supertabular}
\end{center}
{\selectlanguage{spanish}\itshape
Tabla 1: Secuencia de Caracter de Escape}


\bigskip

{\selectlanguage{spanish}
Las secuencias de escape se pueden usar en cadenas, por ejemplo}

{\selectlanguage{spanish}\ttfamily
print('caracter de escape LF{\textbackslash}n{\textbackslash}tnueva línea')}

{\selectlanguage{spanish}
El resultado de la operación es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
caracter de escape LF}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ nueva línea}


\bigskip

\foreignlanguage{spanish}{También puede usar secuencias de escape generalizadas, en forma de
}\textstyleSourceText{\foreignlanguage{spanish}{{\textbackslash}x}}\foreignlanguage{spanish}{ seguido de 2 dígitos
hexadecimales, o }\textstyleSourceText{\foreignlanguage{spanish}{{\textbackslash}}}\foreignlanguage{spanish}{ 3 dígitos
octales, usando esta secuencia de escape puede representar cualquier carácter. Estos son algunos ejemplos del uso del
conjunto de caracteres ASCII:}


\bigskip

{\selectlanguage{spanish}\ttfamily
{}'{\textbackslash}115' \#-'M' -\#'{\textbackslash}x34' \#- '4' -\#'{\textbackslash}064' \#- '4' -\#}

\paragraph[Valor literal nulo]{\selectlanguage{spanish} Valor literal nulo}
\hypertarget{RefHeadingToc354893639824055}{}\foreignlanguage{spanish}{Nil representa un valor nulo, y su valor literal
está representado por la palabra clave
}\textstyleSourceText{\foreignlanguage{spanish}{nil}}\foreignlanguage{spanish}{.}

\subsubsection[1.3.3 Identificador]{\selectlanguage{spanish} 1.3.3 Identificador}
\hypertarget{RefHeadingToc354913639824055}{}\foreignlanguage{spanish}{El identificador es un nombre definido por el
usuario, que comienza con un guión bajo o una letra, y luego consiste en una combinación de varios guiones bajos,
letras o números. Al igual }\foreignlanguage{spanish}{que la mayoría de los lenguajes, Berry distingue entre mayúsculas
y minúsculas, por lo que los identificadores
}\textstyleSourceText{\foreignlanguage{spanish}{A}}\foreignlanguage{spanish}{ y los identificadores
}\textstyleSourceText{\foreignlanguage{spanish}{a}}\foreignlanguage{spanish}{ se resolverán en dos identificadores
diferentes.}


\bigskip

{\selectlanguage{spanish}\ttfamily
a}

{\selectlanguage{spanish}\ttfamily
TestVariable}

{\selectlanguage{spanish}\ttfamily
Test\_Var}

{\selectlanguage{spanish}\ttfamily
\_init}

{\selectlanguage{spanish}\ttfamily
baseCass}

{\selectlanguage{spanish}\ttfamily
\_}

\subsubsection[1.3.4 Palabras clave]{\selectlanguage{spanish} 1.3.4 Palabras clave}
\hypertarget{RefHeadingToc354933639824055}{}{\selectlanguage{spanish}
Berry reserva los siguientes tokens como palabras clave del lenguaje:}


\bigskip

{\selectlanguage{spanish}\ttfamily
if elif else while for def}

{\selectlanguage{spanish}\ttfamily
end class break continue return true}

{\selectlanguage{spanish}\ttfamily
false nil var do import as static}


\bigskip

\foreignlanguage{spanish}{El uso específico de palabras clave se presentará en los capítulos correspondientes. Tenga en
cuenta que las palabras clave no se pueden utilizar como identificadores. Debido a que Berry distingue entre mayúsculas
y minúsculas, }\textstyleSourceText{\foreignlanguage{spanish}{If}}\foreignlanguage{spanish}{ puede usarse para
identificadores.}

\foreignlanguage{spanish}{[1] Para GNU Readline, el comando de instalación para la serie Debian de distribuciones de
Linux es }\textstyleSourceText{\foreignlanguage{spanish}{sudo apt install libreadline-dev}}\foreignlanguage{spanish}{,
y el comando de instalación para la serie RedHat de distribuciones de Linux es
}\textstyleSourceText{\foreignlanguage{spanish}{yum install readline-devel}}\foreignlanguage{spanish}{, bajo macOS el
comando de instalación es }\textstyleSourceText{\foreignlanguage{spanish}{brew install
readline}}\foreignlanguage{spanish}{. Además, es fácil encontrar documentación de GNU Readline y materiales
relacionados en los motores de búsqueda.}

{\selectlanguage{spanish}
[2] Los comandos deben usarse en la {\textquotedbl}interfaz de línea de comandos{\textquotedbl} después de completar el
trabajo de preparación. El entorno de la línea de comandos en los sistemas Windows suele ser una ventana del símbolo
del sistema (CMD), mientras que el entorno de la línea de comandos en los sistemas similares a Unix suele llamarse
{\textquotedbl}Terminal{\textquotedbl}. Esto no es muy preciso, pero no se ampliará aquí.}

{\selectlanguage{spanish}
[3] En Windows, puede hacer doble clic directamente para ejecutar el archivo ejecutable. En Linux o macOS, use la
terminal para ejecutarlo. También puede ejecutar el intérprete en la ventana del símbolo del sistema de Windows.
Consulte el archivo README.md para un uso específico.}

\clearpage\section{Capítulo 2: Tipos y Variables}
\hypertarget{RefHeadingToc354953639824055}{}
\bigskip

{\selectlanguage{spanish}
El \textbf{Tipo} es un atributo de datos, que define el significado de los datos y las operaciones que se pueden
realizar en los datos. Los tipos se pueden dividir en tipos integrados y tipos definidos por el usuario. Los tipos
integrados se refieren a algunos tipos básicos integrados en el lenguaje Berry, entre los cuales los tipos que no se
basan en definiciones de clase se denominan \textbf{Tipo simple}. Los tipos basados en definiciones de clase se
denominan \textbf{Tipo de clase}, algunos de los tipos integrados son tipos de clase y los tipos definidos por el
usuario también son tipos de clase.}

\subsection[2.1 Tipo incorporado]{\selectlanguage{spanish} 2.1 Tipo incorporado}
\hypertarget{RefHeadingToc354973639824055}{}\subsubsection[2.1.1 Tipo simple]{\selectlanguage{spanish} 2.1.1 Tipo
simple}
\hypertarget{RefHeadingToc354993639824055}{}\paragraph[nil]{\textstyleSourceText{\foreignlanguage{spanish}{nil}}}
\hypertarget{RefHeadingToc355013639824055}{}\foreignlanguage{spanish}{El tipo Nil es el tipo nulo, lo que significa que
el objeto tiene un valor no válido, o se puede decir que el objeto no tiene un valor significativo. Este es un tipo muy
especial. Aunque podríamos decir que una variable es
}\textstyleSourceText{\foreignlanguage{spanish}{nil}}\foreignlanguage{spanish}{, de hecho el tipo nil no tiene valor,
entonces de lo que estamos hablando aquí es que el tipo de la variable es nil (no un valor).}

\foreignlanguage{spanish}{El valor predeterminado de una variable antes de la asignación es
}\textstyleSourceText{\foreignlanguage{spanish}{nil}}\foreignlanguage{spanish}{. Este tipo se puede utilizar en
operaciones lógicas. En este caso 'nil' es equivalente a 'falso'.}

\paragraph[Tipo entero]{\selectlanguage{spanish} Tipo entero}
\hypertarget{RefHeadingToc355033639824055}{}{\selectlanguage{spanish}
El tipo entero (integer) representa un entero con signo, denominado entero. El número de bits del entero representado
por este tipo depende de la implementación específica y, por lo general, consta de un entero de 32 bits con signo en
una plataforma de 32 bits. Integer es un tipo aritmético y admite todas las operaciones aritméticas. Preste atención al
rango de valores de los enteros cuando use este tipo. El rango de valores típico de los enteros con signo de 32 bits
está entre $-$2147483648 y 2147483647.}

\foreignlanguage{spanish}{Cualquier valor se puede convertir a
}\textstyleSourceText{\foreignlanguage{spanish}{int}}\foreignlanguage{spanish}{ usando la función
}\textstyleSourceText{\foreignlanguage{spanish}{int()}}\foreignlanguage{spanish}{; sin embargo
}\textstyleSourceText{\foreignlanguage{spanish}{int(nil) == nil}}\foreignlanguage{spanish}{. Si el argumento es una
instancia, y si contiene un miembro
}\textstyleSourceText{\foreignlanguage{spanish}{toint()}}\foreignlanguage{spanish}{, se nos llamará y el valor devuelto
se convertirá en }\textstyleSourceText{\foreignlanguage{spanish}{int}}\foreignlanguage{spanish}{.}

\paragraph[Tipo de número real]{\selectlanguage{spanish} Tipo de número real}
\hypertarget{RefHeadingToc355053639824055}{}\foreignlanguage{spanish}{El tipo real (real), para ser precisos, es un tipo
de coma flotante. Los tipos de números reales generalmente se implementan como números de punto flotante de precisión
simple o números de punto flotante de precisión doble. El tipo de número real también es un tipo aritmético. En
comparación con el tipo de número entero, el tipo de número real tiene mayor precisión y un mayor rango de valores, por
lo que este tipo es más adecuado para cálculos matemáticos. Cabe señalar que el tipo de número real es en realidad un
número de coma flotante, por lo que aun existen problemas de precisión. Por ejemplo, no se recomienda comparar dos
valores de tipo }\textstyleSourceText{\foreignlanguage{spanish}{real}}\foreignlanguage{spanish}{ para la igualdad.}

{\selectlanguage{spanish}
Cuando los enteros y los números reales participan en operaciones al mismo tiempo, los enteros generalmente se
convierten en números reales.}

\paragraph[Tipo booleano]{\selectlanguage{spanish} Tipo booleano}
\hypertarget{RefHeadingToc355073639824055}{}\foreignlanguage{spanish}{El tipo booleano (boolean) se utiliza para
operaciones lógicas. Tiene dos valores }\textstyleSourceText{\foreignlanguage{spanish}{true}}\foreignlanguage{spanish}{
y }\textstyleSourceText{\foreignlanguage{spanish}{false}}\foreignlanguage{spanish}{, que representan los dos valores
verdaderos (verdadero y falso) en lógica y álgebra booleana. El tipo booleano se utiliza principalmente para el juicio
condicional. Los operandos y los valores devueltos de las expresiones lógicas y las expresiones relacionales son todos
de tipo booleano, y las sentencias como }\textstyleSourceText{\foreignlanguage{spanish}{if}}\foreignlanguage{spanish}{
y }\textstyleSourceText{\foreignlanguage{spanish}{while}}\foreignlanguage{spanish}{ utilizan tipos booleanos como
comprobaciones condicionales.}

\foreignlanguage{spanish}{En muchos casos, los valores no booleanos también se pueden usar como tipos booleanos. Esto se
debe a que el intérprete convertirá implícitamente los parámetros. Esta es también la razón por la que las expresiones
de verificación condicional, como las declaraciones
}\textstyleSourceText{\foreignlanguage{spanish}{if}}\foreignlanguage{spanish}{, pueden usar cualquier tipo de
parámetros. Las reglas para convertir varios tipos a tipos booleanos son:}

\liststyleLii
\begin{itemize}
\item \textstyleSourceText{\foreignlanguage{spanish}{nil}}\foreignlanguage{spanish}{: convertido a
}\textstyleSourceText{\foreignlanguage{spanish}{falso}}\foreignlanguage{spanish}{.}
\item \foreignlanguage{spanish}{\textbf{Entero}}\foreignlanguage{spanish}{: cuando el valor es
}\textstyleSourceText{\foreignlanguage{spanish}{0}}\foreignlanguage{spanish}{, se convierte en
}\textstyleSourceText{\foreignlanguage{spanish}{falso}}\foreignlanguage{spanish}{, de lo contrario, se convierte en
}\textstyleSourceText{\foreignlanguage{spanish}{verdadero}}\foreignlanguage{spanish}{.}
\item \foreignlanguage{spanish}{\textbf{Número real}}\foreignlanguage{spanish}{: cuando el valor es
}\textstyleSourceText{\foreignlanguage{spanish}{0.0}}\foreignlanguage{spanish}{, se convierte en
}\textstyleSourceText{\foreignlanguage{spanish}{falso}}\foreignlanguage{spanish}{, de lo contrario, se convierte en
}\textstyleSourceText{\foreignlanguage{spanish}{verdadero}}\foreignlanguage{spanish}{.}
\item \foreignlanguage{spanish}{\textbf{Cadena}}\foreignlanguage{spanish}{: cuando el valor es
{\textquotedbl}{\textquotedbl} (cadena vacía) se convierte en
}\textstyleSourceText{\foreignlanguage{spanish}{falso}}\foreignlanguage{spanish}{ de lo contrario, se convierte en
}\textstyleSourceText{\foreignlanguage{spanish}{verdadero}}\foreignlanguage{spanish}{.}
\item \foreignlanguage{spanish}{\textbf{Comobj}}\foreignlanguage{spanish}{ y
}\foreignlanguage{spanish}{\textbf{Comptr}}\foreignlanguage{spanish}{: cuando el puntero interno es
}\textstyleSourceText{\foreignlanguage{spanish}{NULL}}\foreignlanguage{spanish}{ es convertido a
}\textstyleSourceText{\foreignlanguage{spanish}{falso}}\foreignlanguage{spanish}{, de lo contrario se convierte a
}\textstyleSourceText{\foreignlanguage{spanish}{verdadero}}\foreignlanguage{spanish}{.}
\item \foreignlanguage{spanish}{\textbf{Instancia}}\foreignlanguage{spanish}{: si la instancia contiene un método
}\textstyleSourceText{\foreignlanguage{spanish}{tobool()}}\foreignlanguage{spanish}{, se utilizará el valor de retorno
del método, de lo contrario, se convertirá en
}\textstyleSourceText{\foreignlanguage{spanish}{verdadero}}\foreignlanguage{spanish}{.}
\item \foreignlanguage{spanish}{Todos los demás tipos: converten a
}\textstyleSourceText{\foreignlanguage{spanish}{verdadero}}\foreignlanguage{spanish}{.}
\end{itemize}
\foreignlanguage{spanish}{Cualquier valor se puede convertir a
}\textstyleSourceText{\foreignlanguage{spanish}{bool}}\foreignlanguage{spanish}{ usando la función
}\textstyleSourceText{\foreignlanguage{spanish}{bool()}}\foreignlanguage{spanish}{.}

\paragraph[Cadena]{\selectlanguage{spanish} Cadena}
\hypertarget{RefHeadingToc355093639824055}{}{\selectlanguage{spanish}
Una cadena es una secuencia de caracteres. En términos de almacenamiento, Berry divide las cadenas en cadenas largas y
cadenas cortas. Solo hay una instancia de la misma cadena de caracteres cortos en la memoria, y todas las cadenas de
caracteres cortos están vinculadas en una tabla hash. Este diseño ayuda a mejorar el rendimiento de la comparación de
igualdad de cadenas y puede reducir el uso de memoria. Dado que la frecuencia de uso de cadenas largas es baja y la
sobrecarga de la operación hash es bastante alta, no están vinculadas a la tabla hash, por lo que puede haber varias
instancias idénticas en la memoria. La cadena es de solo lectura después de que se crea. Por lo tanto,
{\textquotedbl}modificar{\textquotedbl} la cadena generará una nueva cadena y la cadena original no se modificará.}

\foreignlanguage{spanish}{Berry no se preocupa por el formato o la codificación de los caracteres. Por ejemplo, la
cadena }\textstyleSourceText{\foreignlanguage{spanish}{{}'abc'}}\foreignlanguage{spanish}{ es en realidad el código
ASCII de los caracteres }\textstyleSourceText{\foreignlanguage{spanish}{{}'a'}}\foreignlanguage{spanish}{,
}\textstyleSourceText{\foreignlanguage{spanish}{{}'b'}}\foreignlanguage{spanish}{ y
}\textstyleSourceText{\foreignlanguage{spanish}{{}'c'}}\foreignlanguage{spanish}{. Por lo tanto, si
}\foreignlanguage{spanish}{hay caracteres anchos en la cadena (la longitud de los caracteres es superior a 1 byte), el
número de caracteres de la cadena no se puede contar directamente. De hecho, usar la función
}\textstyleSourceText{\foreignlanguage{spanish}{size()}}\foreignlanguage{spanish}{ solo puede obtener el número de
bytes en la cadena. Además, para facilitar la interacción con el lenguaje C, la cadena de Berry siempre termina con los
caracteres }\textstyleSourceText{\foreignlanguage{spanish}{{}'{\textbackslash}0'}}\foreignlanguage{spanish}{. Esta
función es transparente para el programa Berry.}

{\selectlanguage{spanish}
El tipo de cadena se puede comparar en tamaño, por lo que se puede usar en operaciones relacionales.}

\paragraph[Función]{\selectlanguage{spanish} Función}
\hypertarget{RefHeadingToc355113639824055}{}{\selectlanguage{spanish}
Una función es una pieza de código que está encapsulada y disponible para llamadas, generalmente utilizada para
implementar una función específica. La función es en realidad una categoría grande, que incluye varios subtipos, como
cierres, funciones nativas y cierres nativos. Para el código Berry, todos los subtipos de funciones tienen el mismo
comportamiento. Las funciones pertenecen al primer tipo de valor en Berry, por lo que se pueden pasar como valores.
Además, se puede usar directamente en expresiones a través de la forma {\textquotedbl}literal{\textquotedbl} de
{\textquotedbl}funciones anónimas{\textquotedbl}.}

{\selectlanguage{spanish}
Una función es un objeto de solo lectura y no se puede modificar una vez definida. Puede comparar si dos funciones son
iguales (si son la misma función), pero no se puede comparar el tipo de función. \textbf{Función nativa} y
\textbf{Cierre nativo} se refieren a funciones y cierres implementados en lenguaje C. Uno de los propósitos principales
de las funciones nativas y los cierres nativos es proporcionar funciones que el lenguaje Berry no proporciona, como
operaciones de E/S y operaciones de bajo nivel. Si un fragmento de código se usa con frecuencia y tiene requisitos de
rendimiento, se recomienda reescribirlo como una función nativa o un cierre nativo.}

\paragraph[Clase]{\selectlanguage{spanish} Clase}
\hypertarget{RefHeadingToc355133639824055}{}\foreignlanguage{spanish}{En la programación orientada a objetos, una clase
es una plantilla de código de programa extensible. Las clases se utilizan para crear objetos de instancia, por lo que
se puede decir que la clase es el {\textquotedbl}tipo{\textquotedbl} de la instancia. Todos los objetos de instancia
son del tipo }\textstyleSourceText{\foreignlanguage{spanish}{instancia}}\foreignlanguage{spanish}{ y todos tienen una
clase correspondiente, que se llama instancia }\foreignlanguage{spanish}{\textbf{Tipo de
clase}}\foreignlanguage{spanish}{. En pocas palabras, una clase es un valor que representa el tipo de un objeto de
instancia y una clase es una abstracción de las características de una instancia. Una clase también es un objeto de
solo lectura, una vez definida, no se puede modificar.}

{\selectlanguage{spanish}
Las clases solo pueden comparar iguales y desiguales, pero no pueden comparar tamaños.}

\paragraph[Ejemplos]{\selectlanguage{spanish} Ejemplos}
\hypertarget{RefHeadingToc355153639824055}{}\foreignlanguage{spanish}{Una instancia es un objeto materializado generado
por una clase, y el proceso de generar una instancia a partir de una clase se llama
}\textstyleSourceText{\foreignlanguage{spanish}{Instanciación}}\foreignlanguage{spanish}{. En la programación orientada
a objetos, {\textquotedbl}instancia{\textquotedbl} suele ser sinónimo de {\textquotedbl}objeto{\textquotedbl}. Sin
embargo, para distinguir los objetos que no son de instancia, no usamos el término {\textquotedbl}objeto{\textquotedbl}
solo, sino que usamos {\textquotedbl}instancia{\textquotedbl} u {\textquotedbl}objeto de instancia{\textquotedbl}. Las
instancias de Berry siempre se asignan dinámicamente y deben usarse con un recolector de basura. Además de la
asignación de memoria, el proceso de creación de instancias también necesita inicializar la instancia, este proceso lo
completa el }\textstyleSourceText{\foreignlanguage{spanish}{Constructor}}\foreignlanguage{spanish}{. Además, puedes
completar la destrucción del objeto a través del
}\textstyleSourceText{\foreignlanguage{spanish}{Destructor}}\foreignlanguage{spanish}{ antes de recuperar la memoria
del objeto.}

{\selectlanguage{spanish}
En la implementación interna, la instancia contendrá una referencia a la clase, y la instancia en sí misma solo almacena
variables miembro y no métodos.}

\subsubsection[2.1.2 Tipo de clase]{\selectlanguage{spanish} 2.1.2 Tipo de clase}
\hypertarget{RefHeadingToc355173639824055}{}\foreignlanguage{spanish}{Algunos de los tipos incorporados son tipos de
clase, son }\textstyleSourceText{\foreignlanguage{spanish}{list}}\foreignlanguage{spanish}{,
}\textstyleSourceText{\foreignlanguage{spanish}{map}}\foreignlanguage{spanish}{ y
}\textstyleSourceText{\foreignlanguage{spanish}{range}}\foreignlanguage{spanish}{. A diferencia de los tipos
personalizados, los tipos de clase integrados se pueden construir usando literales, por ejemplo,
}\textstyleSourceText{\foreignlanguage{spanish}{[1, 2, 3]}}\foreignlanguage{spanish}{ es un literal de tipo
}\textstyleSourceText{\foreignlanguage{spanish}{list}}\foreignlanguage{spanish}{.}

\paragraph[Lista]{\selectlanguage{spanish} Lista}
\hypertarget{RefHeadingToc355193639824055}{}{\selectlanguage{spanish}
La clase List es un contenedor que proporciona soporte para tipos de datos de lista. La lista de Berry es una colección
ordenada de elementos, y cada elemento de la lista tiene un índice entero único, y se puede acceder a cada elemento
directamente según el índice. List admite la inserción o eliminación de elementos en cualquier posición, y el elemento
puede ser de cualquier tipo. Además de usar índices, también puede usar iteradores para acceder a los elementos de la
lista.}

{\selectlanguage{spanish}
La implementación de List es una matriz dinámica y esta estructura de datos tiene un buen rendimiento de acceso
aleatorio. La eficiencia de agregar y eliminar elementos al final de la lista es muy alta, pero la eficiencia de
agregar y eliminar elementos en el medio de la lista es baja.}

{\selectlanguage{spanish}
El método de inicialización literal del contenedor List es usar una lista de objetos entre corchetes y múltiples objetos
separados por comas, por ejemplo:}


\bigskip

{\selectlanguage{spanish}\ttfamily
[]}

{\selectlanguage{spanish}\ttfamily
['string']}

{\selectlanguage{spanish}\ttfamily
[0, 1, 2,'list']}

{\selectlanguage{spanish}
Operaciones: ver capítulo 7.}

\paragraph[Mapa]{\selectlanguage{spanish} Mapa}
\hypertarget{RefHeadingToc355213639824055}{}{\selectlanguage{spanish}
El mapa también es un tipo de contenedor, el mapa es una colección de pares clave-valor, y cada clave posible aparece
como máximo una vez en la colección. El contenedor Mapa proporciona las siguientes operaciones básicas:}

\liststyleLiii
\begin{itemize}
\item {\selectlanguage{spanish}
Agregar pares clave-valor a la colección}
\item {\selectlanguage{spanish}
Eliminar pares clave-valor de la colección}
\item {\selectlanguage{spanish}
Modificar el valor correspondiente a una clave existente}
\item {\selectlanguage{spanish}
Encuentra el valor correspondiente por clave}
\end{itemize}
{\selectlanguage{spanish}
El mapa se implementa utilizando una tabla hash y tiene una alta eficiencia de búsqueda. La operación de agregar y
eliminar pares clave-valor consumirá más tiempo si se produce un {\textquotedbl}rehashing{\textquotedbl}.}

{\selectlanguage{spanish}
El contenedor Map también se puede inicializar con valores literales, escritos entre llaves para encerrar una lista de
pares clave-valor, separados por dos puntos entre claves y valores, y separados por comas entre pares clave-valor.
P.ej:}


\bigskip

{\selectlanguage{spanish}\ttfamily
\{\}}

{\selectlanguage{spanish}\ttfamily
\{'str':'hola'\}}

{\selectlanguage{spanish}\ttfamily
\{'str':'hola','int': 45, 78: nil\}}


\bigskip

{\selectlanguage{spanish}
Operaciones: ver capítulo 7.}

\paragraph[Rango]{\selectlanguage{spanish} Rango}
\hypertarget{RefHeadingToc355233639824055}{}\foreignlanguage{spanish}{El contenedor Range representa un rango de
enteros, que generalmente se usa para iterar en un rango de enteros. Este tipo tiene un miembro
}\textstyleSourceText{\foreignlanguage{spanish}{\_\_lower\_\_}}\foreignlanguage{spanish}{ y un miembro
}\textstyleSourceText{\foreignlanguage{spanish}{\_\_upper\_\_}}\foreignlanguage{spanish}{, que representan los límites
inferior y superior del rango, respectivamente. El valor literal de Range es un par de enteros conectados mediante el
operador }\textstyleSourceText{\foreignlanguage{spanish}{..}}\foreignlanguage{spanish}{:}


\bigskip

{\selectlanguage{spanish}\ttfamily
0 .. 10}

{\selectlanguage{spanish}\ttfamily
{}-5 .. 5}


\bigskip

\foreignlanguage{spanish}{Cuando la clase Range se usa para la iteración, los elementos de la iteración son todos
valores enteros desde el límite inferior hasta el límite superior, incluidos los valores límite. Por ejemplo, el
resultado de la iteración de }\textstyleSourceText{\foreignlanguage{spanish}{0..5}}\foreignlanguage{spanish}{ es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
0 1 2 3 4 5}


\bigskip

{\selectlanguage{spanish}
Por tanto, cabe señalar que para un rango de \textit{x} .. (\textit{x}+\textit{n}), el número de iteraciones es
\textit{n} + 1. Una construcción común para iterar a través de los elementos de una lista por elemento es:}

{\selectlanguage{spanish}\ttfamily
for i: 0..size(l)-1}

{\selectlanguage{spanish}
Rango abierto: si omite el último rango, se reemplaza implícitamente con MAXINT.}


\bigskip

{\selectlanguage{spanish}\ttfamily
{\textgreater} r = 10..}

{\selectlanguage{spanish}\ttfamily
{\textgreater} r}

{\selectlanguage{spanish}\ttfamily
(10..9223372036854775807)}

\paragraph[Bytes]{\selectlanguage{spanish} Bytes}
\hypertarget{RefHeadingToc355253639824055}{}{\selectlanguage{spanish}
El objeto Bytes denota un búfer de bytes que se puede usar para manipular búferes de bytes o para leer/escribir algunas
áreas o estructuras de memoria C.}

{\selectlanguage{spanish}
Consulte el Capítulo 7.}

\subsection[2.2 Variables]{\selectlanguage{spanish} 2.2 Variables}
\hypertarget{RefHeadingToc355273639824055}{}{\selectlanguage{spanish}
Una variable es un espacio de almacenamiento con un nombre, y los datos o la información almacenados en el espacio de
almacenamiento se denominan valor de la variable. Los nombres de variables se utilizan para hacer referencia a las
variables en el código fuente. En diferentes ámbitos, un nombre de variable puede vincular varias variables
independientes, pero las variables no tienen alias. El valor de la variable se puede acceder o cambiar en cualquier
momento durante la ejecución del programa. Berry es un lenguaje de tipo dinámico, por lo que el tipo de valor de la
variable se determina en tiempo de ejecución y la variable puede almacenar cualquier tipo de valor.}

\subsubsection[2.2.1 Definir variables]{\selectlanguage{spanish} 2.2.1 Definir variables}
\hypertarget{RefHeadingToc355293639824055}{}{\selectlanguage{spanish}
La primera forma de definir una variable es usar una declaración de asignación para asignar un valor a un nuevo nombre
de variable:}


\bigskip

{\selectlanguage{spanish}\ttfamily
{}'var' = \ expresión}


\bigskip

{\selectlanguage{spanish}
\textbf{var} es el nombre de la variable, y el nombre de la variable es un identificador (consulte la sección
identificador). \textbf{expresión} es la expresión para inicializar la variable.}


\bigskip

{\selectlanguage{spanish}\ttfamily
a = 1}

{\selectlanguage{spanish}\ttfamily
b ='str'}


\bigskip

{\selectlanguage{spanish}
Sin embargo, este método de definición de variables tiene algunas limitaciones. Tome el siguiente código como ejemplo:}


\bigskip

{\selectlanguage{spanish}\ttfamily
i = 0}

{\selectlanguage{spanish}\ttfamily
do}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ i = 1}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ print(i) \# 1}

{\selectlanguage{spanish}\ttfamily
end}

{\selectlanguage{spanish}\ttfamily
print(i) \# 1}


\bigskip

\foreignlanguage{spanish}{La instrucción }\textstyleSourceText{\foreignlanguage{spanish}{do}}\foreignlanguage{spanish}{
en la rutina constituye el alcance interno. Modificamos el valor de la variable
}\textstyleSourceText{\foreignlanguage{spanish}{i}}\foreignlanguage{spanish}{ en la línea 3, y el valor de
}\textstyleSourceText{\foreignlanguage{spanish}{i}}\foreignlanguage{spanish}{ sigue siendo
}\textstyleSourceText{\foreignlanguage{spanish}{1}}\foreignlanguage{spanish}{ después de dejar el alcance interno en la
línea 6. Si queremos que la variable }\textstyleSourceText{\foreignlanguage{spanish}{i}}\foreignlanguage{spanish}{ del
ámbito interno sea una variable independiente, el método de definir la variable mediante la asignación directa al nuevo
nombre de variable no puede cumplir el requisito, porque el identificador
}\textstyleSourceText{\foreignlanguage{spanish}{i}}\foreignlanguage{spanish}{ ya existe en el ámbito externo. En este
caso, la variable se puede definir mediante la palabra clave
}\textstyleSourceText{\foreignlanguage{spanish}{var}}\foreignlanguage{spanish}{:}


\bigskip

{\selectlanguage{spanish}\ttfamily
{}'var' variable}

{\selectlanguage{spanish}\ttfamily
{}'var' variable = expresión}


\bigskip

\foreignlanguage{spanish}{Hay dos formas de usar
}\textstyleSourceText{\foreignlanguage{spanish}{var}}\foreignlanguage{spanish}{ para definir una variable: la primera
es seguir el nombre de la variable }\foreignlanguage{spanish}{\textbf{variable}}\foreignlanguage{spanish}{ después de
la palabra clave }\textstyleSourceText{\foreignlanguage{spanish}{var}}\foreignlanguage{spanish}{, en este caso la
variable se inicializará a }\textstyleSourceText{\foreignlanguage{spanish}{nil}}\foreignlanguage{spanish}{, y la otra
se escribe en la variable y se inicializa al mismo tiempo que se define la variable. En este caso, se requiere una
expresión de valor inicial }\foreignlanguage{spanish}{\textbf{expresión}}\foreignlanguage{spanish}{. Usar
}\textstyleSourceText{\foreignlanguage{spanish}{var}}\foreignlanguage{spanish}{ para definir una variable tiene dos
posibles resultados: si el alcance actual no define la variable de
}\foreignlanguage{spanish}{\textbf{variable}}\foreignlanguage{spanish}{, definir e inicializar la variable, de lo
contrario, es equivalente a reinicializar la variable. Por lo tanto, la variable definida con
}\textstyleSourceText{\foreignlanguage{spanish}{var}}\foreignlanguage{spanish}{ protegerá a la variable con el mismo
nombre en el ámbito externo.}

\foreignlanguage{spanish}{Ahora cambiamos el ejemplo anterior para usar la palabra clave
}\textstyleSourceText{\foreignlanguage{spanish}{var}}\foreignlanguage{spanish}{ para definir variables:}


\bigskip

{\selectlanguage{spanish}\ttfamily
i = 0}

{\selectlanguage{spanish}\ttfamily
do}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ var i = 1}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ print(i) \# 1}

{\selectlanguage{spanish}\ttfamily
end}

{\selectlanguage{spanish}\ttfamily
print(i) \# 0}


\bigskip

\foreignlanguage{spanish}{A partir de la rutina modificada, se puede encontrar que el valor de la variable
}\textstyleSourceText{\foreignlanguage{spanish}{i}}\foreignlanguage{spanish}{ en el ámbito interno es
}\textstyleSourceText{\foreignlanguage{spanish}{1}}\foreignlanguage{spanish}{, y su valor en el ámbito externo es
}\textstyleSourceText{\foreignlanguage{spanish}{0}}\foreignlanguage{spanish}{. Esto prueba que después de usar la
palabra clave }\textstyleSourceText{\foreignlanguage{spanish}{var}}\foreignlanguage{spanish}{, se define una nueva
variable }\textstyleSourceText{\foreignlanguage{spanish}{i}}\foreignlanguage{spanish}{ en el ámbito interno y se
bloquea la variable con el mismo nombre en el ámbito externo. Una vez que finaliza el ámbito interno, el identificador
}\textstyleSourceText{\foreignlanguage{spanish}{i}}\foreignlanguage{spanish}{ vuelve a vincularse a la variable
}\textstyleSourceText{\foreignlanguage{spanish}{i}}\foreignlanguage{spanish}{ en el ámbito externo.}

\foreignlanguage{spanish}{Al usar la palabra clave
}\textstyleSourceText{\foreignlanguage{spanish}{var}}\foreignlanguage{spanish}{ para definir una variable, también
puede usar una lista de múltiples nombres de variables, separados por comas. También puede inicializar una o más
variables al definir variables:}


\bigskip

{\selectlanguage{spanish}\ttfamily
var a = 0, b, c ='test'}

\subsubsection[2.2.2 Alcance y Ciclo de Vida]{\selectlanguage{spanish} 2.2.2 Alcance y Ciclo de Vida}
\hypertarget{RefHeadingToc355313639824055}{}{\selectlanguage{spanish}
Como se mencionó anteriormente, los nombres de las variables se pueden vincular a varias entidades de variables
(espacios de almacenamiento) y los nombres de las variables se vinculan a una sola entidad en cada posición. La entidad
vinculada por el nombre de la variable debe determinarse de acuerdo con la posición en la que aparece el nombre de la
variable.}

{\selectlanguage{spanish}
\textbf{Ámbito} se refiere al área de código donde el nombre y la entidad están vinculados de forma única. Fuera del
alcance, el nombre puede estar vinculado a otras entidades, o no estar vinculado a ninguna entidad. La entidad solo es
visible en el alcance asociado al nombre, es decir, la variable solo es válida en su alcance. Un bloque de código (ver
bloque) es un alcance. Una variable solo está disponible dentro del bloque, y los nombres en diferentes bloques pueden
vincular diferentes entidades variables. El siguiente ejemplo demuestra el alcance de las variables:}


\bigskip

{\selectlanguage{spanish}\ttfamily
var i = 0}

{\selectlanguage{spanish}\ttfamily
do}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ var j ='str'}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ print(i, j) \# 0 str}

{\selectlanguage{spanish}\ttfamily
end}

{\selectlanguage{spanish}\ttfamily
\# \ La variable j no está disponible aquí}

{\selectlanguage{spanish}\ttfamily
print(i) \# 0}


\bigskip

\foreignlanguage{spanish}{Los nombres }\textstyleSourceText{\foreignlanguage{spanish}{i}}\foreignlanguage{spanish}{ y
}\textstyleSourceText{\foreignlanguage{spanish}{j}}\foreignlanguage{spanish}{ se definen en esta rutina. El nombre
}\textstyleSourceText{\foreignlanguage{spanish}{i}}\foreignlanguage{spanish}{ se define fuera de la Sentencia
}\textstyleSourceText{\foreignlanguage{spanish}{do}}\foreignlanguage{spanish}{, y el nombre definido en el bloque más
externo tiene }\foreignlanguage{spanish}{\textbf{Alcance global}}\foreignlanguage{spanish}{. El nombre con alcance
global está disponible en todo el programa después de la personalización. El nombre
}\textstyleSourceText{\foreignlanguage{spanish}{j}}\foreignlanguage{spanish}{ se define en el bloque en la Sentencia
}\textstyleSourceText{\foreignlanguage{spanish}{do}}\foreignlanguage{spanish}{, y el nombre de este tipo de definición
en el bloque no exterior tiene }\foreignlanguage{spanish}{\textbf{Ámbito local}}\foreignlanguage{spanish}{. No se puede
acceder a un nombre con un ámbito local fuera del ámbito.}

\foreignlanguage{spanish}{Berry tiene algunos objetos integrados, que están todos en el ámbito global. Sin embargo, los
objetos integrados y las variables globales definidas en los scripts no están en el mismo ámbito global. Los objetos
integrados en realidad pertenecen al }\foreignlanguage{spanish}{\textbf{Alcance integrado}}\foreignlanguage{spanish}{.
El alcance es visible globalmente como el alcance global ordinario, pero puede estar cubierto por el alcance global
ordinario. Los objetos incorporados incluyen funciones y clases en la }\foreignlanguage{spanish}{biblioteca estándar.
Estos objetos incluyen funciones de
}\textstyleSourceText{\foreignlanguage{spanish}{impresión}}\foreignlanguage{spanish}{, funciones de
}\textstyleSourceText{\foreignlanguage{spanish}{tipo}}\foreignlanguage{spanish}{ y clases de
}\textstyleSourceText{\foreignlanguage{spanish}{mapa}}\foreignlanguage{spanish}{. A diferencia de otros ámbitos, las
variables en el ámbito integrado son de solo lectura, por lo que la {\textquotedbl}asignación{\textquotedbl} a las
variables en el ámbito integrado en realidad define una variable con el mismo nombre en el ámbito global, que anula los
símbolos en el ámbito en el alcance incorporado.}

\paragraph[Alcance anidado]{\selectlanguage{spanish} Alcance anidado}
\hypertarget{RefHeadingToc355333639824055}{}\foreignlanguage{spanish}{Ámbito anidado significa que el ámbito contiene
otro ámbito. Llamamos al ámbito contenido }\foreignlanguage{spanish}{\textbf{Ámbito interno}}\foreignlanguage{spanish}{
y al ámbito que contiene el ámbito interno }\foreignlanguage{spanish}{\textbf{Ámbito
externo}}\foreignlanguage{spanish}{. Se puede acceder al nombre definido en el ámbito externo en todos los ámbitos
internos. El ámbito interno también puede volver a vincular el nombre ya definido en el ámbito externo. El ejemplo
anterior usando }\textstyleSourceText{\foreignlanguage{spanish}{var}}\foreignlanguage{spanish}{ para definir variables
describe este escenario.}

\paragraph[Ciclo de vida variable]{\selectlanguage{spanish} Ciclo de vida variable}
\hypertarget{RefHeadingToc355353639824055}{}{\selectlanguage{spanish}
No existe el concepto de nombres de variables cuando el programa se está ejecutando, y las variables existen en forma de
entidades en este momento. El {\textquotedbl}período de validez{\textquotedbl} de una variable durante la ejecución del
programa es el \textbf{ciclo de vida} de la variable. Las variables en tiempo de ejecución solo son válidas dentro del
alcance. Después de salir del alcance, las variables se destruirán para recuperar recursos.}

{\selectlanguage{spanish}
Las variables definidas en el ámbito global se denominan \textbf{Variable global} y tienen \textbf{Ciclo de vida
estático}. Se puede acceder a dichas variables durante todo el programa en ejecución y no se destruirán. Las variables
definidas en el ámbito local se denominan \textbf{Variable local} y tienen \textbf{Ciclo de vida dinámico}. No se puede
acceder a dichas variables después de abandonar el alcance y se destruirán.}

{\selectlanguage{spanish}
Debido a los diferentes ciclos de vida, las variables locales y las variables globales usan diferentes formas de asignar
el espacio de almacenamiento. Las variables locales se asignan en una estructura llamada \textbf{Pila} (stack), y los
objetos asignados en función de la pila se pueden reclamar rápidamente al final del alcance. Las variables globales se
asignan en \textbf{Tabla global} (tabla global). Los objetos de la tabla global no se reciclarán una vez creados y se
puede acceder a la tabla desde cualquier parte del programa.}

\subsubsection[2.2.3 Tipo de variable]{\selectlanguage{spanish} 2.2.3 Tipo de variable}
\hypertarget{RefHeadingToc355373639824055}{}\foreignlanguage{spanish}{Berry determina el tipo de variable en tiempo de
ejecución. En otras palabras, la variable puede almacenar cualquier tipo de valor. Por lo tanto, Berry es un lenguaje
de }\foreignlanguage{spanish}{\textbf{escritura dinámica}}\foreignlanguage{spanish}{. El intérprete no deduce el tipo
de la variable en tiempo de compilación, lo que puede provocar que se expongan algunos errores en tiempo de ejecución.
Por ejemplo, el error generado al ejecutar la expresión }\textstyleSourceText{\foreignlanguage{spanish}{{}'1' +
1}}\foreignlanguage{spanish}{ es un error de tiempo de ejecución y no un error del compilador. La ventaja de usar tipos
dinámicos es que se pueden simplificar muchos diseños y el programa será más flexible, sin mencionar la necesidad de
diseñar un sistema de inferencia de tipos complejo.}

\foreignlanguage{spanish}{Debido a que el intérprete no verifica el tipo, es posible que el código de usuario deba
determinar el tipo de valor por sí mismo, y esta característica también se puede usar para implementar algunas
operaciones especiales. Esta característica también hace que las funciones sobrecargadas sean innecesarias. Por
ejemplo, la función nativa }\textstyleSourceText{\foreignlanguage{spanish}{type}}\foreignlanguage{spanish}{ acepta
cualquier tipo de parámetro y devuelve una cadena que describe el tipo de parámetro.}

\clearpage\section[Capítulo 3: Expresiones]{Capítulo 3: \foreignlanguage{spanish}{Expresiones}}
\hypertarget{RefHeadingToc355393639824055}{}
\bigskip

\subsection[3.1 Conceptos básicos]{\selectlanguage{spanish} 3.1 Conceptos básicos}
\hypertarget{RefHeadingToc355413639824055}{}{\selectlanguage{spanish}
Una expresión (Declaración) se compone de uno a más operandos y operadores, y se puede obtener un resultado evaluando la
expresión. Este resultado se llama el valor de la expresión. El operando puede ser un valor literal, una variable, una
llamada de función o una subexpresión, etc. Las expresiones y operadores simples también se pueden combinar en
expresiones más complejas. Similar a las cuatro operaciones aritméticas, la precedencia de los operadores afecta el
orden de evaluación de las expresiones. Cuanto mayor sea la precedencia del operador, antes se evaluará la expresión.}

\subsubsection[3.1.1 Operadores y expresiones]{\selectlanguage{spanish} 3.1.1 Operadores y expresiones}
\hypertarget{RefHeadingToc355433639824055}{}\foreignlanguage{spanish}{Berry proporciona algunos operadores unarios y
operadores binarios. Por ejemplo, el operador AND lógico
}\textstyleSourceText{\foreignlanguage{spanish}{\&\&}}\foreignlanguage{spanish}{ es un operador binario, y el operador
de negación lógica }\textstyleSourceText{\foreignlanguage{spanish}{!}}\foreignlanguage{spanish}{ es un operador unario.
Algunos operadores pueden ser operadores unarios u operadores binarios. El significado específico de tales operadores
depende del contexto. Por ejemplo, el operador
}\textstyleSourceText{\foreignlanguage{spanish}{{}-}}\foreignlanguage{spanish}{ es un símbolo unario en la expresión
}\textstyleSourceText{\foreignlanguage{spanish}{{}-1}}\foreignlanguage{spanish}{, pero es un signo menos binario en la
expresión }\textstyleSourceText{\foreignlanguage{spanish}{1-2}}\foreignlanguage{spanish}{.}

\paragraph[Expresión de combinación de operadores]{\selectlanguage{spanish} Expresión de combinación de operadores}
\hypertarget{RefHeadingToc355453639824055}{}{\selectlanguage{spanish}
Tanto el lado izquierdo como el derecho de un operador binario pueden ser subexpresiones, por lo que puede usar
operadores binarios para combinar expresiones. Una expresión más compleja suele tener varios operadores y operandos. En
este momento, el orden de evaluación de cada subexpresión en la expresión puede afectar el valor de la expresión. La
precedencia y asociatividad de los operadores garantizan la unicidad del orden de evaluación de la expresión. Por
ejemplo, una expresión combinada:}


\bigskip

{\selectlanguage{spanish}\ttfamily
1 + 10/2 * 3}


\bigskip

\foreignlanguage{spanish}{Las cuatro operaciones aritméticas de uso diario calcularán primero la expresión de división
}\textstyleSourceText{\foreignlanguage{spanish}{10/2}}\foreignlanguage{spanish}{, luego la expresión de multiplicación
y finalmente la expresión de suma. Esto se debe a que la multiplicación y la división tienen mayor prioridad que la
suma.}

\paragraph[Tipo de operando]{\selectlanguage{spanish} Tipo de operando}
\hypertarget{RefHeadingToc355473639824055}{}\foreignlanguage{spanish}{En la operación de expresiones, los operandos
pueden tener tipos que no coincidan con los operadores. Además, los operadores binarios normalmente requieren que los
operandos izquierdo y derecho sean del mismo tipo. La expresión
}\textstyleSourceText{\foreignlanguage{spanish}{{}'10'+10}}\foreignlanguage{spanish}{ es incorrecta. No puede agregar
una cadena a un número entero. El problema con la expresión
}\textstyleSourceText{\foreignlanguage{spanish}{{}-'b'}}\foreignlanguage{spanish}{ es que no puedes tomar un valor
negativo en una cadena. A veces, un operador binario tiene diferentes tipos de operandos pero puede realizar
operaciones. Por ejemplo, al agregar un número entero a un número real, el objeto entero se convertirá en un número
real y se agregará a otro objeto de número real. Los operadores lógicos AND y OR lógicos permiten que los operandos a
ambos lados del operador sean de cualquier tipo. En expresiones lógicas, siempre se convertirán al tipo
}\textstyleSourceText{\foreignlanguage{spanish}{booleano}}\foreignlanguage{spanish}{ de acuerdo con ciertas reglas.}

{\selectlanguage{spanish}
Otra situación es que los operadores pueden sobrecargarse al usar clases personalizadas. En esencia, puede interpretar
este operador arbitrariamente y depende de usted decidir qué tipo de operando debe ser.}

\subsubsection[3.1.2 Prioridad y asociatividad]{\selectlanguage{spanish} 3.1.2 Prioridad y asociatividad}
\hypertarget{RefHeadingToc355493639824055}{}{\selectlanguage{spanish}
En una expresión compuesta de varios operadores, la precedencia y la asociatividad de los operadores determinan el orden
de evaluación de las expresiones. La precedencia y asociatividad de cada operador se dan en la Tabla 2 .}

\foreignlanguage{spanish}{La precedencia especifica el orden de evaluación entre diferentes operadores, y las
expresiones con operadores de mayor precedencia se evaluarán primero. Por ejemplo, el proceso de evaluar la expresión
}\textstyleSourceText{\foreignlanguage{spanish}{1+2*3}}\foreignlanguage{spanish}{ calculará primero el resultado de
}\textstyleSourceText{\foreignlanguage{spanish}{2*3}}\foreignlanguage{spanish}{ y luego el resultado de la expresión de
suma. El uso de paréntesis puede mejorar el orden de evaluación de las expresiones de baja prioridad. Por ejemplo, en
la evaluación de la expresión }\textstyleSourceText{\foreignlanguage{spanish}{(1+2)*3}}\foreignlanguage{spanish}{,
primero se calcula el resultado de la expresión
}\textstyleSourceText{\foreignlanguage{spanish}{1+2}}\foreignlanguage{spanish}{ entre paréntesis y luego se calcula la
expresión de multiplicación fuera de los paréntesis.}

\foreignlanguage{spanish}{La asociatividad se refiere al orden de evaluación de los operandos en ambos lados del
operador, donde los operandos pueden ser subexpresiones. Por ejemplo, en la expresión de suma
}\textstyleSourceText{\foreignlanguage{spanish}{expr1 + expr2}}\foreignlanguage{spanish}{, el valor de
}\textstyleSourceText{\foreignlanguage{spanish}{expr1}}\foreignlanguage{spanish}{ se calcula primero y luego el valor
de }\textstyleSourceText{\foreignlanguage{spanish}{expr2}}\foreignlanguage{spanish}{, porque el operador de suma es
asociativo por la izquierda.}


\bigskip

\begin{center}
\tablefirsthead{\centering{\selectlanguage{spanish}\bfseries Prioridad} &
\centering{\selectlanguage{spanish}\bfseries Operador} &
{\selectlanguage{spanish}\bfseries Descripción} &
\centering\arraybslash{\selectlanguage{spanish}\bfseries Asociatividad}\\}
\tablehead{\centering{\selectlanguage{spanish}\bfseries Prioridad} &
\centering{\selectlanguage{spanish}\bfseries Operador} &
{\selectlanguage{spanish}\bfseries Descripción} &
\centering\arraybslash{\selectlanguage{spanish}\bfseries Asociatividad}\\}
\tabletail{}
\tablelasttail{}
\begin{supertabular}{m{2.303cm}m{3.462cm}m{5.573cm}m{3.783cm}}
\centering{\selectlanguage{spanish} 1} &
\centering \textstyleSourceText{\foreignlanguage{spanish}{()}} &
{\selectlanguage{spanish} Símbolo de agrupación} &
\centering\arraybslash{\selectlanguage{spanish} {}-}\\
\centering{\selectlanguage{spanish} 2} &
\centering \textstyleSourceText{\foreignlanguage{spanish}{() [] .}} &
{\selectlanguage{spanish} Operación de campo} &
\centering\arraybslash{\selectlanguage{spanish} izquierda}\\
\centering{\selectlanguage{spanish} 3} &
\centering \textstyleSourceText{\foreignlanguage{spanish}{{}-! \~{}}} &
{\selectlanguage{spanish} Signo negativo, negación lógica, cambio de bit} &
\centering\arraybslash{\selectlanguage{spanish} izquierda}\\
\centering{\selectlanguage{spanish} 4} &
\centering \textstyleSourceText{\foreignlanguage{spanish}{* / \%}} &
{\selectlanguage{spanish} Multiplicación, división y resto} &
\centering\arraybslash{\selectlanguage{spanish} izquierda}\\
\centering{\selectlanguage{spanish} 5} &
\centering \textstyleSourceText{\foreignlanguage{spanish}{+ -}} &
{\selectlanguage{spanish} Suma, resta} &
\centering\arraybslash{\selectlanguage{spanish} izquierda}\\
\centering{\selectlanguage{spanish} 6} &
\centering \textstyleSourceText{\foreignlanguage{spanish}{{\textless}{\textless} {\textgreater}{\textgreater}}} &
{\selectlanguage{spanish} Mover a la izquierda, mover a la derecha} &
\centering\arraybslash{\selectlanguage{spanish} izquierda}\\
\centering{\selectlanguage{spanish} 7} &
\centering \textstyleSourceText{\foreignlanguage{spanish}{\&}} &
{\selectlanguage{spanish} Bit a bit Y} &
\centering\arraybslash{\selectlanguage{spanish} izquierda}\\
\centering{\selectlanguage{spanish} 8} &
\centering \textstyleSourceText{\foreignlanguage{spanish}{\^{}}} &
{\selectlanguage{spanish} XOR bit a bit} &
\centering\arraybslash{\selectlanguage{spanish} izquierda}\\
\centering{\selectlanguage{spanish} 9} &
\centering \textstyleSourceText{\foreignlanguage{spanish}{{\textbar}}} &
{\selectlanguage{spanish} Bit a bit O} &
\centering\arraybslash{\selectlanguage{spanish} izquierda}\\
\centering{\selectlanguage{spanish} 10} &
\centering \textstyleSourceText{\foreignlanguage{spanish}{..}} &
{\selectlanguage{spanish} Operador de concatenación} &
\centering\arraybslash{\selectlanguage{spanish} izquierda}\\
\centering{\selectlanguage{spanish} 11} &
\centering \textstyleSourceText{\foreignlanguage{spanish}{{\textless} {\textless}= {\textgreater} {\textgreater}=}} &
{\selectlanguage{spanish} Mayor que, mayor que o igual a} &
\centering\arraybslash{\selectlanguage{spanish} izquierda}\\
\centering{\selectlanguage{spanish} 12} &
\centering \textstyleSourceText{\foreignlanguage{spanish}{== !=}} &
{\selectlanguage{spanish} Igual a, no igual a} &
\centering\arraybslash{\selectlanguage{spanish} izquierda}\\
\centering{\selectlanguage{spanish} 13} &
\centering \textstyleSourceText{\foreignlanguage{spanish}{\&\&}} &
{\selectlanguage{spanish} Y lógico} &
\centering\arraybslash{\selectlanguage{spanish} izquierda}\\
\centering{\selectlanguage{spanish} 14} &
\centering \textstyleSourceText{\foreignlanguage{spanish}{{\textbar}{\textbar}}} &
{\selectlanguage{spanish} O lógico} &
\centering\arraybslash{\selectlanguage{spanish} izquierda}\\
\centering{\selectlanguage{spanish} 15} &
\centering \textstyleSourceText{\foreignlanguage{spanish}{? :}} &
{\selectlanguage{spanish} Operador condicional} &
\centering\arraybslash{\selectlanguage{spanish} derecha}\\
\centering{\selectlanguage{spanish} 16} &
\centering \textstyleSourceText{\foreignlanguage{spanish}{\&= {\textbar}= \^{}= {\textless}{\textless}=
{\textgreater}{\textgreater}=}} &
{\selectlanguage{spanish} Asignación} &
\centering\arraybslash{\selectlanguage{spanish} derecha}\\
\end{supertabular}
\end{center}
{\selectlanguage{spanish}\itshape
Tabla 2: Lista de operadores}


\bigskip

\paragraph[Utilice corchetes para aumentar la prioridad]{\selectlanguage{spanish} Utilice corchetes para aumentar la
prioridad}
\hypertarget{RefHeadingToc355513639824055}{}{\selectlanguage{spanish}
Los paréntesis se pueden usar cuando necesitamos que los operadores con menor precedencia se evalúen primero. Durante la
evaluación de expresiones, primero se calcula el valor de la expresión entre paréntesis. En otras palabras, para toda
la expresión, la expresión entre paréntesis es equivalente a un operando, independientemente de la composición de la
expresión entre paréntesis.}

\subsection[3.2 Operador]{\selectlanguage{spanish} 3.2 Operador}
\hypertarget{RefHeadingToc355533639824055}{}\subsubsection[3.2.1 Operadores aritméticos]{\selectlanguage{spanish} 3.2.1
Operadores aritméticos}
\hypertarget{RefHeadingToc355553639824055}{}{\selectlanguage{spanish}
Los operadores aritméticos se utilizan para implementar operaciones aritméticas. Estos operadores son similares a los
símbolos matemáticos que solemos usar. Los operadores aritméticos provistos por Berry se muestran en la Tabla 3 .}


\bigskip

\begin{center}
\tablefirsthead{\centering{\selectlanguage{spanish}\bfseries Operador} &
\centering{\selectlanguage{spanish}\bfseries Descripción} &
\centering\arraybslash{\selectlanguage{spanish}\bfseries Ejemplo}\\}
\tablehead{\centering{\selectlanguage{spanish}\bfseries Operador} &
\centering{\selectlanguage{spanish}\bfseries Descripción} &
\centering\arraybslash{\selectlanguage{spanish}\bfseries Ejemplo}\\}
\tabletail{}
\tablelasttail{}
\begin{supertabular}{m{3.178cm}m{7.0350003cm}m{5.1080003cm}}
\centering \textstyleSourceText{\foreignlanguage{spanish}{{}-}} &
\centering{\selectlanguage{spanish} menos unario} &
\centering\arraybslash \textstyleSourceText{\foreignlanguage{spanish}{{}- expr}}\\
\centering \textstyleSourceText{\foreignlanguage{spanish}{+}} &
\centering{\selectlanguage{spanish} Concatenación más/cadena} &
\centering\arraybslash \textstyleSourceText{\foreignlanguage{spanish}{expr + expr}}\\
\centering \textstyleSourceText{\foreignlanguage{spanish}{{}-}} &
\centering{\selectlanguage{spanish} signo menos} &
\centering\arraybslash \textstyleSourceText{\foreignlanguage{spanish}{expr-expr}}\\
\centering \textstyleSourceText{\foreignlanguage{spanish}{*}} &
\centering{\selectlanguage{spanish} Signo de multiplicación} &
\centering\arraybslash \textstyleSourceText{\foreignlanguage{spanish}{expr * expr}}\\
\centering \textstyleSourceText{\foreignlanguage{spanish}{/}} &
\centering{\selectlanguage{spanish} Signo de división} &
\centering\arraybslash \textstyleSourceText{\foreignlanguage{spanish}{expr / expr}}\\
\centering \textstyleSourceText{\foreignlanguage{spanish}{\%}} &
\centering{\selectlanguage{spanish} Toma el resto} &
\centering\arraybslash \textstyleSourceText{\foreignlanguage{spanish}{expr\%expr}}\\
\end{supertabular}
\end{center}
{\selectlanguage{spanish}\itshape
Tabla 3: Operador aritmético}


\bigskip

\foreignlanguage{spanish}{Operador binario }\textstyleSourceText{\foreignlanguage{spanish}{+}}\foreignlanguage{spanish}{
Además de ser un signo más, también es una concatenación de cadenas. Cuando el operando de este operador es una cadena,
la concatenación de cadenas se realizará para concatenar dos cadenas en una cadena más larga. Para ser precisos,
}\textstyleSourceText{\foreignlanguage{spanish}{+}}\foreignlanguage{spanish}{ como concatenación de cadenas ya no está
en la categoría de operadores aritméticos.}

\foreignlanguage{spanish}{El operador binario
}\textstyleSourceText{\foreignlanguage{spanish}{\%}}\foreignlanguage{spanish}{ es el símbolo de resto. Sus operandos
deben ser números enteros. El resultado de la operación de resto es el resto después de dividir el operando izquierdo
por el operando derecho. Por ejemplo, el resultado de
}\textstyleSourceText{\foreignlanguage{spanish}{11\%4}}\foreignlanguage{spanish}{ es
}\textstyleSourceText{\foreignlanguage{spanish}{3}}\foreignlanguage{spanish}{. El tipo de número real no puede ser
divisible, por lo que no se admite el resto.}

\foreignlanguage{spanish}{En general, los operadores aritméticos no cumplen la ley conmutativa. Por ejemplo, los valores
de las expresiones }\textstyleSourceText{\foreignlanguage{spanish}{2/4}}\foreignlanguage{spanish}{ y
}\textstyleSourceText{\foreignlanguage{spanish}{4/2}}\foreignlanguage{spanish}{ no son iguales.}

{\selectlanguage{spanish}
Todos los operadores aritméticos se pueden sobrecargar en la clase. Los operadores sobrecargados no están necesariamente
limitados a su diseño funcional original, sino que son determinados por el programador.}

\subsubsection[3.2.2 Operadores relacionales]{\selectlanguage{spanish} 3.2.2 Operadores relacionales}
\hypertarget{RefHeadingToc355573639824055}{}{\selectlanguage{spanish}
Los operadores relacionales se utilizan para comparar la magnitud de los operandos. Los seis operadores relacionales
soportados por Berry se dan en la Tabla 4 .}


\bigskip

\begin{center}
\tablefirsthead{\centering{\selectlanguage{spanish}\bfseries Operador} &
\centering{\selectlanguage{spanish}\bfseries Descripción} &
\centering\arraybslash{\selectlanguage{spanish}\bfseries Ejemplo}\\}
\tablehead{\centering{\selectlanguage{spanish}\bfseries Operador} &
\centering{\selectlanguage{spanish}\bfseries Descripción} &
\centering\arraybslash{\selectlanguage{spanish}\bfseries Ejemplo}\\}
\tabletail{}
\tablelasttail{}
\begin{supertabular}{m{3.6629999cm}m{6.55cm}m{5.1080003cm}}
\centering \textstyleSourceText{\foreignlanguage{spanish}{{\textless}}} &
\centering{\selectlanguage{spanish} Menor que} &
\centering\arraybslash \textstyleSourceText{\foreignlanguage{spanish}{expr {\textless} expr}}\\
\centering \textstyleSourceText{\foreignlanguage{spanish}{{\textless}=}} &
\centering{\selectlanguage{spanish} Menor o igual que} &
\centering\arraybslash \textstyleSourceText{\foreignlanguage{spanish}{expr {\textless}= expr}}\\
\centering \textstyleSourceText{\foreignlanguage{spanish}{==}} &
\centering{\selectlanguage{spanish} Igual} &
\centering\arraybslash \textstyleSourceText{\foreignlanguage{spanish}{expr == expr}}\\
\centering \textstyleSourceText{\foreignlanguage{spanish}{!=}} &
\centering{\selectlanguage{spanish} No es igual a} &
\centering\arraybslash \textstyleSourceText{\foreignlanguage{spanish}{expr != expr}}\\
\centering \textstyleSourceText{\foreignlanguage{spanish}{{\textgreater}=}} &
\centering{\selectlanguage{spanish} Mayor o igual a} &
\centering\arraybslash \textstyleSourceText{\foreignlanguage{spanish}{expr {\textgreater}= expr}}\\
\centering \textstyleSourceText{\foreignlanguage{spanish}{{\textgreater}}} &
\centering{\selectlanguage{spanish} Mayor qu e} &
\centering\arraybslash \textstyleSourceText{\foreignlanguage{spanish}{{}-expr}}\\
\end{supertabular}
\end{center}
{\selectlanguage{spanish}\itshape
Tabla 4: Operador relacional}


\bigskip

\foreignlanguage{spanish}{Al comparar la relación de magnitud de los operandos o juzgar si los operandos son iguales, la
evaluación de la expresión relacional producirá un resultado booleano. Cuando se cumple la relación, el valor de la
expresión de la relación es {\textquotedbl}verdadero{\textquotedbl}, de lo contrario, es
{\textquotedbl}falso{\textquotedbl}. Los operadores relacionales
}\textstyleSourceText{\foreignlanguage{spanish}{==}}\foreignlanguage{spanish}{ y
}\textstyleSourceText{\foreignlanguage{spanish}{!=}}\foreignlanguage{spanish}{ pueden usar cualquier tipo de operando y
permiten que los operandos izquierdo y derecho tengan diferentes tipos. Otros operadores relacionales permiten el uso
de las siguientes combinaciones de operandos:}

{\selectlanguage{spanish}
\textbf{integer} relop}

{\selectlanguage{spanish}
\textbf{integer} \textbf{real} relop}

{\selectlanguage{spanish}
\textbf{real} \textbf{integer} relop}

{\selectlanguage{spanish}
\textbf{real} \textbf{real} relop}

{\selectlanguage{spanish}
\textbf{integer} \textbf{string} relop \textbf{string}}

\foreignlanguage{spanish}{En operaciones relacionales, el signo igual
}\textstyleSourceText{\foreignlanguage{spanish}{==}}\foreignlanguage{spanish}{ y el signo de desigualdad
}\textstyleSourceText{\foreignlanguage{spanish}{!=}}\foreignlanguage{spanish}{ satisfacen la ley conmutativa. Si los
operandos izquierdo y derecho son del mismo tipo o ambos son de tipo numérico (número entero y número real), los
operandos se consideran iguales según el valor de los operandos; de lo contrario, los operandos se consideran
desiguales. La igualdad y la desigualdad son operaciones recíprocas: si
}\textstyleSourceText{\foreignlanguage{spanish}{a==b}}\foreignlanguage{spanish}{ es verdadero, entonces
}\textstyleSourceText{\foreignlanguage{spanish}{a!=b}}\foreignlanguage{spanish}{ es falso, y viceversa. Otros
operadores relacionales no satisfacen la ley conmutativa, pero tienen las siguientes propiedades:
}\textstyleSourceText{\foreignlanguage{spanish}{{\textless}}}\foreignlanguage{spanish}{ y
}\textstyleSourceText{\foreignlanguage{spanish}{{\textgreater}=}}\foreignlanguage{spanish}{ son operaciones recíprocas,
y }\textstyleSourceText{\foreignlanguage{spanish}{{\textgreater}}}\foreignlanguage{spanish}{ y
}\textstyleSourceText{\foreignlanguage{spanish}{{\textless}=}}\foreignlanguage{spanish}{ son operaciones recíprocas.
Las operaciones relacionales requieren que los operandos sean del mismo tipo, de lo contrario es una expresión
incorrecta.}

{\selectlanguage{spanish}
Las instancias pueden sobrecargar a los operadores como métodos. Si el operador relacional está sobrecargado, el
programa debe garantizar las propiedades anteriores.}

\foreignlanguage{spanish}{Entre los operadores relacionales, los operadores
}\textstyleSourceText{\foreignlanguage{spanish}{==}}\foreignlanguage{spanish}{ y
}\textstyleSourceText{\foreignlanguage{spanish}{!=}}\foreignlanguage{spanish}{ tienen requisitos más relajados que
}\textstyleSourceText{\foreignlanguage{spanish}{{\textless}}}\foreignlanguage{spanish}{,
}\textstyleSourceText{\foreignlanguage{spanish}{{\textless}=}}\foreignlanguage{spanish}{,
}\textstyleSourceText{\foreignlanguage{spanish}{{\textgreater}}}\foreignlanguage{spanish}{ y
}\textstyleSourceText{\foreignlanguage{spanish}{{\textgreater}=}}\foreignlanguage{spanish}{, que solo permiten
comparaciones entre los mismos tipos. En el desarrollo de un programa real, el juicio de igualdad o desigualdad suele
ser más simple que el juicio de tamaño. Es posible que algunos objetos de operación no puedan juzgar el tamaño, pero
solo pueden juzgar la igualdad o desigualdad. Este es el caso del tipo booleano.}

\subsubsection[3.2.3 Operadores logicos]{\selectlanguage{spanish} 3.2.3 Operadores logicos}
\hypertarget{RefHeadingToc355593639824055}{}{\selectlanguage{spanish}
Los operadores lógicos se dividen en tres tipos: AND lógico, OR lógico y NOT lógico. Como se muestra en la Tabla 5 .}


\bigskip

\begin{center}
\tablefirsthead{\centering{\selectlanguage{spanish}\bfseries Operador} &
\centering{\selectlanguage{spanish}\bfseries Descripción} &
\centering\arraybslash{\selectlanguage{spanish}\bfseries Ejemplo}\\}
\tablehead{\centering{\selectlanguage{spanish}\bfseries Operador} &
\centering{\selectlanguage{spanish}\bfseries Descripción} &
\centering\arraybslash{\selectlanguage{spanish}\bfseries Ejemplo}\\}
\tabletail{}
\tablelasttail{}
\begin{supertabular}{m{3.462cm}m{6.7510004cm}m{5.1080003cm}}
\centering \textstyleSourceText{\foreignlanguage{spanish}{\&\&}} &
\centering{\selectlanguage{spanish} Y lógico} &
\centering\arraybslash \textstyleSourceText{\foreignlanguage{spanish}{expr \&\& expr}}\\
\centering \textstyleSourceText{\foreignlanguage{spanish}{{\textbar}{\textbar}}} &
\centering{\selectlanguage{spanish} O lógico} &
\centering\arraybslash \textstyleSourceText{\foreignlanguage{spanish}{expr{\textbar}{\textbar} expr}}\\
\centering \textstyleSourceText{\foreignlanguage{spanish}{!}} &
\centering{\selectlanguage{spanish} Negación lógica} &
\centering\arraybslash \textstyleSourceText{\foreignlanguage{spanish}{!expr}}\\
\end{supertabular}
\end{center}
{\selectlanguage{spanish}\itshape
Tabla 5: Operadores lógicos}


\bigskip

{\selectlanguage{spanish}
Para el operador lógico AND, cuando los valores de ambos operandos son {\textquotedbl}verdaderos{\textquotedbl}, el
valor de la expresión lógica es {\textquotedbl}verdadero{\textquotedbl}, de lo contrario, es
{\textquotedbl}falso{\textquotedbl}.}

\foreignlanguage{spanish}{Para el operador lógico OR, cuando los valores de ambos operandos son
}\textstyleSourceText{\foreignlanguage{spanish}{falso}}\foreignlanguage{spanish}{, el valor de la expresión lógica es
}\textstyleSourceText{\foreignlanguage{spanish}{falso}}\foreignlanguage{spanish}{, de lo contrario es
}\textstyleSourceText{\foreignlanguage{spanish}{verdadero}}\foreignlanguage{spanish}{.}

{\selectlanguage{spanish}
El papel del operador de negación lógica es cambiar el estado lógico del operando. Cuando el valor del operando es
{\textquotedbl}verdadero{\textquotedbl}, el valor de la expresión lógica es {\textquotedbl}falso{\textquotedbl}, de lo
contrario, el valor es {\textquotedbl}verdadero{\textquotedbl}.}

{\selectlanguage{spanish}
Los operadores lógicos requieren que el operando sea de tipo booleano, y si el operando no es de tipo booleano, se
convertirá. Consulte la sección [Capitulo-2: Tipo booleano] para conocer las reglas de conversión.}

{\selectlanguage{spanish}
Las operaciones lógicas utilizan una estrategia de evaluación llamada \textbf{Evaluación de cortocircuito}. Esta
estrategia de evaluación es: para el operador lógico AND, el segundo operando se evaluará si y solo si el operando de
la izquierda es verdadero; para el operador lógico OR, si y solo si el operando izquierdo es falso evaluará el operando
derecho. La naturaleza de la evaluación de cortocircuito hace que no se ejecute todo el código de la expresión lógica.}

\subsubsection[3.2.4 Operador bit a bit]{\selectlanguage{spanish} 3.2.4 Operador bit a bit}
\hypertarget{RefHeadingToc355613639824055}{}{\selectlanguage{spanish}
Los operadores de bits pueden implementar algunas operaciones de bits binarios, y las operaciones de bits solo se pueden
usar en tipos enteros. La información detallada de los operadores de bit se muestra en la Tabla 6 . La operación de
bits se refiere a la operación de bits binarios directamente en números enteros. Las operaciones lógicas se pueden
extender a operaciones de bits. Tomando AND lógico como ejemplo, podemos realizar esta operación en cada bit binario
para lograr AND bit a bit, como \$110\_b{\textbackslash} \{{\textbackslash}rm AND\}{\textbackslash} 011\_b = 010\_b\$.
Las operaciones de bits también admiten operaciones de cambio, que mueven números de forma binaria.}


\bigskip

\begin{center}
\tablefirsthead{\centering{\selectlanguage{spanish}\bfseries Operador} &
~
 &
\centering\arraybslash{\selectlanguage{spanish}\bfseries Ejemplo}\\}
\tablehead{\centering{\selectlanguage{spanish}\bfseries Operador} &
~
 &
\centering\arraybslash{\selectlanguage{spanish}\bfseries Ejemplo}\\}
\tabletail{}
\tablelasttail{}
\begin{supertabular}{m{3.555cm}m{6.658cm}m{5.1080003cm}}
\centering \textstyleSourceText{\foreignlanguage{spanish}{\~{}}} &
{\selectlanguage{spanish} Negar} &
\centering\arraybslash \textstyleSourceText{\foreignlanguage{spanish}{\~{}expr}}\\
\centering \textstyleSourceText{\foreignlanguage{spanish}{\&}} &
{\selectlanguage{spanish} Bit a bit y} &
\centering\arraybslash \textstyleSourceText{\foreignlanguage{spanish}{expr \& expr}}\\
\centering \textstyleSourceText{\foreignlanguage{spanish}{{\textbar}}} &
{\selectlanguage{spanish} Bit a bit o} &
\centering\arraybslash \textstyleSourceText{\foreignlanguage{spanish}{expr{\textbar} expr}}\\
\centering \textstyleSourceText{\foreignlanguage{spanish}{\^{}}} &
{\selectlanguage{spanish} O exclusivo bit a bit} &
\centering\arraybslash \textstyleSourceText{\foreignlanguage{spanish}{expr\^{}expr}}\\
\centering \textstyleSourceText{\foreignlanguage{spanish}{{\textless}{\textless}}} &
{\selectlanguage{spanish} Desplazar a la izquierda} &
\centering\arraybslash \textstyleSourceText{\foreignlanguage{spanish}{expr {\textless}{\textless} expr}}\\
\centering \textstyleSourceText{\foreignlanguage{spanish}{{\textgreater}{\textgreater}}} &
{\selectlanguage{spanish} Desplazar a la derecha} &
\centering\arraybslash \textstyleSourceText{\foreignlanguage{spanish}{expr {\textgreater}{\textgreater} expr}}\\
\end{supertabular}
\end{center}
{\selectlanguage{spanish}\itshape
Tabla 6: Operador bit a bit}


\bigskip

\foreignlanguage{spanish}{Aunque solo se puede usar para números enteros, las operaciones con bits siguen siendo
versátiles. Las operaciones de bits pueden implementar muchas técnicas de optimización. En muchos algoritmos, el uso de
operaciones de bits puede ahorrar mucho código. Por ejemplo, para determinar si un número
}\textstyleSourceText{\foreignlanguage{spanish}{n}}\foreignlanguage{spanish}{ es una potencia de 2, podemos juzgar si
el resultado de }\textstyleSourceText{\foreignlanguage{spanish}{n \& (n - 1)}}\foreignlanguage{spanish}{ es
}\textstyleSourceText{\foreignlanguage{spanish}{0}}\foreignlanguage{spanish}{. En algunos lenguajes con alta eficiencia
de ejecución, las operaciones de cambio también se pueden usar para optimizar la multiplicación y la división (por lo
general, no hay un efecto obvio en los lenguajes de secuencias de comandos).}

\foreignlanguage{spanish}{El operador AND bit a bit
{\textquotedbl}}\textstyleSourceText{\foreignlanguage{spanish}{\&}}\foreignlanguage{spanish}{{\textquotedbl} es un
operador binario, que realiza la operación AND binaria de dos operandos enteros: solo cuando los bits binarios
correspondientes a los operandos son todos
}\textstyleSourceText{\foreignlanguage{spanish}{1}}\foreignlanguage{spanish}{, el resultado es
}\textstyleSourceText{\foreignlanguage{spanish}{1}}\foreignlanguage{spanish}{. Por ejemplo, 1110
}\foreignlanguage{spanish}{\textit{b}}\foreignlanguage{spanish}{ \& 0111
}\foreignlanguage{spanish}{\textit{b}}\foreignlanguage{spanish}{ = 0110
}\foreignlanguage{spanish}{\textit{b}}\foreignlanguage{spanish}{ .}

\foreignlanguage{spanish}{El operador OR bit a bit
{\textquotedbl}}\textstyleSourceText{\foreignlanguage{spanish}{{\textbar}}}\foreignlanguage{spanish}{{\textquotedbl} es
un operador binario, que realiza una operación OR de bits binarios en dos operandos enteros: solo cuando los bits
binarios correspondientes a los operandos son ambos
}\textstyleSourceText{\foreignlanguage{spanish}{0}}\foreignlanguage{spanish}{, el bit del resultado es
}\textstyleSourceText{\foreignlanguage{spanish}{\ 0}}\foreignlanguage{spanish}{. Por ejemplo, 1000
}\foreignlanguage{spanish}{\textit{b}}\foreignlanguage{spanish}{ {\textbar} 0001
}\foreignlanguage{spanish}{\textit{b}}\foreignlanguage{spanish}{ = 1001
}\foreignlanguage{spanish}{\textit{b}}\foreignlanguage{spanish}{ .}

\foreignlanguage{spanish}{El operador OR exclusivo bit a bit
``}\textstyleSourceText{\foreignlanguage{spanish}{\^{}}}\foreignlanguage{spanish}{{}'' es un operador binario, que
realiza una operación OR exclusiva binaria en dos operandos enteros: cuando los bits binarios correspondientes a los
operandos son diferentes, el valor de bit del resultado es
}\textstyleSourceText{\foreignlanguage{spanish}{1}}\foreignlanguage{spanish}{. Por ejemplo, \$1100\_b{\textbackslash}
{\textbackslash}hat\{\}{\textbackslash} 0101\_b = 1001\_b\$.}

\foreignlanguage{spanish}{El operador de desplazamiento a la izquierda
``}\textstyleSourceText{\foreignlanguage{spanish}{{\textless}{\textless}}}\foreignlanguage{spanish}{{}'' es un operador
binario, que mueve el operando izquierdo hacia la izquierda el número de bits especificado por el operando derecho
sobre una base binaria. Por ejemplo, 00001010 }\foreignlanguage{spanish}{\textit{b}}\foreignlanguage{spanish}{ ${\ll}$
3 = 01010000 }\foreignlanguage{spanish}{\textit{b}}\foreignlanguage{spanish}{ . El operador de desplazamiento a la
derecha ``}\textstyleSourceText{\foreignlanguage{spanish}{{\textgreater}{\textgreater}}}\foreignlanguage{spanish}{{}''
es un operador binario, que desplaza el operando izquierdo hacia la derecha el número de bits especificado por el
operando derecho en un binario. base. Por ejemplo, 10100000
}\foreignlanguage{spanish}{\textit{b}}\foreignlanguage{spanish}{ ${\gg}$ 3 = 00010100
}\foreignlanguage{spanish}{\textit{b}}\foreignlanguage{spanish}{ .}

\foreignlanguage{spanish}{El operador de inversión bit a bit ``\~{}'' es un operador unario, y el resultado de la
expresión es invertir el valor de cada bit binario del operando. Por ejemplo,
}\textstyleSourceText{\foreignlanguage{spanish}{${\sim}$}}\foreignlanguage{spanish}{10100011
}\foreignlanguage{spanish}{\textit{b}}\foreignlanguage{spanish}{ = 01011100
}\foreignlanguage{spanish}{\textit{b}}\foreignlanguage{spanish}{ .}

{\selectlanguage{spanish}
Los siguientes son algunos ejemplos del uso de operaciones con bits. Por lo general, no usamos binario directamente. Los
resultados de los ejemplos se han convertido en bases comunes.}


\bigskip

{\selectlanguage{spanish}\ttfamily
1 {\textless}{\textless} 1 \# 2}

{\selectlanguage{spanish}\ttfamily
168 {\textgreater}{\textgreater} 4 \# 10}

{\selectlanguage{spanish}\ttfamily
456 \& 127 \# 72}

{\selectlanguage{spanish}\ttfamily
456 {\textbar} 127 \# 511}

{\selectlanguage{spanish}\ttfamily
0xA5 \^{} 0x5A \# 255}

{\selectlanguage{spanish}\ttfamily
\~{}2 \# -3}

\subsubsection[3.2.5 Operador de asignación]{\selectlanguage{spanish} 3.2.5 Operador de asignación}
\hypertarget{RefHeadingToc355633639824055}{}{\selectlanguage{spanish}
El operador de asignación solo aparece en la expresión de asignación y el operando del operador debe ser un objeto de
escritura. La expresión de asignación no tiene resultado, por lo que no se pueden utilizar operaciones de asignación
continua.}

\paragraph[Operador de asignación simple]{\selectlanguage{spanish} Operador de asignación simple}
\hypertarget{RefHeadingToc355653639824055}{}\foreignlanguage{spanish}{El operador de asignación simple
}\textstyleSourceText{\foreignlanguage{spanish}{=}}\foreignlanguage{spanish}{ se puede utilizar para la asignación de
variables. Si la }\foreignlanguage{spanish}{variable de operando de la izquierda no está definida, se definirá la
variable. El operador de asignación se utiliza para vincular el valor del operando derecho con el operando izquierdo.
Este proceso también se llama {\textquotedbl}asignación{\textquotedbl}. Por lo tanto, el operando izquierdo no puede
ser una constante, ni puede ser ningún objeto que no se pueda escribir. Estas son algunas expresiones legales de
asignación:}


\bigskip

{\selectlanguage{spanish}\ttfamily
a = 45 b ='string' c = 0}


\bigskip

{\selectlanguage{spanish}
Y la siguiente expresión de asignación es incorrecta:}


\bigskip

{\selectlanguage{spanish}\ttfamily
1 = 5 \# Tratando de asignar una constante 1}

{\selectlanguage{spanish}\ttfamily
a = b = 0 \# \ Asignación continua}


\bigskip

\foreignlanguage{spanish}{Al asignar tipos
}\textstyleSourceText{\foreignlanguage{spanish}{nil}}\foreignlanguage{spanish}{, enteros, reales y booleanos a
variables, el valor del objeto se pasará al operando izquierdo, pero para otros tipos, la operación de asignación
simplemente pasa la referencia del objeto al operando izquierdo. Dado que las cadenas, las funciones y los tipos de
clase son de solo lectura, todas las referencias que pasan no tendrán efectos secundarios, pero debe tener mucho
cuidado con los tipos de instancia.}

\paragraph[Operador de asignación compuesto]{\selectlanguage{spanish} Operador de asignación compuesto}
\hypertarget{RefHeadingToc355673639824055}{}{\selectlanguage{spanish}
Los operadores de asignación compuestos son operadores que combinan operadores binarios y operadores de asignación. Son
extensiones prácticas de operadores de asignación simples. Los operadores de asignación compuestos pueden simplificar
la escritura de algunas expresiones. La Tabla 7 enumera todos los operadores de asignación compuestos}


\bigskip

\begin{center}
\tablefirsthead{\centering{\selectlanguage{spanish}\bfseries Operador} &
{\selectlanguage{spanish}\bfseries Descripción}\\}
\tablehead{\centering{\selectlanguage{spanish}\bfseries Operador} &
{\selectlanguage{spanish}\bfseries Descripción}\\}
\tabletail{}
\tablelasttail{}
\begin{supertabular}{m{3.756cm}m{11.764cm}}
\centering \textstyleSourceText{\foreignlanguage{spanish}{+=}} &
{\selectlanguage{spanish} Asignación de adición}\\
\centering \textstyleSourceText{\foreignlanguage{spanish}{{}-=}} &
{\selectlanguage{spanish} Asignación de resta}\\
\centering \textstyleSourceText{\foreignlanguage{spanish}{*=}} &
{\selectlanguage{spanish} Asignación de multiplicación}\\
\centering \textstyleSourceText{\foreignlanguage{spanish}{/=}} &
{\selectlanguage{spanish} Asignación de división}\\
\centering \textstyleSourceText{\foreignlanguage{spanish}{\%=}} &
{\selectlanguage{spanish} Asignación de resto}\\
\centering \textstyleSourceText{\foreignlanguage{spanish}{\&=}} &
{\selectlanguage{spanish} Asignación AND bit a bit}\\
\centering \textstyleSourceText{\foreignlanguage{spanish}{{\textbar}=}} &
{\selectlanguage{spanish} Asignación OR bit a bit}\\
\centering \textstyleSourceText{\foreignlanguage{spanish}{\^{}=}} &
{\selectlanguage{spanish} Asignación XOR bit a bit}\\
\centering \textstyleSourceText{\foreignlanguage{spanish}{{\textless}{\textless}=}} &
{\selectlanguage{spanish} Asignación de desplazamiento a la izquierda}\\
\centering \textstyleSourceText{\foreignlanguage{spanish}{{\textgreater}{\textgreater}=}} &
{\selectlanguage{spanish} Asignación de desplazamiento a la derecha}\\
\end{supertabular}
\end{center}
{\selectlanguage{spanish}\itshape
Tabla 7: Operador de bits}


\bigskip

\foreignlanguage{spanish}{La expresión de asignación compuesta realiza la operación binaria correspondiente al operador
de asignación compuesta en el operando izquierdo y el operando derecho, y luego asigna el resultado al operando
izquierdo. Tomando }\textstyleSourceText{\foreignlanguage{spanish}{+=}}\foreignlanguage{spanish}{ como ejemplo, la
expresión }\textstyleSourceText{\foreignlanguage{spanish}{a += b}}\foreignlanguage{spanish}{ es equivalente a
}\textstyleSourceText{\foreignlanguage{spanish}{a = a + b}}\foreignlanguage{spanish}{. El operador de asignación
compuesto también es un operador de asignación, por lo que tiene una prioridad más baja. El operador binario
correspondiente al operador de asignación compuesto siempre se evalúa después del operando derecho, por lo que una
expresión como }\textstyleSourceText{\foreignlanguage{spanish}{a *= 1 + 2}}\foreignlanguage{spanish}{ debería ser
equivalente a }\textstyleSourceText{\foreignlanguage{spanish}{a = a * (1 + 2)}}\foreignlanguage{spanish}{.}

{\selectlanguage{spanish}
A diferencia del operador de asignación simple, el operando izquierdo del operador de asignación compuesto debe
participar en la evaluación, por lo que la expresión de asignación compuesta no tiene la función de definir variables.
El operador de asignación en sí no se puede sobrecargar en la clase. Los usuarios solo pueden sobrecargar el operador
binario correspondiente al operador de asignación compuesto. Esto también asegura que el operador de asignación
compuesto siempre se ajustará a las características básicas de las operaciones de asignación.}

\subsubsection{3.2.6 Operador de dominio y operador de subíndice}
\hypertarget{RefHeadingToc355693639824055}{}\foreignlanguage{spanish}{El operador de dominio
}\textstyleSourceText{\foreignlanguage{spanish}{.}}\foreignlanguage{spanish}{ se utiliza para acceder a un atributo o
miembro de un objeto. Puede utilizar operadores de dominio para ambos tipos de módulos e instancias:}


\bigskip

{\selectlanguage{spanish}\ttfamily
l = list[]}

{\selectlanguage{spanish}\ttfamily
l.push('item 0')}

{\selectlanguage{spanish}\ttfamily
s = l.item(0) \# 'item 0'}


\bigskip

\foreignlanguage{spanish}{El operador de subíndice
}\textstyleSourceText{\foreignlanguage{spanish}{[]}}\foreignlanguage{spanish}{ se utiliza para acceder a los elementos
de un objeto, por ejemplo}


\bigskip

{\selectlanguage{spanish}\ttfamily
l[2] = 10 \# Leido por índice}

{\selectlanguage{spanish}\ttfamily
n = l[2] \# Escrito por índice}


\bigskip

\foreignlanguage{spanish}{Las clases que admiten la lectura de subíndices deben implementar el método
}\textstyleSourceText{\foreignlanguage{spanish}{item}}\foreignlanguage{spanish}{ y las clases que admiten la escritura
de subíndices deben implementar el método
}\textstyleSourceText{\foreignlanguage{spanish}{setitem}}\foreignlanguage{spanish}{. El mapa y la lista en el
contenedor estándar implementan estos dos métodos, por lo que admiten la lectura y escritura mediante el operador de
subíndice. La cadena admite la lectura de subíndices, pero no admite la escritura de subíndices (las cadenas son
valores de solo lectura):}


\bigskip

{\selectlanguage{spanish}\ttfamily
{}'string'[2] \#'r'}

{\selectlanguage{spanish}\ttfamily
{}'string'[2] ='a' \# error: \ valor 'string' no admite asignación de índice}


\bigskip

{\selectlanguage{spanish}
Actualmente, las cadenas admiten subíndices enteros y el rango de subíndices no puede exceder la longitud de la cadena.}

\subsubsection[3.2.7 Operador condicional]{\selectlanguage{spanish} 3.2.7 Operador condicional}
\hypertarget{RefHeadingToc355713639824055}{}\foreignlanguage{spanish}{El operador condicional
(}\textstyleSourceText{\foreignlanguage{spanish}{? :}}\foreignlanguage{spanish}{) es similar a la declaración
}\foreignlanguage{spanish}{\textbf{if else}}\foreignlanguage{spanish}{, pero la primera puede usarse en expresiones. La
forma de uso del operador condicional es: \$\${\textbackslash}begin\{gathered\} cond{\textbackslash}
{\textbackslash}bm\{?\}{\textbackslash} expr1{\textbackslash} {\textbackslash}bm\{:\}{\textbackslash}
expr2{\textbackslash}end\{gathered\}\$\$}

{\selectlanguage{spanish}
\textbf{\textit{cond}} es la expresión utilizada para juzgar la condición. El proceso de evaluación del operador
condicional es: primero encuentra el valor de \textbf{\textit{cond}}, si la condición es verdadera, evalúa
\textbf{\textit{expr1}} y devuelve el valor, de lo contrario, el valor de \textit{**expr2 **} ] Evalúa y devuelve el
valor. \textbf{\textit{expr1}} y \textbf{\textit{expr2}} pueden tener diferentes tipos, por lo que lo siguiente es
correcto:}

{\selectlanguage{spanish}\ttfamily
resultado = alcance {\textless} 6 ? 'malo' : alcance}

\foreignlanguage{spanish}{Esta expresión primero determina si
}\textstyleSourceText{\foreignlanguage{spanish}{alcance}}\foreignlanguage{spanish}{ es menor que
}\textstyleSourceText{\foreignlanguage{spanish}{6}}\foreignlanguage{spanish}{, si lo es, devuelve
}\textstyleSourceText{\foreignlanguage{spanish}{malo}}\foreignlanguage{spanish}{, de lo contrario, devuelve el valor de
}\textstyleSourceText{\foreignlanguage{spanish}{alcance}}\foreignlanguage{spanish}{. Independientemente de la condición
de la expresión }\foreignlanguage{spanish}{condicional, solo se ejecutará uno de
}\foreignlanguage{spanish}{\textbf{\textit{expr1}}}\foreignlanguage{spanish}{ o
}\foreignlanguage{spanish}{\textbf{\textit{expr2}}}\foreignlanguage{spanish}{, similar a la característica de
cortocircuito de las operaciones lógicas AND y lógicas OR.}

\paragraph[Operadores de condiciones anidadas]{\selectlanguage{spanish} Operadores de condiciones anidadas}
\hypertarget{RefHeadingToc355733639824055}{}{\selectlanguage{spanish}
Un operador condicional se puede anidar en otro operador condicional, es decir, la expresión condicional se puede usar
como \textbf{\textit{cond}} o \textbf{\textit{expr}} de otra expresión condicional. Por ejemplo, use expresiones
condicionales para dividir puntajes en tres niveles: excelente, bueno y malo:}


\bigskip

{\selectlanguage{spanish}\ttfamily
resultado = alcance {\textgreater}= 9 ? 'excelente' : alcance {\textgreater}= 6 ? 'bueno' : 'malo'}


\bigskip

\foreignlanguage{spanish}{La primera condición comprueba si la puntuación no es inferior a
}\textstyleSourceText{\foreignlanguage{spanish}{9}}\foreignlanguage{spanish}{ puntos. Si es así, ejecute la rama
después de }\textstyleSourceText{\foreignlanguage{spanish}{?}}\foreignlanguage{spanish}{ y devuelva
}\textstyleSourceText{\foreignlanguage{spanish}{{}'excelente'}}\foreignlanguage{spanish}{; de lo contrario, ejecute la
rama después de }\textstyleSourceText{\foreignlanguage{spanish}{:}}\foreignlanguage{spanish}{, que también es una
expresión condicional. La condición comprueba si la puntuación no es inferior a
}\textstyleSourceText{\foreignlanguage{spanish}{6}}\foreignlanguage{spanish}{, si lo es, devuelve
}\textstyleSourceText{\foreignlanguage{spanish}{{}'bueno'}}\foreignlanguage{spanish}{, de lo contrario, devuelve
}\textstyleSourceText{\foreignlanguage{spanish}{{}'malo'}}\foreignlanguage{spanish}{.}

{\selectlanguage{spanish}
El operador condicional satisface la asociatividad correcta, por lo que el valor de la expresión de bifurcación debe
evaluarse primero para obtener el valor de la expresión condicional. Por lo tanto, en una expresión condicional
anidada, la expresión condicional anidada se evalúa primero y luego se evalúa la expresión condicional externa.}

\paragraph[Prioridad de los operadores condicionales]{\selectlanguage{spanish} Prioridad de los operadores
condicionales}
\hypertarget{RefHeadingToc355753639824055}{}{\selectlanguage{spanish}
Dado que la precedencia de las expresiones condicionales es muy baja (sólo superada por los operadores de asignación), a
menudo es necesario agregar paréntesis fuera de las expresiones condicionales. Por ejemplo, cuando se usa una expresión
condicional como operando de una expresión aritmética, los paréntesis tendrán diferentes efectos en el resultado:}


\bigskip

{\selectlanguage{spanish}\ttfamily
resultado = 10 * (signo {\textless} 0 ? -1 : 1) \# el resultado es -10 ó 10}

{\selectlanguage{spanish}\ttfamily
resultado = 10 * signo {\textless} 0 ? -1 : 1 \# el resultado es -1 ó 1}


\bigskip

\foreignlanguage{spanish}{El resultado de la primera expresión es correcto, y la segunda expresión toma
}\textstyleSourceText{\foreignlanguage{spanish}{10 * signo {\textless} 0}}\foreignlanguage{spanish}{ como condición a
juzgar, lo que no cumple con la expectativa de la expresión condicional como el operando derecho de la multiplicación.}

\subsubsection[3.2.8 Operador de concatenación]{\foreignlanguage{spanish}{3.2.8 }\foreignlanguage{spanish}{Operador de
concatenación}}
\hypertarget{RefHeadingToc355773639824055}{}\paragraph[Operador +]{\foreignlanguage{spanish}{Operador
}\textstyleSourceText{\foreignlanguage{spanish}{+}}}
\hypertarget{RefHeadingToc355793639824055}{}\foreignlanguage{spanish}{Cuando los operandos izquierdo y derecho son
cadenas, el operador }\textstyleSourceText{\foreignlanguage{spanish}{+}}\foreignlanguage{spanish}{ se usa para conectar
las dos cadenas, y la nueva cadena obtenida es el valor de la expresión. Por lo tanto, este operador se usa a menudo
para la concatenación de cadenas:}


\bigskip

{\selectlanguage{spanish}\ttfamily
resultado ='abc' + '123' \# el resultado es 'abc123'}


\bigskip

\foreignlanguage{spanish}{Los operadores }\textstyleSourceText{\foreignlanguage{spanish}{+}}\foreignlanguage{spanish}{
también se pueden usar para conectar dos instancias de lista:}


\bigskip

{\selectlanguage{spanish}\ttfamily
resultado = [1, 2] + [3, 4] \# el resultado es [1, 2, 3, 4]}


\bigskip

\foreignlanguage{spanish}{A diferencia del método
}\textstyleSourceText{\foreignlanguage{spanish}{list.push}}\foreignlanguage{spanish}{, el operador
}\textstyleSourceText{\foreignlanguage{spanish}{+}}\foreignlanguage{spanish}{ fusiona dos listas en un objeto de lista
más grande, con los elementos del operando izquierdo al principio de la lista de resultados y los elementos del
operando derecho al final de la lista de resultados}

\paragraph[Operador ..]{\foreignlanguage{spanish}{Operador }\textstyleSourceText{\foreignlanguage{spanish}{..}}}
\hypertarget{RefHeadingToc355813639824055}{}\textstyleSourceText{\foreignlanguage{spanish}{..}}\foreignlanguage{spanish}{
es un operador especial. Si el operando izquierdo es una cadena, el comportamiento de la expresión es concatenar los
operandos izquierdo y derecho en una nueva cadena (conversión automática si el operando derecho no es una cadena):}

{\selectlanguage{spanish}\ttfamily
resultado ='abc' + 123 \# el resultado es 'abc123'}

\foreignlanguage{spanish}{El operador }\textstyleSourceText{\foreignlanguage{spanish}{..}}\foreignlanguage{spanish}{ se
usa a menudo cuando se concatena una cadena y un valor que no es una cadena. Si el operando izquierdo es una instancia
de lista, el operador }\textstyleSourceText{\foreignlanguage{spanish}{..}}\foreignlanguage{spanish}{ agregará el
operando derecho al final de la lista y luego usará esta lista como el valor de la expresión:}


\bigskip

{\selectlanguage{spanish}\ttfamily
resultado ='abc' + 123 \# el resultado es 'abc123'}


\bigskip

\foreignlanguage{spanish}{Este proceso modificará directamente el operando izquierdo, que es muy similar al método
}\textstyleSourceText{\foreignlanguage{spanish}{push}}\foreignlanguage{spanish}{ de
}\textstyleSourceText{\foreignlanguage{spanish}{list}}\foreignlanguage{spanish}{ (excepto las cadenas que son objetos
inmutables). La operación de unión de la lista se puede ejecutar en cadena:}


\bigskip

{\selectlanguage{spanish}\ttfamily
resultado = [1, 2] .. 3 .. 4 \# el resultado es [1, 2, 3, 4]}


\bigskip

{\selectlanguage{spanish}
Todos los valores en este proceso se agregarán al objeto de lista más a la izquierda.}

\foreignlanguage{spanish}{Si los operandos izquierdo y derecho son enteros, utilice el operador
}\textstyleSourceText{\foreignlanguage{spanish}{..}}\foreignlanguage{spanish}{ para obtener un objeto de rango de
enteros:}


\bigskip

{\selectlanguage{spanish}\ttfamily
resultado = 1 .. 10 \# el resultado es (1..10)}


\bigskip

{\selectlanguage{spanish}
Este objeto se utiliza para representar un intervalo cerrado de enteros, donde el operando izquierdo es el límite
inferior y el operando derecho es el límite superior. Dichos objetos de rango de enteros se utilizan a menudo para la
iteración.}

\clearpage\section{Capítulo 4: Declaración}
\hypertarget{RefHeadingToc355833639824055}{}
\bigskip

{\selectlanguage{spanish}
Berry es un lenguaje de programación imperativo. Este paradigma asume que los programas se ejecutan paso a paso.
Normalmente, las declaraciones de Berry se ejecutan secuencialmente, y esta estructura de programa se denomina
estructura secuencial. Aunque la estructura de la secuencia es muy básica, las estructuras de rama y las estructuras de
bucle se utilizan normalmente en los programas reales. Berry proporciona varias declaraciones de control para realizar
esta compleja estructura de flujo, como declaraciones condicionales y declaraciones de iteración.}

\foreignlanguage{spanish}{A excepción de los comentarios de línea, los retornos de carro o los saltos de línea
({\textquotedbl}}\textstyleSourceText{\foreignlanguage{spanish}{{\textbackslash}r}}\foreignlanguage{spanish}{{\textquotedbl}
y
{\textquotedbl}}\textstyleSourceText{\foreignlanguage{spanish}{{\textbackslash}n}}\foreignlanguage{spanish}{{\textquotedbl})
solo se usan como caracteres en blanco, por lo que las declaraciones se pueden escribir en líneas. Además, puede
escribir varias declaraciones en la misma línea.}

{\selectlanguage{spanish}
Puede agregar un punto y coma al final de la declaración para indicar el final de la declaración, pero el intérprete
generalmente puede dividir la declaración automáticamente sin usar un punto y coma. Puede usar punto y coma para
decirle al intérprete cómo analizar el código para el código que será ambiguo. Sin embargo, es mejor no escribir código
ambiguo.}

\subsection[4.1 Sentencia simple]{\selectlanguage{spanish} 4.1 Sentencia simple}
\hypertarget{RefHeadingToc355853639824055}{}\subsubsection[4.1.1 Declaración de expresión]{\selectlanguage{spanish}
4.1.1 Declaración de expresión}
\hypertarget{RefHeadingToc355873639824055}{}\foreignlanguage{spanish}{Las declaraciones de expresión son principalmente
declaraciones compuestas de expresiones de asignación o expresiones de llamada de función. Otras expresiones también
pueden formar Sentencias, pero no tienen significado. Por ejemplo, la expresión
}\textstyleSourceText{\foreignlanguage{spanish}{1+2}}\foreignlanguage{spanish}{ es una Sentencia escrita sola, pero no
tiene ningún efecto. Las siguientes rutinas dan ejemplos de sentencias de expresión y sentencias de función:}


\bigskip

{\selectlanguage{spanish}\ttfamily
a = 1 \# \ Declaración de asignación}

{\selectlanguage{spanish}\ttfamily
print(a) \# \ Declaración de llamada}


\bigskip

\foreignlanguage{spanish}{La línea 1 es una declaración de asignación simple que asigna el valor literal
}\textstyleSourceText{\foreignlanguage{spanish}{i}}\foreignlanguage{spanish}{ a la variable
}\textstyleSourceText{\foreignlanguage{spanish}{a}}\foreignlanguage{spanish}{. La declaración en la línea 2 es una
declaración de llamada de función, que imprime el valor de la variable 'a' llamando a la función 'imprimir'.}

{\selectlanguage{spanish}
Las expresiones de líneas cruzadas se escriben de la misma manera que las expresiones de una sola línea y no se
requieren símbolos especiales de continuación de línea. P.ej:}


\bigskip

{\selectlanguage{spanish}\ttfamily
a = 1 +}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ func() \# Ajustar línea}


\bigskip

{\selectlanguage{spanish}
También puede escribir varias declaraciones de expresión en una línea y varios tipos de declaraciones se pueden escribir
en una línea. Este ejemplo pone dos declaraciones de expresión en la misma línea:}


\bigskip

{\selectlanguage{spanish}\ttfamily
b = 1 c = 2 \# \ sentencias múltiples}


\bigskip

{\selectlanguage{spanish}
A veces el programador quiere escribir dos declaraciones, pero el intérprete puede pensar erróneamente que es una
declaración. Este problema es causado por la ambigüedad en el proceso de análisis gramatical. Tome este código como
ejemplo:}


\bigskip

{\selectlanguage{spanish}\ttfamily
a = c}

{\selectlanguage{spanish}\ttfamily
(b) = 1 \# \ Considérese como una llamada de función}


\bigskip

\foreignlanguage{spanish}{Supongamos que las líneas 1 y 2 están destinadas a ser dos Sentencias de expresión:
}\textstyleSourceText{\foreignlanguage{spanish}{a = c}}\foreignlanguage{spanish}{ y
}\textstyleSourceText{\foreignlanguage{spanish}{(b) = 1}}\foreignlanguage{spanish}{, pero el intérprete las
interpretará como una Sentencia: }\textstyleSourceText{\foreignlanguage{spanish}{a = c(b) =
1}}\foreignlanguage{spanish}{. La causa de este problema es que el intérprete analiza incorrectamente
}\textstyleSourceText{\foreignlanguage{spanish}{c}}\foreignlanguage{spanish}{ y
}\textstyleSourceText{\foreignlanguage{spanish}{(b)}}\foreignlanguage{spanish}{ en llamadas de función. Para evitar
ambigüedades, podemos agregar un punto y coma al final de la declaración para separar claramente la declaración:}


\bigskip

{\selectlanguage{spanish}\ttfamily
a = c; (b) = 1;}


\bigskip

{\selectlanguage{spanish}
Una mejor manera es no usar paréntesis en el lado izquierdo del número de tarea. Obviamente, no hay razón para usar
paréntesis aquí. En circunstancias normales, las expresiones complejas no deberían aparecer en el lado izquierdo del
operador de asignación, sino solo expresiones simples compuestas de nombres de variables, expresiones de operación de
dominio y expresiones de operación de subíndice:}


\bigskip

{\selectlanguage{spanish}\ttfamily
a = c b = 1}


\bigskip

{\selectlanguage{spanish}
Usar expresiones simples solo en el lado izquierdo del signo de asignación no causará ambigüedad en la segmentación de
Sentencias. Por lo tanto, en la mayoría de los casos, no es necesario usar punto y coma para separar expresiones y no
recomendamos esta forma de escritura.}

\subsubsection[4.1.2 Bloque]{\selectlanguage{spanish} 4.1.2 Bloque}
\hypertarget{RefHeadingToc355893639824055}{}\foreignlanguage{spanish}{Un
}\foreignlanguage{spanish}{\textbf{Bloque}}\foreignlanguage{spanish}{ es una colección de varias Sentencias. Un bloque
es un alcance, por lo que solo se puede acceder a las variables definidas en el bloque dentro del bloque y sus
sub-bloques. Hay muchos lugares donde se utilizan bloques, como declaraciones
}\textstyleSourceText{\foreignlanguage{spanish}{if}}\foreignlanguage{spanish}{, declaraciones
}\textstyleSourceText{\foreignlanguage{spanish}{while}}\foreignlanguage{spanish}{, declaraciones de funciones, etc.
Estas declaraciones contendrán un bloque a través de un par de palabras clave. Por ejemplo, el bloque utilizado en la
sentencia }\textstyleSourceText{\foreignlanguage{spanish}{if}}\foreignlanguage{spanish}{:}


\bigskip

{\selectlanguage{spanish}\ttfamily
if isOpen}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ close()}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ print('el dispositivo fue cerrado')}

{\selectlanguage{spanish}\ttfamily
end}


\bigskip

\foreignlanguage{spanish}{Las sentencias en las líneas 2 a 3 constituyen un bloque, que se intercala entre el par de
palabras clave }\textstyleSourceText{\foreignlanguage{spanish}{if}}\foreignlanguage{spanish}{ y
}\textstyleSourceText{\foreignlanguage{spanish}{end}}\foreignlanguage{spanish}{ (la expresión condicional de la
sentencia en }\textstyleSourceText{\foreignlanguage{spanish}{if}}\foreignlanguage{spanish}{ no está en el bloque). No
es necesario que el bloque contenga declaraciones, lo que constituye un bloque vacío, o se puede decir que es un bloque
que contiene una declaración vacía. En términos generales, cualquier cantidad de Sentencias consecutivas puede llamarse
bloque, pero preferimos }\foreignlanguage{spanish}{expandir el alcance del bloque tanto como sea posible, lo que puede
garantizar que el área del bloque sea consistente con el alcance del alcance. En el ejemplo anterior, tendemos a pensar
que las filas 2 a 3 son un bloque completo, que es el rango más grande entre las palabras clave
}\textstyleSourceText{\foreignlanguage{spanish}{if}}\foreignlanguage{spanish}{ y
}\textstyleSourceText{\foreignlanguage{spanish}{end}}\foreignlanguage{spanish}{.}

\paragraph[Declaración do]{\foreignlanguage{spanish}{Declaración }\textstyleSourceText{\foreignlanguage{spanish}{do}}}
\hypertarget{RefHeadingToc355913639824055}{}\foreignlanguage{spanish}{A veces solo queremos abrir un nuevo ámbito, pero
no queremos usar ninguna declaración de control. En este caso, podemos usar la instrucción
}\textstyleSourceText{\foreignlanguage{spanish}{do}}\foreignlanguage{spanish}{ para encapsular el bloque, entonces la
sentencia no tiene función de control. La Sentencia tiene la forma:}

\textstyleSourceText{\foreignlanguage{spanish}{do}}\foreignlanguage{spanish}{
}\foreignlanguage{spanish}{\textbf{bloque}}\foreignlanguage{spanish}{
}\textstyleSourceText{\foreignlanguage{spanish}{end}}

\foreignlanguage{spanish}{Entre ellos }\foreignlanguage{spanish}{\textbf{bloque}}\foreignlanguage{spanish}{ está el
bloque que necesitamos. Esta instrucción utiliza un par de palabras clave
}\textstyleSourceText{\foreignlanguage{spanish}{do}}\foreignlanguage{spanish}{ y
}\textstyleSourceText{\foreignlanguage{spanish}{end}}\foreignlanguage{spanish}{ para contener bloques. La declaración
no tiene función de control, ni genera ninguna instrucción de tiempo de ejecución.}

\subsection[4.2 Sentencia condicional]{\selectlanguage{spanish} 4.2 Sentencia condicional}
\hypertarget{RefHeadingToc355933639824055}{}\foreignlanguage{spanish}{Berry proporciona sentencias
}\textstyleSourceText{\foreignlanguage{spanish}{if}}\foreignlanguage{spanish}{ para realizar la función de ejecución de
control condicional. Este tipo de estructura de programa generalmente se denomina estructura de rama
}\textstyleSourceText{\foreignlanguage{spanish}{if}}\foreignlanguage{spanish}{. La declaración determinará la rama de
ejecución basada en la expresión condicional verdadera
(}\textstyleSourceText{\foreignlanguage{spanish}{true}}\foreignlanguage{spanish}{) o falsa
(}\textstyleSourceText{\foreignlanguage{spanish}{false}}\foreignlanguage{spanish}{). En algunos lenguajes, existen
otras opciones para implementar el control condicional. Por ejemplo, los lenguajes como C y C++ proporcionan sentencias
}\textstyleSourceText{\foreignlanguage{spanish}{switch}}\foreignlanguage{spanish}{, pero para simplificar el diseño,
Berry no admite sentencias }\textstyleSourceText{\foreignlanguage{spanish}{switch}}\foreignlanguage{spanish}{.}

\subsubsection[4.2.1 Declaración if]{\foreignlanguage{spanish}{4.2.1 }\foreignlanguage{spanish}{Declaración
}\textstyleSourceText{\foreignlanguage{spanish}{if}}}
\hypertarget{RefHeadingToc355953639824055}{}\foreignlanguage{spanish}{La instrucción
}\textstyleSourceText{\foreignlanguage{spanish}{if}}\foreignlanguage{spanish}{ se utiliza para implementar la
estructura de rama, que selecciona la rama del programa de acuerdo con el verdadero o falso de una determinada
condición de juicio. La sentencia también puede incluir la rama
}\textstyleSourceText{\foreignlanguage{spanish}{else}}\foreignlanguage{spanish}{ o la rama
}\textstyleSourceText{\foreignlanguage{spanish}{elif}}\foreignlanguage{spanish}{. La forma simple de declaración
}\textstyleSourceText{\foreignlanguage{spanish}{if}}\foreignlanguage{spanish}{ sin ramas es}

\textstyleSourceText{\foreignlanguage{spanish}{if}}\foreignlanguage{spanish}{
}\foreignlanguage{spanish}{\textbf{condición}}\foreignlanguage{spanish}{ ~~
}\foreignlanguage{spanish}{\textbf{bloque}}\foreignlanguage{spanish}{
}\textstyleSourceText{\foreignlanguage{spanish}{end}}

\foreignlanguage{spanish}{\textbf{condición}}\foreignlanguage{spanish}{ es una expresión condicional. Cuando el valor de
*}\foreignlanguage{spanish}{\textit{condición}}\foreignlanguage{spanish}{ es
}\textstyleSourceText{\foreignlanguage{spanish}{verdadero}}\foreignlanguage{spanish}{, se ejecutará
}\foreignlanguage{spanish}{\textbf{bloque}}\foreignlanguage{spanish}{ en la segunda línea; de lo contrario, se omitirá
el }\foreignlanguage{spanish}{\textbf{bloque}}\foreignlanguage{spanish}{ y se ejecutará la instrucción que sigue a
}\textstyleSourceText{\foreignlanguage{spanish}{end}}\foreignlanguage{spanish}{. En el caso de que se ejecute
}\foreignlanguage{spanish}{\textbf{bloque}}\foreignlanguage{spanish}{, después de que se ejecute la última declaración
en el bloque, dejará la declaración }\textstyleSourceText{\foreignlanguage{spanish}{if}}\foreignlanguage{spanish}{ y
comenzará a ejecutar la declaración que sigue a
}\textstyleSourceText{\foreignlanguage{spanish}{end}}\foreignlanguage{spanish}{.}

\foreignlanguage{spanish}{Aquí hay un ejemplo para ilustrar el uso de la sentencia
}\textstyleSourceText{\foreignlanguage{spanish}{if}}\foreignlanguage{spanish}{:}


\bigskip

{\selectlanguage{spanish}\ttfamily
if 8 \% 2 == 0}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ print('este número es par')}

{\selectlanguage{spanish}\ttfamily
end}


\bigskip

\foreignlanguage{spanish}{Este código se usa para juzgar si el número '8' es par y, si lo es, generará 'este número es
par'. Aunque este ejemplo es muy simple, es suficiente para ilustrar el uso básico de las Sentencias
}\textstyleSourceText{\foreignlanguage{spanish}{if}}\foreignlanguage{spanish}{.}

\foreignlanguage{spanish}{Si desea tener una rama correspondiente para la ejecución cuando la condición se cumple y
}\foreignlanguage{spanish}{no se cumple, use la instrucción
}\textstyleSourceText{\foreignlanguage{spanish}{if}}\foreignlanguage{spanish}{ con la rama
}\textstyleSourceText{\foreignlanguage{spanish}{else}}\foreignlanguage{spanish}{. La forma de la Sentencia es:}

\textstyleSourceText{\foreignlanguage{spanish}{if}}\foreignlanguage{spanish}{
}\foreignlanguage{spanish}{\textbf{condición}}\foreignlanguage{spanish}{ ~~
}\foreignlanguage{spanish}{\textbf{bloque}}\foreignlanguage{spanish}{
}\textstyleSourceText{\foreignlanguage{spanish}{else}}\foreignlanguage{spanish}{
}\foreignlanguage{spanish}{\textbf{bloque}}\foreignlanguage{spanish}{
}\textstyleSourceText{\foreignlanguage{spanish}{end}}

\foreignlanguage{spanish}{A diferencia de la simple instrucción
}\textstyleSourceText{\foreignlanguage{spanish}{if}}\foreignlanguage{spanish}{, la declaración
}\textstyleSourceText{\foreignlanguage{spanish}{if else}}\foreignlanguage{spanish}{ ejecutará
}\foreignlanguage{spanish}{\textbf{bloque}}\foreignlanguage{spanish}{ en la rama
}\textstyleSourceText{\foreignlanguage{spanish}{else}}\foreignlanguage{spanish}{ cuando el valor de
}\foreignlanguage{spanish}{\textbf{condición}}\foreignlanguage{spanish}{ sea
}\textstyleSourceText{\foreignlanguage{spanish}{falso}}\foreignlanguage{spanish}{. No importa qué rama se ejecute bajo
}\foreignlanguage{spanish}{\textbf{bloque}}\foreignlanguage{spanish}{, después de que se ejecute la última declaración
en el bloque, aparecerá la declaración }\textstyleSourceText{\foreignlanguage{spanish}{if
else}}\foreignlanguage{spanish}{, es decir, se ejecutará la declaración después de
}\textstyleSourceText{\foreignlanguage{spanish}{end}}\foreignlanguage{spanish}{. En otras palabras, no importa si el
valor de }\foreignlanguage{spanish}{\textbf{condición}}\foreignlanguage{spanish}{ es
}\textstyleSourceText{\foreignlanguage{spanish}{verdadero}}\foreignlanguage{spanish}{ o
}\textstyleSourceText{\foreignlanguage{spanish}{falso}}\foreignlanguage{spanish}{, se ejecutará un
}\foreignlanguage{spanish}{\textbf{bloque}}\foreignlanguage{spanish}{.}

{\selectlanguage{spanish}
Continúe usando el juicio de paridad como ejemplo, esta vez cambie la demanda para generar la información
correspondiente de acuerdo con la paridad del número de entrada. El código para lograr este requisito es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
if x \% 2 == 0}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ print('este número es par')}

{\selectlanguage{spanish}\ttfamily
else}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ print('este número es impar')}

{\selectlanguage{spanish}\ttfamily
end}


\bigskip

\foreignlanguage{spanish}{Antes de ejecutar este código, primero debemos asignar un valor entero a la variable
}\textstyleSourceText{\foreignlanguage{spanish}{x}}\foreignlanguage{spanish}{, que es el número cuya paridad queremos
comprobar. Si 'x' es un número par, el programa generará 'este número es par'; de lo contrario, generará 'este número
es impar'. A veces necesitamos anidar declaraciones
}\textstyleSourceText{\foreignlanguage{spanish}{if}}\foreignlanguage{spanish}{. Una forma es anidar una instrucción
}\textstyleSourceText{\foreignlanguage{spanish}{if}}\foreignlanguage{spanish}{ debajo de la rama
}\textstyleSourceText{\foreignlanguage{spanish}{else}}\foreignlanguage{spanish}{. Este es un requisito muy común porque
muchas condiciones deben juzgarse consecutivamente. Para este tipo de demanda, use la instrucción
}\textstyleSourceText{\foreignlanguage{spanish}{if else}}\foreignlanguage{spanish}{ para escribir:}


\bigskip

{\selectlanguage{spanish}\ttfamily
if expr}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ bloque}

{\selectlanguage{spanish}\ttfamily
else}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ if expr}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ bloque}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ end}

{\selectlanguage{spanish}\ttfamily
end}


\bigskip

\foreignlanguage{spanish}{Obviamente, esta forma de escribir aumentará el nivel de sangría del código, y es más
engorroso usar múltiples }\textstyleSourceText{\foreignlanguage{spanish}{end}}\foreignlanguage{spanish}{ al final. Como
mejora, Berry proporciona la rama }\textstyleSourceText{\foreignlanguage{spanish}{elif}}\foreignlanguage{spanish}{ para
optimizar la escritura anterior. Usar la rama
}\textstyleSourceText{\foreignlanguage{spanish}{elif}}\foreignlanguage{spanish}{ es equivalente al código anterior, en
la forma}

\textstyleSourceText{\foreignlanguage{spanish}{if}}\foreignlanguage{spanish}{
}\foreignlanguage{spanish}{\textbf{condición}}\foreignlanguage{spanish}{
}\foreignlanguage{spanish}{\textbf{bloque}}\foreignlanguage{spanish}{
}\textstyleSourceText{\foreignlanguage{spanish}{elif}}\foreignlanguage{spanish}{
}\foreignlanguage{spanish}{\textbf{condición}}\foreignlanguage{spanish}{
}\foreignlanguage{spanish}{\textbf{bloque}}\foreignlanguage{spanish}{
}\textstyleSourceText{\foreignlanguage{spanish}{else}}\foreignlanguage{spanish}{
}\foreignlanguage{spanish}{\textbf{bloque}}\foreignlanguage{spanish}{
}\textstyleSourceText{\foreignlanguage{spanish}{end}}

\foreignlanguage{spanish}{La rama debe usarse después de la rama
}\textstyleSourceText{\foreignlanguage{spanish}{if}}\foreignlanguage{spanish}{ y antes de la rama, y la rama
}\textstyleSourceText{\foreignlanguage{spanish}{elif}}\foreignlanguage{spanish}{ se puede usar varias veces seguidas.
Si se cumple la }\foreignlanguage{spanish}{\textbf{condición}}\foreignlanguage{spanish}{ correspondiente a la rama
}\textstyleSourceText{\foreignlanguage{spanish}{elif}}\foreignlanguage{spanish}{, se ejecutará el
}\foreignlanguage{spanish}{\textbf{bloque}}\foreignlanguage{spanish}{ debajo de la rama. La ramificación
}\textstyleSourceText{\foreignlanguage{spanish}{elif}}\foreignlanguage{spanish}{ es adecuada para situaciones que
requieren que se juzguen múltiples condiciones en secuencia.}

\foreignlanguage{spanish}{Usamos un fragmento de código que juzga positivo, negativo y 0 para demostrar la rama
}\textstyleSourceText{\foreignlanguage{spanish}{elif}}\foreignlanguage{spanish}{:}


\bigskip

{\selectlanguage{spanish}\ttfamily
if x{\textgreater} 0}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ print('positivo')}

{\selectlanguage{spanish}\ttfamily
elif x == 0}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ print('cero')}

{\selectlanguage{spanish}\ttfamily
else}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ print('negativo')}

{\selectlanguage{spanish}\ttfamily
end}


\bigskip

\foreignlanguage{spanish}{Aquí también, la variable
}\textstyleSourceText{\foreignlanguage{spanish}{x}}\foreignlanguage{spanish}{ debe asignarse primero. Este código es
muy simple y no será explicado.}

\foreignlanguage{spanish}{Algunos lenguajes tienen un problema llamado
{\textquotedbl}}\textstyleSourceText{\foreignlanguage{spanish}{else}}\foreignlanguage{spanish}{{\textquotedbl}
colgante, que se refiere a cuando una Sentencia
}\textstyleSourceText{\foreignlanguage{spanish}{if}}\foreignlanguage{spanish}{ está anidada dentro de otra Sentencia
}\textstyleSourceText{\foreignlanguage{spanish}{if}}\foreignlanguage{spanish}{, ¿a dónde pertenece la rama
}\textstyleSourceText{\foreignlanguage{spanish}{else}}\foreignlanguage{spanish}{? Es un problema con la sentencia
}\textstyleSourceText{\foreignlanguage{spanish}{if}}\foreignlanguage{spanish}{. Cuando usamos C/C++, debemos considerar
el problema de colgar }\textstyleSourceText{\foreignlanguage{spanish}{else}}\foreignlanguage{spanish}{. Para evitar la
ambigüedad en el problema de }\textstyleSourceText{\foreignlanguage{spanish}{if else}}\foreignlanguage{spanish}{, los
programadores de C/C++ a menudo usan llaves para convertir una rama en un bloque. En Berry, la rama de la instrucción
}\textstyleSourceText{\foreignlanguage{spanish}{if}}\foreignlanguage{spanish}{ debe ser un bloque, lo que también
determina que Berry no tiene el problema de sobresalir por
}\textstyleSourceText{\foreignlanguage{spanish}{else}}\foreignlanguage{spanish}{.}

\subsection[4.3 Declaración de iteración]{\selectlanguage{spanish} 4.3 Declaración de iteración}
\hypertarget{RefHeadingToc355973639824055}{}\foreignlanguage{spanish}{Las declaraciones iterativas también se denominan
declaraciones de bucle, que se utilizan para repetir ciertas operaciones hasta que se cumple la condición de
terminación. Berry proporciona las declaraciones
}\textstyleSourceText{\foreignlanguage{spanish}{while}}\foreignlanguage{spanish}{ y
}\textstyleSourceText{\foreignlanguage{spanish}{for}}\foreignlanguage{spanish}{, dos declaraciones de iteración. Muchos
lenguajes también proporcionan estas dos declaraciones para la iteración. La declaración
}\textstyleSourceText{\foreignlanguage{spanish}{while}}\foreignlanguage{spanish}{ de Berry es similar a la declaración
}\textstyleSourceText{\foreignlanguage{spanish}{while}}\foreignlanguage{spanish}{ en C/C++, pero la declaración
}\textstyleSourceText{\foreignlanguage{spanish}{for}}\foreignlanguage{spanish}{ de Berry solo se usa para recorrer los
elementos en el contenedor, similar a la declaración
}\textstyleSourceText{\foreignlanguage{spanish}{foreach}}\foreignlanguage{spanish}{ proporcionada por algunos lenguajes
y la que se introdujo por el nuevo estilo en C++11 de
}\textstyleSourceText{\foreignlanguage{spanish}{for}}\foreignlanguage{spanish}{. No se admite la instrucción
}\textstyleSourceText{\foreignlanguage{spanish}{for}}\foreignlanguage{spanish}{ de estilo C.}

\subsubsection[4.3.2 Sentencia while]{\foreignlanguage{spanish}{4.3.2 }\foreignlanguage{spanish}{Sentencia
}\textstyleSourceText{\foreignlanguage{spanish}{while}}}
\hypertarget{RefHeadingToc355993639824055}{}\foreignlanguage{spanish}{La declaración
}\textstyleSourceText{\foreignlanguage{spanish}{while}}\foreignlanguage{spanish}{ es una declaración iterativa básica.
La instrucción }\textstyleSourceText{\foreignlanguage{spanish}{while}}\foreignlanguage{spanish}{ utiliza una condición
de juicio. Cuando la condición es verdadera, el cuerpo del ciclo se ejecuta repetidamente; de lo contrario, el ciclo
finaliza. El patrón de la declaración es}

\textstyleSourceText{\foreignlanguage{spanish}{while}}\foreignlanguage{spanish}{
}\foreignlanguage{spanish}{\textbf{condición}}\foreignlanguage{spanish}{ ~~
}\foreignlanguage{spanish}{\textbf{bloque}}\foreignlanguage{spanish}{
}\textstyleSourceText{\foreignlanguage{spanish}{end}}

\foreignlanguage{spanish}{Cuando el programa ejecuta la sentencia
}\textstyleSourceText{\foreignlanguage{spanish}{while}}\foreignlanguage{spanish}{, comprobará si la expresión
}\foreignlanguage{spanish}{\textbf{condición}}\foreignlanguage{spanish}{ es verdadera o falsa. Si es cierto, ejecuta el
}\foreignlanguage{spanish}{\textbf{bloque}}\foreignlanguage{spanish}{ del cuerpo del ciclo; de lo contrario, finaliza
el ciclo. Después de ejecutar la última declaración en
}\foreignlanguage{spanish}{\textbf{bloque}}\foreignlanguage{spanish}{, el programa saltará al comienzo de la
declaración }\textstyleSourceText{\foreignlanguage{spanish}{while}}\foreignlanguage{spanish}{ y comenzará la siguiente
ronda de detección. Si la expresión de }\foreignlanguage{spanish}{\textbf{condición}}\foreignlanguage{spanish}{ es
falsa cuando se evalúa por primera vez, el }\foreignlanguage{spanish}{\textbf{bloque}}\foreignlanguage{spanish}{ del
cuerpo del bucle no se ejecutará en absoluto (al igual que la expresión de
}\foreignlanguage{spanish}{\textbf{condición}}\foreignlanguage{spanish}{ de la declaración
}\textstyleSourceText{\foreignlanguage{spanish}{if}}\foreignlanguage{spanish}{ es falsa). En términos generales, el
valor de la expresión }\foreignlanguage{spanish}{\textbf{condición}}\foreignlanguage{spanish}{ debería poder cambiar
durante el ciclo, en lugar de ser una constante o una variable modificada fuera del ciclo, lo que hará que el ciclo no
se ejecute o no termine. Un bucle que nunca termina se llama bucle sin fin. Por lo general, esperamos que el ciclo se
ejecute un número específico de veces y luego termine. Por ejemplo, cuando usamos el bucle
}\textstyleSourceText{\foreignlanguage{spanish}{while}}\foreignlanguage{spanish}{ para acceder a todos los elementos de
la matriz, esperamos que el número de ejecuciones del bucle sea igual a la longitud de la matriz, por ejemplo:}


\bigskip

{\selectlanguage{spanish}\ttfamily
i = 0}

{\selectlanguage{spanish}\ttfamily
l = ['a','b','c']}

{\selectlanguage{spanish}\ttfamily
while i {\textless} l.size()}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ print(l[i])}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ i = i + 1}

{\selectlanguage{spanish}\ttfamily
end}


\bigskip

\foreignlanguage{spanish}{Este bucle obtiene los elementos del arreglo
}\textstyleSourceText{\foreignlanguage{spanish}{l}}\foreignlanguage{spanish}{ y los imprime. Usamos una variable
}\textstyleSourceText{\foreignlanguage{spanish}{i}}\foreignlanguage{spanish}{ como contador de bucles e índice de
matriz. Dejamos que el valor de }\textstyleSourceText{\foreignlanguage{spanish}{i}}\foreignlanguage{spanish}{ alcance
la longitud de la matriz }\textstyleSourceText{\foreignlanguage{spanish}{l}}\foreignlanguage{spanish}{ para finalizar
el bucle. En la última línea del cuerpo del bucle, añadimos
}\textstyleSourceText{\foreignlanguage{spanish}{1}}\foreignlanguage{spanish}{ al valor de
}\textstyleSourceText{\foreignlanguage{spanish}{i}}\foreignlanguage{spanish}{ para asegurar que se acceda al siguiente
elemento de la matriz en el siguiente bucle, y el bucle
}\textstyleSourceText{\foreignlanguage{spanish}{while}}\foreignlanguage{spanish}{ finaliza cuando el número de bucles
alcanza la longitud de la matriz.}

\subsubsection[4.3.2 Sentencia for]{\foreignlanguage{spanish}{4.3.2 }\foreignlanguage{spanish}{Sentencia
}\textstyleSourceText{\foreignlanguage{spanish}{for}}}
\hypertarget{RefHeadingToc356013639824055}{}\foreignlanguage{spanish}{La instrucción
}\textstyleSourceText{\foreignlanguage{spanish}{for}}\foreignlanguage{spanish}{ de Berry se usa para recorrer los
elementos en el contenedor, y su forma es}

\textstyleSourceText{\foreignlanguage{spanish}{for
}}\foreignlanguage{spanish}{\textbf{variable}}\foreignlanguage{spanish}{
}\textstyleSourceText{\foreignlanguage{spanish}{:}}\foreignlanguage{spanish}{
}\foreignlanguage{spanish}{\textbf{expresión}}\foreignlanguage{spanish}{
}\foreignlanguage{spanish}{\textbf{bloque}}\foreignlanguage{spanish}{
}\textstyleSourceText{\foreignlanguage{spanish}{end}}

\foreignlanguage{spanish}{\textbf{expresión}}\foreignlanguage{spanish}{ El valor de la expresión debe ser un contenedor
iterable o una función, como la clase
}\textstyleSourceText{\foreignlanguage{spanish}{range}}\foreignlanguage{spanish}{. La declaración obtiene un iterador
del contenedor y obtiene un elemento en el contenedor cada vez que se llama al iterador.}

\foreignlanguage{spanish}{\textbf{variable}}\foreignlanguage{spanish}{ se denomina variable de iteración, que siempre se
define en la instrucción }\textstyleSourceText{\foreignlanguage{spanish}{for}}\foreignlanguage{spanish}{. Por lo tanto,
}\foreignlanguage{spanish}{\textbf{variable}}\foreignlanguage{spanish}{ debe ser un nombre de variable y no una
expresión. El elemento contenedor obtenido del iterador en cada bucle se asignará a la variable de iteración. Este
proceso ocurre antes de la primera declaración en
}\foreignlanguage{spanish}{\textbf{bloque}}\foreignlanguage{spanish}{.}

\foreignlanguage{spanish}{La declaración }\textstyleSourceText{\foreignlanguage{spanish}{for}}\foreignlanguage{spanish}{
verificará si hay elementos no visitados en el iterador para la iteración. Si los hay, comenzará la siguiente
iteración; de lo contrario, finalizará la declaración
}\textstyleSourceText{\foreignlanguage{spanish}{for}}\foreignlanguage{spanish}{ y ejecutará la declaración que sigue a
}\textstyleSourceText{\foreignlanguage{spanish}{end}}\foreignlanguage{spanish}{. Actualmente, Berry solo proporciona
iteradores de solo lectura, lo que significa que los elementos del contenedor no se pueden modificar a través de las
variables de iteración en la instrucción
}\textstyleSourceText{\foreignlanguage{spanish}{for}}\foreignlanguage{spanish}{.}

\foreignlanguage{spanish}{El alcance de la variable de iteración
}\foreignlanguage{spanish}{\textbf{variable}}\foreignlanguage{spanish}{ se limita al
}\foreignlanguage{spanish}{\textbf{bloque}}\foreignlanguage{spanish}{ del cuerpo del ciclo, y la variable no tendrá
ninguna relación con la variable con el mismo nombre fuera del alcance. Para ilustrar este punto, usemos un ejemplo
para ilustrar. En este ejemplo, usamos la instrucción
}\textstyleSourceText{\foreignlanguage{spanish}{for}}\foreignlanguage{spanish}{ para acceder a todos los elementos en
la instancia }\textstyleSourceText{\foreignlanguage{spanish}{range}}\foreignlanguage{spanish}{ e imprimirlos. Por
supuesto, también usamos este ejemplo para demostrar el alcance de las variables de bucle.}


\bigskip

{\selectlanguage{spanish}\ttfamily
i = {\textquotedbl}Hola, estoy bien{\textquotedbl}. \# Variable exterior}

{\selectlanguage{spanish}\ttfamily
for i: 0 .. 2}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ print(i) \# \ variable de iteración}

{\selectlanguage{spanish}\ttfamily
end}

{\selectlanguage{spanish}\ttfamily
print(i)}


\bigskip

\foreignlanguage{spanish}{En este ejemplo, en relación con la variable de iteración
}\textstyleSourceText{\foreignlanguage{spanish}{i}}\foreignlanguage{spanish}{ definida en la línea 2, la variable
}\textstyleSourceText{\foreignlanguage{spanish}{i}}\foreignlanguage{spanish}{ definida en la línea 1 es una variable
externa. Al ejecutar este ejemplo obtendrá el siguiente resultado:}

\textstyleSourceText{\foreignlanguage{spanish}{0 1 2 Hola, estoy bien}}

\foreignlanguage{spanish}{Se puede ver que la variable de iteración
}\textstyleSourceText{\foreignlanguage{spanish}{i}}\foreignlanguage{spanish}{ y la variable externa
}\textstyleSourceText{\foreignlanguage{spanish}{i}}\foreignlanguage{spanish}{ son dos variables diferentes. Solo tienen
el mismo nombre pero diferentes alcances.}

\paragraph[Principio de enunciado for]{\foreignlanguage{spanish}{Principio de enunciado
}\textstyleSourceText{\foreignlanguage{spanish}{for}}}
\hypertarget{RefHeadingToc356033639824055}{}\foreignlanguage{spanish}{A diferencia de la sentencia iterativa tradicional
}\textstyleSourceText{\foreignlanguage{spanish}{while}}\foreignlanguage{spanish}{, la sentencia
}\textstyleSourceText{\foreignlanguage{spanish}{for}}\foreignlanguage{spanish}{ utiliza iteradores para atravesar el
contenedor. Si necesita usar la declaración
}\textstyleSourceText{\foreignlanguage{spanish}{for}}\foreignlanguage{spanish}{ para atravesar una clase personalizada,
debe comprender su mecanismo de implementación. Cuando se usa la instrucción
}\textstyleSourceText{\foreignlanguage{spanish}{for}}\foreignlanguage{spanish}{, el intérprete oculta muchos detalles
de implementación. De hecho, para dicho código:}


\bigskip

{\selectlanguage{spanish}\ttfamily
for i: 0 .. 2}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ print(i)}

{\selectlanguage{spanish}\ttfamily
end}


\bigskip

{\selectlanguage{spanish}
Será traducido al siguiente código equivalente por el intérprete:}


\bigskip

{\selectlanguage{spanish}\ttfamily
var it = \_\_iterator\_\_(0 .. 2)}

{\selectlanguage{spanish}\ttfamily
try}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ while true}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ var i = it()}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ print(i)}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ end}

{\selectlanguage{spanish}\ttfamily
except 'stop\_iteration'}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \# \ no hacer nada}

{\selectlanguage{spanish}\ttfamily
end}


\bigskip

\foreignlanguage{spanish}{Hasta cierto punto, la declaración
}\textstyleSourceText{\foreignlanguage{spanish}{for}}\foreignlanguage{spanish}{ es solo un azúcar sintáctico, y es
esencialmente solo una forma simple de escribir una pieza de código complejo. En este código equivalente se usa una
variable intermedia }\textstyleSourceText{\foreignlanguage{spanish}{it}}\foreignlanguage{spanish}{. El valor de la
variable es un iterador y, en este ejemplo, es un iterador del contenedor
}\textstyleSourceText{\foreignlanguage{spanish}{range}}\foreignlanguage{spanish}{
}\textstyleSourceText{\foreignlanguage{spanish}{0..2}}\foreignlanguage{spanish}{. Al procesar la instrucción
}\textstyleSourceText{\foreignlanguage{spanish}{for}}\foreignlanguage{spanish}{, el intérprete oculta la variable
intermedia del iterador, por lo que no se puede acceder a ella en el código.}

\foreignlanguage{spanish}{El parámetro de la función
}\textstyleSourceText{\foreignlanguage{spanish}{\_\_iterator\_\_}}\foreignlanguage{spanish}{ es un contenedor y la
función devuelve un iterador de parámetros. Esta función obtiene el iterador llamando al método de parámetro. Por lo
tanto, si el valor de retorno del método
}\textstyleSourceText{\foreignlanguage{spanish}{iter}}\foreignlanguage{spanish}{ es un tipo de instancia
(}\textstyleSourceText{\foreignlanguage{spanish}{instance}}\foreignlanguage{spanish}{), esta instancia debe tener un
método }\textstyleSourceText{\foreignlanguage{spanish}{next}}\foreignlanguage{spanish}{ y un método
}\textstyleSourceText{\foreignlanguage{spanish}{hasnext}}\foreignlanguage{spanish}{.}

\foreignlanguage{spanish}{El parámetro de la función
}\textstyleSourceText{\foreignlanguage{spanish}{\_\_hasnext\_\_}}\foreignlanguage{spanish}{ es un iterador, que
comprueba si el iterador tiene el siguiente elemento llamando al método
}\textstyleSourceText{\foreignlanguage{spanish}{hasnext}}\foreignlanguage{spanish}{ del iterador
}\textstyleSourceText{\foreignlanguage{spanish}{hasnext}}\foreignlanguage{spanish}{ El valor de retorno del método es
de tipo }\textstyleSourceText{\foreignlanguage{spanish}{booleano}}\foreignlanguage{spanish}{. El parámetro de la
función }\textstyleSourceText{\foreignlanguage{spanish}{\_\_next\_\_}}\foreignlanguage{spanish}{ también es un
iterador, que obtiene el siguiente elemento en el iterador llamando al método
}\textstyleSourceText{\foreignlanguage{spanish}{next}}\foreignlanguage{spanish}{ del iterador.}

\foreignlanguage{spanish}{Hasta ahora, las funciones
}\textstyleSourceText{\foreignlanguage{spanish}{\_\_iterator\_\_}}\foreignlanguage{spanish}{,
}\textstyleSourceText{\foreignlanguage{spanish}{\_\_hasnext\_\_}}\foreignlanguage{spanish}{ y
}\textstyleSourceText{\foreignlanguage{spanish}{\_\_next\_\_}}\foreignlanguage{spanish}{ simplemente llaman a algunos
métodos del contenedor o iterador y luego devuelven el valor de retorno de estos métodos. Por lo tanto, la escritura
equivalente de la instrucción }\textstyleSourceText{\foreignlanguage{spanish}{for}}\foreignlanguage{spanish}{ también
se puede simplificar de esta forma:}


\bigskip

{\selectlanguage{spanish}\ttfamily
do}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ var it = (0 .. 2).iter()}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ while (it.hasnext())}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ var i = it.next()}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ print(i)}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ end}

{\selectlanguage{spanish}\ttfamily
end}


\bigskip

\foreignlanguage{spanish}{Este código es más fácil de leer. Se puede ver en el código que el alcance de la variable
iteradora }\textstyleSourceText{\foreignlanguage{spanish}{it}}\foreignlanguage{spanish}{ es la declaración
}\textstyleSourceText{\foreignlanguage{spanish}{for}}\foreignlanguage{spanish}{ completa, pero no es visible fuera de
la declaración }\textstyleSourceText{\foreignlanguage{spanish}{for}}\foreignlanguage{spanish}{, mientras que el alcance
de la variable de iteración }\textstyleSourceText{\foreignlanguage{spanish}{i}}\foreignlanguage{spanish}{ está en el
cuerpo del bucle, por lo que cada iteración definirá nuevas variables de iteración.}

\subsection[4.4 Declaración de salto]{\selectlanguage{spanish} 4.4 Declaración de salto}
\hypertarget{RefHeadingToc356053639824055}{}\foreignlanguage{spanish}{La declaración de salto proporcionada por Berry se
usa para realizar el salto del flujo del programa en el proceso de bucle. Las sentencias de salto se dividen en
sentencias de {\textquotedbl}ruptura{\textquotedbl} y sentencias de {\textquotedbl}continuación{\textquotedbl}. Estas
dos declaraciones deben usarse dentro de declaraciones iterativas y solo pueden usarse dentro de funciones para saltar.
Algunos lenguajes proporcionan sentencias
}\textstyleSourceText{\foreignlanguage{spanish}{goto}}\foreignlanguage{spanish}{ para realizar saltos arbitrarios
dentro de las funciones, que Berry no proporciona, pero los efectos de las sentencias
}\textstyleSourceText{\foreignlanguage{spanish}{goto}}\foreignlanguage{spanish}{ se pueden reemplazar por sentencias
condicionales y sentencias de iteración.}

\subsection[4.4.1 Declaración break]{\foreignlanguage{spanish}{4.4.1 }\foreignlanguage{spanish}{Declaración
}\textstyleSourceText{\foreignlanguage{spanish}{break}}}
\hypertarget{RefHeadingToc356073639824055}{}\textstyleSourceText{\foreignlanguage{spanish}{break}}\foreignlanguage{spanish}{
se usa para terminar la declaración de iteración y saltar. Después de la ejecución de la sentencia
}\textstyleSourceText{\foreignlanguage{spanish}{break}}\foreignlanguage{spanish}{, el nivel más cercano de la sentencia
de iteración terminará inmediatamente y la ejecución continuará desde la posición de la primera sentencia después de la
sentencia de iteración. Para ilustrar el flujo de ejecución de la declaración
}\textstyleSourceText{\foreignlanguage{spanish}{break}}\foreignlanguage{spanish}{, usamos un ejemplo para demostrarlo:}


\bigskip

{\selectlanguage{spanish}\ttfamily
while true}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ print('antes del break')}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ break}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ print('después del break')}

{\selectlanguage{spanish}\ttfamily
end}

{\selectlanguage{spanish}\ttfamily
print('fuera del bucle')}


\bigskip

\foreignlanguage{spanish}{En este código, la sentencia
}\textstyleSourceText{\foreignlanguage{spanish}{break}}\foreignlanguage{spanish}{ está en un bucle
}\textstyleSourceText{\foreignlanguage{spanish}{while}}\foreignlanguage{spanish}{. Antes y después de la declaración
}\textstyleSourceText{\foreignlanguage{spanish}{break}}\foreignlanguage{spanish}{ y después de la declaración
}\textstyleSourceText{\foreignlanguage{spanish}{while}}\foreignlanguage{spanish}{, hemos colocado una declaración de
impresión para probar el flujo de ejecución del programa. El resultado de este código es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
antes del break}

{\selectlanguage{spanish}\ttfamily
fuera del bucle}


\bigskip

\foreignlanguage{spanish}{Esto muestra que la sentencia
}\textstyleSourceText{\foreignlanguage{spanish}{while}}\foreignlanguage{spanish}{ finaliza el bucle en la posición de
la sentencia }\textstyleSourceText{\foreignlanguage{spanish}{break}}\foreignlanguage{spanish}{ en la tercera línea y el
programa continúa ejecutándose desde la sexta línea.}

\subsubsection[4.4.2 Declaración continue]{\foreignlanguage{spanish}{4.4.2 }\foreignlanguage{spanish}{Declaración
}\textstyleSourceText{\foreignlanguage{spanish}{continue}}}
\hypertarget{RefHeadingToc356093639824055}{}\foreignlanguage{spanish}{Esta declaración también se usa dentro de una
declaración de iteración. Su función es }\foreignlanguage{spanish}{finalizar una iteración e iniciar inmediatamente la
siguiente ronda. Por lo tanto, después de la ejecución de la sentencia
}\textstyleSourceText{\foreignlanguage{spanish}{continue}}\foreignlanguage{spanish}{, el código restante en la
sentencia de iteración de la capa más cercana ya no se ejecutará, pero comenzará una nueva ronda de iteración. Aquí
usamos una sentencia }\textstyleSourceText{\foreignlanguage{spanish}{for}}\foreignlanguage{spanish}{ para demostrar la
función de la sentencia }\textstyleSourceText{\foreignlanguage{spanish}{continue}}\foreignlanguage{spanish}{:}


\bigskip

{\selectlanguage{spanish}\ttfamily
for i: 0 .. 5}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ if i {\textgreater}= 2}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ continue}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ end}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ print('i =', i)}

{\selectlanguage{spanish}\ttfamily
end}

{\selectlanguage{spanish}\ttfamily
print('fuera del bucle')}


\bigskip

\foreignlanguage{spanish}{Aquí, la instrucción
}\textstyleSourceText{\foreignlanguage{spanish}{for}}\foreignlanguage{spanish}{ iterará 6 veces. Cuando la variable de
iteración }\textstyleSourceText{\foreignlanguage{spanish}{i}}\foreignlanguage{spanish}{ es mayor o igual que
}\textstyleSourceText{\foreignlanguage{spanish}{2}}\foreignlanguage{spanish}{, se ejecutará la declaración
}\textstyleSourceText{\foreignlanguage{spanish}{continue}}\foreignlanguage{spanish}{ en la línea 3, y la declaración de
impresión en la línea 5 no se ejecutará a partir de entonces. En otras palabras, la línea 5 solo se ejecutará en las
dos primeras iteraciones (en este momento }\textstyleSourceText{\foreignlanguage{spanish}{i {\textless}
2}}\foreignlanguage{spanish}{). El resultado de ejecución de esta rutina es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
i = 0}

{\selectlanguage{spanish}\ttfamily
i = 1}

{\selectlanguage{spanish}\ttfamily
fuera del bucle}


\bigskip

\foreignlanguage{spanish}{Se puede ver que el valor de la variable
}\textstyleSourceText{\foreignlanguage{spanish}{i}}\foreignlanguage{spanish}{ solo se imprime dos veces, lo cual está
en línea con las expectativas. Los lectores pueden intentar imprimir el valor de la variable
}\textstyleSourceText{\foreignlanguage{spanish}{i}}\foreignlanguage{spanish}{ antes de la instrucción
}\textstyleSourceText{\foreignlanguage{spanish}{continue}}\foreignlanguage{spanish}{. Encontrará que la declaración
}\textstyleSourceText{\foreignlanguage{spanish}{for}}\foreignlanguage{spanish}{ itera 6 veces, lo que indica que la
declaración }\textstyleSourceText{\foreignlanguage{spanish}{continue}}\foreignlanguage{spanish}{ no finaliza la
iteración.}

\subsection[4.5 Declaración import]{\foreignlanguage{spanish}{4.5 }\foreignlanguage{spanish}{Declaración
}\textstyleSourceText{\foreignlanguage{spanish}{import}}}
\hypertarget{RefHeadingToc356113639824055}{}\foreignlanguage{spanish}{Berry tiene algunos módulos predefinidos, como el
módulo }\textstyleSourceText{\foreignlanguage{spanish}{math}}\foreignlanguage{spanish}{ para cálculos matemáticos.
Estos módulos no se pueden usar directamente, sino que se deben importar con la instrucción
}\textstyleSourceText{\foreignlanguage{spanish}{import}}\foreignlanguage{spanish}{. Hay dos formas de importar un
módulo:}

\textstyleSourceText{\foreignlanguage{spanish}{import}}\foreignlanguage{spanish}{
}\foreignlanguage{spanish}{\textbf{nombre}}

\textstyleSourceText{\foreignlanguage{spanish}{import}}\foreignlanguage{spanish}{
}\foreignlanguage{spanish}{\textbf{nombre}}\foreignlanguage{spanish}{
}\textstyleSourceText{\foreignlanguage{spanish}{as}}\foreignlanguage{spanish}{
}\foreignlanguage{spanish}{\textbf{variable}}

\foreignlanguage{spanish}{\textbf{nombre}}\foreignlanguage{spanish}{ Para importar el nombre del módulo, al usar el
primer método de escritura para importar el módulo, el módulo importado se puede llamar directamente usando el nombre
del módulo. La segunda forma de escribir es importar un módulo llamado
}\foreignlanguage{spanish}{\textbf{nombre}}\foreignlanguage{spanish}{ y modificar el nombre del módulo al llamarlo a
}\foreignlanguage{spanish}{\textbf{variable}}\foreignlanguage{spanish}{. Por ejemplo, un módulo llamado
}\textstyleSourceText{\foreignlanguage{spanish}{math}}\foreignlanguage{spanish}{, usamos el primer método para importar
y usar:}


\bigskip

{\selectlanguage{spanish}\ttfamily
import math}

{\selectlanguage{spanish}\ttfamily
math.sin(0)}


\bigskip

\foreignlanguage{spanish}{Aquí usa directamente
}\textstyleSourceText{\foreignlanguage{spanish}{math}}\foreignlanguage{spanish}{ para llamar al módulo. Si el nombre de
un módulo es relativamente largo y no es conveniente escribirlo, puede usar la instrucción
}\textstyleSourceText{\foreignlanguage{spanish}{import as}}\foreignlanguage{spanish}{. Aquí, asuma un módulo llamado
}\textstyleSourceText{\foreignlanguage{spanish}{hardware}}\foreignlanguage{spanish}{. Queremos llamar a la función
}\textstyleSourceText{\foreignlanguage{spanish}{setled}}\foreignlanguage{spanish}{ del
}\foreignlanguage{spanish}{módulo, podemos importar el
}\textstyleSourceText{\foreignlanguage{spanish}{hardware}}\foreignlanguage{spanish}{ del módulo a la variable llamada
}\textstyleSourceText{\foreignlanguage{spanish}{hw}}\foreignlanguage{spanish}{ y usar:}


\bigskip

{\selectlanguage{spanish}\ttfamily
import hardware as hw}

{\selectlanguage{spanish}\ttfamily
hw.setled(true)}


\bigskip

\foreignlanguage{spanish}{Para encontrar módulos, todas las rutas en
}\textstyleSourceText{\foreignlanguage{spanish}{sys.path()}}\foreignlanguage{spanish}{ se exploran secuencialmente. Si
desea agregar una ruta específica antes de la importación (como leer desde la tarjeta SD), puede usar la siguiente
función de ayuda:}


\bigskip

{\selectlanguage{spanish}\ttfamily
def push\_path(p)}

{\selectlanguage{spanish}\ttfamily
\ \ import sys}

{\selectlanguage{spanish}\ttfamily
\ \ var path = sys.path()}

{\selectlanguage{spanish}\ttfamily
\ \ if path.find(p) == nil \ \# agregar solo si aún no está allí}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ path.push(p)}

{\selectlanguage{spanish}\ttfamily
\ \ end}

{\selectlanguage{spanish}\ttfamily
end}

\subsection[4.6 Manejo de excepciones]{\selectlanguage{spanish} 4.6 Manejo de excepciones}
\hypertarget{RefHeadingToc356133639824055}{}{\selectlanguage{spanish}
El mecanismo permite que el programa capture y maneje las excepciones que ocurren durante el tiempo de ejecución. Berry
admite un mecanismo de captura de excepciones que permite separar el proceso de captura y manejo de excepciones. Es
decir, parte del programa se usa para detectar y recopilar excepciones, y la otra parte del programa se usa para
manejar excepciones.}

{\selectlanguage{spanish}
En primer lugar, el programa problemático necesita lanzar primero una excepción. Cuando estos programas están en un
bloque de manejo de excepciones, un programa específico atrapará y manejará la excepción.}

\subsubsection[4.6.1 Generar una excepción]{\selectlanguage{spanish} 4.6.1 Generar una excepción}
\hypertarget{RefHeadingToc356153639824055}{}\foreignlanguage{spanish}{El uso de la instrucción
}\textstyleSourceText{\foreignlanguage{spanish}{raise}}\foreignlanguage{spanish}{ genera una excepción
}\textstyleSourceText{\foreignlanguage{spanish}{raise}}\foreignlanguage{spanish}{. La declaración pasará un valor para
indicar el tipo de excepción para que pueda ser identificada por un manejador de excepciones específico. A continuación
se explica cómo utilizar la sentencia
}\textstyleSourceText{\foreignlanguage{spanish}{raise}}\foreignlanguage{spanish}{:}

\textstyleSourceText{\foreignlanguage{spanish}{raise}}\foreignlanguage{spanish}{
}\foreignlanguage{spanish}{\textbf{excepción}}

\textstyleSourceText{\foreignlanguage{spanish}{raise}}\foreignlanguage{spanish}{
}\foreignlanguage{spanish}{\textbf{excepción}}\textstyleSourceText{\foreignlanguage{spanish}{,
}}\foreignlanguage{spanish}{\textbf{mensaje}}

{\selectlanguage{spanish}
El valor de la expresión \textbf{excepción} son los \textbf{valores atípicos} arrojados; la expresión de
\textbf{mensaje} opcional suele ser una cadena que describe la información de la excepción, y esta expresión se
denomina \textbf{parámetro anómalo}. Berry permite que cualquier valor se use como un valor anormal, por ejemplo, una
cadena se puede usar como un valor anormal:}

{\selectlanguage{spanish}\ttfamily
raise 'mi\_error','un ejemplo de subida'}

\foreignlanguage{spanish}{Después de que el programa se ejecute en la declaración
}\textstyleSourceText{\foreignlanguage{spanish}{raise}}\foreignlanguage{spanish}{, no continuará ejecutando las
declaraciones que le siguen, sino que saltará al bloque de manejo de excepciones más cercano. Si el bloque de manejo de
excepciones más reciente está en otras funciones, las funciones a lo largo de la cadena de llamadas se cerrarán antes.
Si no hay un bloque de manejo de excepciones, se producirá una }\foreignlanguage{spanish}{\textbf{salida
anormal}}\foreignlanguage{spanish}{ y el intérprete imprimirá el mensaje de error de la excepción y la pila de llamadas
de la ubicación del error. Cuando la instrucción
}\textstyleSourceText{\foreignlanguage{spanish}{raise}}\foreignlanguage{spanish}{ está en el bloque de instrucciones
}\textstyleSourceText{\foreignlanguage{spanish}{try}}\foreignlanguage{spanish}{, la excepción será capturada por este
último. La }\foreignlanguage{spanish}{excepción capturada será manejada por el bloque
}\textstyleSourceText{\foreignlanguage{spanish}{except}}\foreignlanguage{spanish}{ asociado con el bloque
}\textstyleSourceText{\foreignlanguage{spanish}{try}}\foreignlanguage{spanish}{. Si la excepción lanzada puede ser
manejada por el bloque 'except', la ejecución de este bloque continuará desde la declaración después del último bloque
}\textstyleSourceText{\foreignlanguage{spanish}{except}}\foreignlanguage{spanish}{. Si ninguna de las sentencias
}\textstyleSourceText{\foreignlanguage{spanish}{except}}\foreignlanguage{spanish}{ pueden manejar la excepción, la
excepción se volverá a generar hasta que se pueda manejar o la excepción finalice.}

\paragraph[Valores atípicos]{\selectlanguage{spanish} Valores atípicos}
\hypertarget{RefHeadingToc356173639824055}{}{\selectlanguage{spanish}
En Berry, puede usar cualquier valor como valor atípico, pero generalmente usamos cadenas cortas. Berry también puede
lanzar algunas excepciones internamente. Llamamos a estas excepciones \textbf{Excepción estándar}. Todos los valores de
excepción estándar son de tipo cadena.}


\bigskip

\begin{center}
\tablefirsthead{\centering{\selectlanguage{spanish}\bfseries Valores atípicos} &
\centering{\selectlanguage{spanish}\bfseries Descripción} &
\centering\arraybslash{\selectlanguage{spanish}\bfseries Descripción del parámetro}\\}
\tablehead{\centering{\selectlanguage{spanish}\bfseries Valores atípicos} &
\centering{\selectlanguage{spanish}\bfseries Descripción} &
\centering\arraybslash{\selectlanguage{spanish}\bfseries Descripción del parámetro}\\}
\tabletail{}
\tablelasttail{}
\begin{supertabular}{m{5.1080003cm}m{5.1080003cm}m{5.1080003cm}}
\centering \textstyleSourceText{\foreignlanguage{spanish}{assert\_failed}} &
\centering{\selectlanguage{spanish} Afirmación fallida} &
\centering\arraybslash{\selectlanguage{spanish} Información sobre excepciones específicas}\\
\centering \textstyleSourceText{\foreignlanguage{spanish}{index\_error}} &
\centering{\selectlanguage{spanish} (generalmente fuera de los límites)} &
\centering\arraybslash{\selectlanguage{spanish} Información sobre excepciones específicas}\\
\centering \textstyleSourceText{\foreignlanguage{spanish}{io\_error}} &
\centering{\selectlanguage{spanish} Mal funcionamiento de E/S} &
\centering\arraybslash{\selectlanguage{spanish} Información sobre excepciones específicas}\\
\centering \textstyleSourceText{\foreignlanguage{spanish}{key\_error}} &
\centering{\selectlanguage{spanish} Error clave} &
\centering\arraybslash{\selectlanguage{spanish} Información sobre excepciones específicas}\\
\centering \textstyleSourceText{\foreignlanguage{spanish}{runtime\_error}} &
\centering{\selectlanguage{spanish} Excepción de tiempo de ejecución de máquina virtual} &
\centering\arraybslash{\selectlanguage{spanish} Información sobre excepciones específicas}\\
\centering \textstyleSourceText{\foreignlanguage{spanish}{stop\_iteration}} &
\centering{\selectlanguage{spanish} Fin del iterador} &
\centering\arraybslash{\selectlanguage{spanish} no}\\
\centering \textstyleSourceText{\foreignlanguage{spanish}{syntax\_error}} &
\centering{\selectlanguage{spanish} Error de sintaxis} &
~
\\
\centering{\selectlanguage{spanish} por el compilador} &
~
 &
~
\\
\centering \textstyleSourceText{\foreignlanguage{spanish}{unrealized\_error}} &
\centering{\selectlanguage{spanish} Función no realizada} &
\centering\arraybslash{\selectlanguage{spanish} Información sobre excepciones específicas}\\
\centering \textstyleSourceText{\foreignlanguage{spanish}{tipe\_error}} &
\centering{\selectlanguage{spanish} Error de tipo} &
\centering\arraybslash{\selectlanguage{spanish} Información sobre excepciones específicas}\\
\end{supertabular}
\end{center}
{\selectlanguage{spanish}\itshape
Tabla 8: Lista de excepciones estándar}


\bigskip

\subsubsection[4.6.2 Capturar excepciones]{\selectlanguage{spanish} 4.6.2 Capturar excepciones}
\hypertarget{RefHeadingToc356193639824055}{}\foreignlanguage{spanish}{Utilice la instrucción
}\textstyleSourceText{\foreignlanguage{spanish}{except}}\foreignlanguage{spanish}{ para detectar excepciones. Debe
estar emparejado con la sentencia }\textstyleSourceText{\foreignlanguage{spanish}{try}}\foreignlanguage{spanish}{, es
decir, un bloque de sentencia }\textstyleSourceText{\foreignlanguage{spanish}{try}}\foreignlanguage{spanish}{ debe ir
seguido de uno o más bloques de sentencia
}\textstyleSourceText{\foreignlanguage{spanish}{except}}\foreignlanguage{spanish}{. La forma básica de la Sentencia
}\textstyleSourceText{\foreignlanguage{spanish}{try-except}}\foreignlanguage{spanish}{ es}

\foreignlanguage{spanish}{{\textasciigrave}{\textasciigrave}try}\textstyleSourceText{\foreignlanguage{spanish}{**bloque**}}\foreignlanguage{spanish}{except{\textasciigrave}
}\foreignlanguage{spanish}{\textbf{...}}\foreignlanguage{spanish}{
}\foreignlanguage{spanish}{\textbf{bloque}}\foreignlanguage{spanish}{ ~~{\textasciigrave}end{\textasciigrave}}

\foreignlanguage{spanish}{La rama }\textstyleSourceText{\foreignlanguage{spanish}{except}}\foreignlanguage{spanish}{
puede tener las siguientes formas}

\textstyleSourceText{\foreignlanguage{spanish}{except ..}}\foreignlanguage{spanish}{
}\textstyleSourceText{\foreignlanguage{spanish}{except
}}\foreignlanguage{spanish}{\textbf{excepciones}}\foreignlanguage{spanish}{
}\textstyleSourceText{\foreignlanguage{spanish}{except
}}\foreignlanguage{spanish}{\textbf{excepciones}}\textstyleSourceText{\foreignlanguage{spanish}{as}}\foreignlanguage{spanish}{
}\foreignlanguage{spanish}{\textbf{variable}}\foreignlanguage{spanish}{
}\textstyleSourceText{\foreignlanguage{spanish}{except
}}\foreignlanguage{spanish}{\textbf{excepciones}}\textstyleSourceText{\foreignlanguage{spanish}{as}}\foreignlanguage{spanish}{
}\foreignlanguage{spanish}{\textbf{variable}}\foreignlanguage{spanish}{
}\textstyleSourceText{\foreignlanguage{spanish}{, }}\foreignlanguage{spanish}{** mensaje**
}\textstyleSourceText{\foreignlanguage{spanish}{except .. as
}}\foreignlanguage{spanish}{\textbf{variable}}\foreignlanguage{spanish}{
}\textstyleSourceText{\foreignlanguage{spanish}{except .. as
}}\foreignlanguage{spanish}{\textbf{variable}}\foreignlanguage{spanish}{
}\textstyleSourceText{\foreignlanguage{spanish}{, }}\foreignlanguage{spanish}{\textbf{mensaje}}

\foreignlanguage{spanish}{La instrucción
}\textstyleSourceText{\foreignlanguage{spanish}{except}}\foreignlanguage{spanish}{ más básica no usa parámetros, esta
rama }\textstyleSourceText{\foreignlanguage{spanish}{except}}\foreignlanguage{spanish}{ capturará todas las
excepciones; }\foreignlanguage{spanish}{\textbf{Lista de excepciones de captura}}\foreignlanguage{spanish}{:
}\foreignlanguage{spanish}{\textbf{excepciones}}\foreignlanguage{spanish}{ es una lista de valores atípicos
}\foreignlanguage{spanish}{que pueden coincidir con la correspondiente rama
}\textstyleSourceText{\foreignlanguage{spanish}{except}}\foreignlanguage{spanish}{, que se utiliza entre varios valores
de la lista Separados por comas; }\foreignlanguage{spanish}{\textbf{variable}}\foreignlanguage{spanish}{ es
}\foreignlanguage{spanish}{\textbf{variable anormal}}\foreignlanguage{spanish}{, si la rama detecta una excepción, el
valor atípico se vinculará a la variable; }\foreignlanguage{spanish}{\textbf{mensaje}}\foreignlanguage{spanish}{ es
}\foreignlanguage{spanish}{\textbf{Variable de parámetro anómalo}}\foreignlanguage{spanish}{, si la rama detecta una
excepción, el valor del parámetro anómalo se vinculará a la variable.}

\foreignlanguage{spanish}{Cuando se detecta una excepción en el bloque de instrucciones
}\textstyleSourceText{\foreignlanguage{spanish}{try}}\foreignlanguage{spanish}{, el intérprete verificará la rama
}\textstyleSourceText{\foreignlanguage{spanish}{except}}\foreignlanguage{spanish}{ una por una. Si el valor de la
excepción existe en la lista de captura de una rama, se llamará al bloque de código debajo de la rama para manejar la
excepción, y la declaración }\textstyleSourceText{\foreignlanguage{spanish}{try-except}}\foreignlanguage{spanish}{
completa se cerrará después de que se ejecute el bloque de código. Si ninguna de las ramas
}\textstyleSourceText{\foreignlanguage{spanish}{except}}\foreignlanguage{spanish}{ coinciden, el controlador de
excepciones externo volverá a lanzar y capturar y manejar la excepción.}

\clearpage\section[Capítulo 5: Funciones]{Capítulo 5: \foreignlanguage{spanish}{Funcion}\foreignlanguage{spanish}{es}}
\hypertarget{RefHeadingToc356213639824055}{}
\bigskip

{\selectlanguage{spanish}
Una \textbf{función} es una {\textquotedbl}subrutina{\textquotedbl} que puede ser llamada por un código externo. Como
parte del programa, la función en sí también es una pieza de código. Una función puede tener 0 o más parámetros y
devolverá un resultado, que se denomina \textbf{valor de retorno} de la función.}

{\selectlanguage{spanish}
En Berry, la función es un \textbf{valor de primera clase}. Por lo tanto, además de llamar a funciones, también puede
pasar funciones como valores, por ejemplo, vincular funciones a variables, usar funciones como valores devueltos, etc.}

\subsection[5.1 Información básica]{\selectlanguage{spanish} 5.1 Información básica}
\hypertarget{RefHeadingToc356233639824055}{}\foreignlanguage{spanish}{El uso de funciones incluye dos partes: definición
de función y llamada. La declaración de definición de función usa la palabra clave
}\textstyleSourceText{\foreignlanguage{spanish}{def}}\foreignlanguage{spanish}{ como el comienzo. La definición de la
función es el proceso de empaquetar y nombrar el código del cuerpo de la función. Este proceso solo genera la
estructura de la función y no ejecuta la función. La función de ejecución debe usar un
}\foreignlanguage{spanish}{\textbf{operador de llamada}}\foreignlanguage{spanish}{, que es un par de paréntesis. El
operador de llamada actúa sobre una expresión cuyo resultado es un tipo de función. Los parámetros que se pasan a la
función se escriben entre paréntesis y los parámetros múltiples se separan con comas. El resultado de la expresión de
llamada es el valor de retorno de la función.}

\subsubsection[5.1.1 Definición de funciones]{\selectlanguage{spanish} 5.1.1 Definición de funciones}
\hypertarget{RefHeadingToc356253639824055}{}\paragraph[Función con nombre]{\selectlanguage{spanish} Función con nombre}
\hypertarget{RefHeadingToc356273639824055}{}\foreignlanguage{spanish}{Una }\foreignlanguage{spanish}{\textbf{función con
nombre}}\foreignlanguage{spanish}{ es una función a la que se le da un nombre cuando se define. Su declaración de
definición consta de las siguientes partes: palabra clave
}\textstyleSourceText{\foreignlanguage{spanish}{def}}\foreignlanguage{spanish}{, nombre de funcion, lista que constan
de 0 a múltiples parámetros y cuerpo de función, múltiples parámetros en la lista de parámetros están separados por
comas, y todos los parámetros están escritos en un par de paréntesis. Llamamos al parámetro cuando la función se define
como }\foreignlanguage{spanish}{\textbf{Parámetros formales}}\foreignlanguage{spanish}{, y al parámetro cuando llamamos
a la función como }\foreignlanguage{spanish}{\textbf{Argumentos}}\foreignlanguage{spanish}{. La forma general de la
definición de la función es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
{}'def' name ´(´ argumentos ´)´}

{\selectlanguage{spanish}\ttfamily
\ \ bloque}

{\selectlanguage{spanish}\ttfamily
´end'}


\bigskip

\foreignlanguage{spanish}{El nombre de función }\foreignlanguage{spanish}{\textbf{nombre}}\foreignlanguage{spanish}{ es
un identificador; }\foreignlanguage{spanish}{\textbf{argumentos}}\foreignlanguage{spanish}{ es la lista de parámetros
formales; }\foreignlanguage{spanish}{\textbf{bloque}}\foreignlanguage{spanish}{ es el cuerpo de la función. Si el
cuerpo de la función es una declaración vacía, la función se denomina {\textquotedbl}función vacía{\textquotedbl}. La
declaración del valor de retorno de la función está contenida en el cuerpo de la función. Si no hay declaración de
devolución en }\foreignlanguage{spanish}{\textbf{bloque}}\foreignlanguage{spanish}{, la función devolverá
}\textstyleSourceText{\foreignlanguage{spanish}{nil}}\foreignlanguage{spanish}{ por defecto. El nombre de la función es
en realidad el nombre de la variable del objeto de la función vinculada. Si el nombre ya existe en el ámbito actual,
definir la función equivale a vincular el objeto de función a esta variable.}

\foreignlanguage{spanish}{El siguiente ejemplo define una función llamada
}\textstyleSourceText{\foreignlanguage{spanish}{add}}\foreignlanguage{spanish}{. La función de este ejemplo es sumar
dos números y devolver el resultado.}


\bigskip

{\selectlanguage{spanish}\ttfamily
def add(a, b)}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ return a + b}

{\selectlanguage{spanish}\ttfamily
end}


\bigskip

\foreignlanguage{spanish}{La función }\textstyleSourceText{\foreignlanguage{spanish}{add}}\foreignlanguage{spanish}{
tiene dos parámetros }\textstyleSourceText{\foreignlanguage{spanish}{a}}\foreignlanguage{spanish}{ y
}\textstyleSourceText{\foreignlanguage{spanish}{b}}\foreignlanguage{spanish}{, y los dos sumandos se pasan a la función
a través de estos parámetros para el cálculo. La instrucción
}\textstyleSourceText{\foreignlanguage{spanish}{return}}\foreignlanguage{spanish}{ devuelve el resultado del cálculo.}

{\selectlanguage{spanish}
Una función como atributo de clase se llama método. Esta parte del contenido se explicará en el capítulo orientado a
objetos.}

\paragraph[Función anónima]{\selectlanguage{spanish} Función anónima}
\hypertarget{RefHeadingToc356293639824055}{}{\selectlanguage{spanish}
A diferencia de las funciones con nombre, la \textbf{función anónima} no tiene nombre y su expresión de definición tiene
la forma:}


\bigskip

{\selectlanguage{spanish}\ttfamily
´def' ´(´ argumentos ´)´}

{\selectlanguage{spanish}\ttfamily
\ \ bloque}

{\selectlanguage{spanish}\ttfamily
´end'}


\bigskip

{\selectlanguage{spanish}
Se puede ver que, en comparación con las funciones con nombre, no hay un \textbf{nombre} de función en su definición..
La definición de una función anónima es esencialmente una expresión, que se denomina \textbf{Función literal}. Para
usar funciones anónimas podemos vincular el valor literal de la función a una variable:}


\bigskip

{\selectlanguage{spanish}\ttfamily
add = def (a, b)}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ return a + b}

{\selectlanguage{spanish}\ttfamily
end}


\bigskip

\foreignlanguage{spanish}{La función de este código es exactamente la misma que la función
}\textstyleSourceText{\foreignlanguage{spanish}{add}}\foreignlanguage{spanish}{ en la sección anterior. Se puede usar
una función anónima para pasar convenientemente el valor de la función como un valor literal. Al igual que otros tipos
de literales, los literales de función también son la unidad de expresión más pequeña. Por lo tanto, lo que hay entre
las palabras clave }\textstyleSourceText{\foreignlanguage{spanish}{def}}\foreignlanguage{spanish}{ y
}\textstyleSourceText{\foreignlanguage{spanish}{end}}\foreignlanguage{spanish}{ es un todo indivisible.}

\subsubsection[5.1.2 Llamada a Función]{\selectlanguage{spanish} 5.1.2 Llamada a Función}
\hypertarget{RefHeadingToc356313639824055}{}\foreignlanguage{spanish}{Tome la función
}\textstyleSourceText{\foreignlanguage{spanish}{add}}\foreignlanguage{spanish}{ como ejemplo. Para llamar a esta
función, debe proporcionar dos valores y puede obtener la suma de los dos números llamando a la función:}


\bigskip

{\selectlanguage{spanish}\ttfamily
res = add(5, 3)}

{\selectlanguage{spanish}\ttfamily
print(res) \# 8}


\bigskip

\foreignlanguage{spanish}{Llamamos a la función llamada (la función
}\textstyleSourceText{\foreignlanguage{spanish}{add}}\foreignlanguage{spanish}{ en el ejemplo) como
}\foreignlanguage{spanish}{\textbf{Función llamada}}\foreignlanguage{spanish}{, y la función que llama a la función
llamada (la función }\textstyleSourceText{\foreignlanguage{spanish}{principal}}\foreignlanguage{spanish}{ en el
ejemplo) como }\foreignlanguage{spanish}{\textbf{Función clave}}\foreignlanguage{spanish}{. El proceso de llamada de
función es el siguiente: Primero, el intérprete (implícitamente) inicializará la lista de parámetros formales de la
función llamada con la lista de argumentos y, al mismo tiempo, suspenderá la función de llamada y guardará su estado,
luego creará un entorno para la función llamada y ejecutará la función llamada.}

\foreignlanguage{spanish}{La función finalizará su ejecución cuando encuentre la instrucción
}\textstyleSourceText{\foreignlanguage{spanish}{return}}\foreignlanguage{spanish}{ y pase el valor de
}\foreignlanguage{spanish}{retorno a la función que llama. El intérprete destruirá el entorno de la función llamada
después de que regrese la función llamada, luego restaurará el entorno de la función que llama y continuará ejecutando
la función que llama. El valor de retorno de la función también es el resultado de la expresión de la llamada a la
función. El siguiente ejemplo define una función
}\textstyleSourceText{\foreignlanguage{spanish}{cuadrado}}\foreignlanguage{spanish}{ y vincula esta función a una
variable }\textstyleSourceText{\foreignlanguage{spanish}{f}}\foreignlanguage{spanish}{, y luego llama a la función
}\textstyleSourceText{\foreignlanguage{spanish}{cuadrado}}\foreignlanguage{spanish}{ a través de la variable
}\textstyleSourceText{\foreignlanguage{spanish}{f}}\foreignlanguage{spanish}{. Este uso es similar a los punteros de
función en lenguaje C.}


\bigskip

{\selectlanguage{spanish}\ttfamily
def cuadrado(n)}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ return n * n}

{\selectlanguage{spanish}\ttfamily
end}

{\selectlanguage{spanish}\ttfamily
f = cuadrado}

{\selectlanguage{spanish}\ttfamily
print(f(5)) \# 25}


\bigskip

{\selectlanguage{spanish}
Cabe señalar que el objeto de la función solo está vinculado a estas variables (consulte la sección Capitulo-3: Operador
de asignación}


\bigskip

{\selectlanguage{spanish}\ttfamily
f = cuadrado}

{\selectlanguage{spanish}\ttfamily
cuadrado = nil}

{\selectlanguage{spanish}\ttfamily
print(f(5)) \# 25}


\bigskip

\foreignlanguage{spanish}{Se puede ver que la función todavía se puede llamar normalmente después de reasignar
}\textstyleSourceText{\foreignlanguage{spanish}{cuadrado}}\foreignlanguage{spanish}{. Solo después de que el objeto de
función ya no esté vinculado a ninguna variable, se perderá y el sistema reciclará los recursos ocupados por este tipo
de objeto de función.}

\paragraph[Desviar la llamada]{\selectlanguage{spanish} Desviar la llamada}
\hypertarget{RefHeadingToc356333639824055}{}{\selectlanguage{spanish}
La llamada de la función debe estar en el ámbito de la variable de función, por lo que normalmente no se puede llamar
antes de que se defina la función. Para resolver este problema, puede utilizar este método para comprometer:}


\bigskip

{\selectlanguage{spanish}\ttfamily
var func1}

{\selectlanguage{spanish}\ttfamily
def func2(x)}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ return func1(x)}

{\selectlanguage{spanish}\ttfamily
end}

{\selectlanguage{spanish}\ttfamily
def func1(x)}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ return x * x}

{\selectlanguage{spanish}\ttfamily
end}

{\selectlanguage{spanish}\ttfamily
print(func2(4)) \# 16}


\bigskip

\foreignlanguage{spanish}{En este ejemplo,
}\textstyleSourceText{\foreignlanguage{spanish}{func2}}\foreignlanguage{spanish}{ llama a
}\textstyleSourceText{\foreignlanguage{spanish}{func1}}\foreignlanguage{spanish}{, pero la función
}\textstyleSourceText{\foreignlanguage{spanish}{func1}}\foreignlanguage{spanish}{ se define después de
}\textstyleSourceText{\foreignlanguage{spanish}{func2}}\foreignlanguage{spanish}{. Después de ejecutar este código, el
programa generará el resultado correcto }\textstyleSourceText{\foreignlanguage{spanish}{16}}\foreignlanguage{spanish}{.
Esta rutina utiliza el mecanismo de que no se llamará a la función cuando se defina. Defina la variable
}\textstyleSourceText{\foreignlanguage{spanish}{func1}}\foreignlanguage{spanish}{ antes de definir
}\textstyleSourceText{\foreignlanguage{spanish}{func2}}\foreignlanguage{spanish}{ para asegurarse de que el símbolo
}\textstyleSourceText{\foreignlanguage{spanish}{func1}}\foreignlanguage{spanish}{ no se encontrará durante la
compilación. Luego definimos la función
}\textstyleSourceText{\foreignlanguage{spanish}{func1}}\foreignlanguage{spanish}{ después de
}\textstyleSourceText{\foreignlanguage{spanish}{func2}}\foreignlanguage{spanish}{ para que la función se use para
sobrescribir el valor de la variable }\textstyleSourceText{\foreignlanguage{spanish}{func1}}\foreignlanguage{spanish}{.
Cuando se llama a la función }\textstyleSourceText{\foreignlanguage{spanish}{func2}}\foreignlanguage{spanish}{ en la
última línea }\textstyleSourceText{\foreignlanguage{spanish}{print(func2(4))}}\foreignlanguage{spanish}{, la variable
}\textstyleSourceText{\foreignlanguage{spanish}{func1}}\foreignlanguage{spanish}{ ya es la función que necesitamos, por
lo que se mostrará el resultado correcto.}

\paragraph[Llamada recursiva]{\selectlanguage{spanish} Llamada recursiva}
\hypertarget{RefHeadingToc356353639824055}{}{\selectlanguage{spanish}
Con \textbf{función recursiva} se refiere a funciones que se llaman a sí mismas directa o indirectamente. La
recursividad se refiere a una estrategia que divide el problema en subproblemas similares y luego los resuelve. Tomando
el factorial como ejemplo, la definición recursiva de factorial es 0! = 1, \textit{n}! = \textit{n} ${\cdot}$
(\textit{n}$-$1)!. Entonces podemos escribir la función recursiva para calcular el factorial según la definición:}


\bigskip

{\selectlanguage{spanish}\ttfamily
def fact(n)}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ if n == 0}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ return 1}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ end}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ return n * fact(n-1)}

{\selectlanguage{spanish}\ttfamily
end}


\bigskip

\foreignlanguage{spanish}{Tome el factorial de 5 como ejemplo, el proceso de calcular manualmente el factorial de 5 es:
¡5! = 5 {\texttimes} 4 {\texttimes} 3 {\texttimes} 2 {\texttimes} 1 = 120. El resultado de llamar a la función
}\textstyleSourceText{\foreignlanguage{spanish}{fact}}\foreignlanguage{spanish}{ también es 120:}


\bigskip

{\selectlanguage{spanish}\ttfamily
print(fact(5)) \# 120}


\bigskip

\foreignlanguage{spanish}{Para garantizar que la profundidad de la llamada recursiva sea limitada (un nivel de
recursividad demasiado profundo agotará el espacio de la pila), la función recursiva debe tener una condición de
finalización. En }\textstyleSourceText{\foreignlanguage{spanish}{fact}}\foreignlanguage{spanish}{ la declaración
}\textstyleSourceText{\foreignlanguage{spanish}{if}}\foreignlanguage{spanish}{ en la segunda línea de la definición de
la función se usa para detectar la condición final, y el proceso recursivo finaliza cuando
}\textstyleSourceText{\foreignlanguage{spanish}{n}}\foreignlanguage{spanish}{ se calcula como
}\textstyleSourceText{\foreignlanguage{spanish}{0}}\foreignlanguage{spanish}{. La fórmula factorial anterior no se
aplica a parámetros no enteros. Ejecutar una expresión como
}\textstyleSourceText{\foreignlanguage{spanish}{fact(5.1)}}\foreignlanguage{spanish}{ provocará un error de
desbordamiento de pila debido a la imposibilidad de finalizar la recursividad.}

\foreignlanguage{spanish}{Existe otra situación, la }\textstyleSourceText{\foreignlanguage{spanish}{Recurrencia
indirecta}}\foreignlanguage{spanish}{, es decir, la función no es llamada por sí misma sino por otra función (directa o
indirectamente) llamada por ella. La recursividad indirecta generalmente requiere el uso de técnicas de llamada de
función hacia adelante. Tome las funciones
}\textstyleSourceText{\foreignlanguage{spanish}{es\_impar}}\foreignlanguage{spanish}{ y
}\textstyleSourceText{\foreignlanguage{spanish}{es\_par}}\foreignlanguage{spanish}{ para calcular números pares e
impares como ejemplos:}


\bigskip

{\selectlanguage{spanish}\ttfamily
var es\_impar}

{\selectlanguage{spanish}\ttfamily
def es\_par(n)}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ if n == 0}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ return true}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ end}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ return es\_impar(n-1)}

{\selectlanguage{spanish}\ttfamily
end}

{\selectlanguage{spanish}\ttfamily
def es\_impar(n)}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ if n == 0}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ return false}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ end}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ return es\_par(n-1)}

{\selectlanguage{spanish}\ttfamily
end}


\bigskip

\foreignlanguage{spanish}{Estas dos funciones se llaman entre sí. Para garantizar que este nombre esté en el alcance
cuando se llama a la función }\textstyleSourceText{\foreignlanguage{spanish}{es\_impar}}\foreignlanguage{spanish}{ en
la línea 6, la variable }\textstyleSourceText{\foreignlanguage{spanish}{es\_impar}}\foreignlanguage{spanish}{ se define
en la línea 1.}

\paragraph[Llamada de función anónima]{\selectlanguage{spanish} Llamada de función anónima}
\hypertarget{RefHeadingToc356373639824055}{}{\selectlanguage{spanish}
Si una función anónima solo se llamará una vez, la forma más fácil es llamarla cuando esté definida, por ejemplo:}


\bigskip

{\selectlanguage{spanish}\ttfamily
res = def (a, b) return a + b end (1, 2) \# 3}


\bigskip

{\selectlanguage{spanish}
En esta rutina, usamos la expresión de llamada directamente después del literal de función para llamar a la función.
Este uso es muy adecuado para funciones que solo se llamarán en un lugar.}

{\selectlanguage{spanish}
También puede vincular una función anónima a una variable y llamarla:}


\bigskip

{\selectlanguage{spanish}\ttfamily
add = def (a, b) return a + b end}

{\selectlanguage{spanish}\ttfamily
res = add(1, 2) \# 3}


\bigskip

{\selectlanguage{spanish}
Este uso es similar a la llamada de una función con nombre, esencialmente llamando a la variable vinculada al valor de
la función. Cabe señalar que es más difícil realizar llamadas recursivas a funciones anónimas, a menos que utilice
técnicas de llamada de reenvío.}

\subsubsection[5.1.3 Parámetros formales y reales]{\selectlanguage{spanish} 5.1.3 Parámetros formales y reales}
\hypertarget{RefHeadingToc356393639824055}{}\foreignlanguage{spanish}{La función utiliza parámetros reales para
inicializar los parámetros formales cuando se llama. En circunstancias normales, el parámetro real y el parámetro de
forma son iguales y las posiciones se corresponden entre sí, pero Berry también permite que el parámetro real sea
diferente del parámetro formal: si el parámetro real es mayor que el parámetro formal, el parámetro real adicional al
parámetro será descartado. De otra forma los parámetros formales restantes se inicializarán a
}\textstyleSourceText{\foreignlanguage{spanish}{nil}}\foreignlanguage{spanish}{.}

\foreignlanguage{spanish}{El proceso de paso de parámetros es similar a la operación de asignación. Para los tipos
}\textstyleSourceText{\foreignlanguage{spanish}{nil}}\foreignlanguage{spanish}{,
}\textstyleSourceText{\foreignlanguage{spanish}{boolean}}\foreignlanguage{spanish}{ y numéricos, el paso de parámetros
es por valor, mientras que otros tipos son por referencia. Para el tipo de referencia de paso de escritura, como una
instancia, modificarlos en la función llamada también modificará el objeto en la función de llamada. El siguiente
ejemplo demuestra esta función:}


\bigskip

{\selectlanguage{spanish}\ttfamily
var l = [], i = 0}

{\selectlanguage{spanish}\ttfamily
def func(a, b)}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ a.push(1)}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ b ='cadena'}

{\selectlanguage{spanish}\ttfamily
end}

{\selectlanguage{spanish}\ttfamily
func(l, i)}

{\selectlanguage{spanish}\ttfamily
print(l, i) \# [1] 0}


\bigskip

\foreignlanguage{spanish}{Se puede ver que el valor de la variable
}\textstyleSourceText{\foreignlanguage{spanish}{l}}\foreignlanguage{spanish}{ ha cambiado después de llamar a la
función }\textstyleSourceText{\foreignlanguage{spanish}{func}}\foreignlanguage{spanish}{, pero el valor de la variable
}\textstyleSourceText{\foreignlanguage{spanish}{i}}\foreignlanguage{spanish}{ no ha cambiado.}

\subsubsection[Función con número variable de argumentos (vararg)]{\selectlanguage{spanish} Función con número variable
de argumentos (vararg)}
\hypertarget{RefHeadingToc356413639824055}{}\foreignlanguage{spanish}{Puede definir una función para tomar cualquier
número arbitrario de argumentos e iterarlos. Por ejemplo,
}\textstyleSourceText{\foreignlanguage{spanish}{print()}}\foreignlanguage{spanish}{ toma cualquier cantidad de
argumentos e imprime cada uno de ellos separados por espacios. Debe definir el último argumento como una captura de
todos los }\foreignlanguage{spanish}{argumentos usando
}\textstyleSourceText{\foreignlanguage{spanish}{*}}\foreignlanguage{spanish}{ antes de su nombre.}

\foreignlanguage{spanish}{Todos los argumentos que siguen a los argumentos formales se agrupan en tiempo de ejecución en
una instancia de }\textstyleSourceText{\foreignlanguage{spanish}{list}}\foreignlanguage{spanish}{. Si no se capturan
argumentos, la lista está vacía.}

{\selectlanguage{spanish}
Ejemplo:}


\bigskip

{\selectlanguage{spanish}\ttfamily
def f(a, b, *c) return size(c) end}

{\selectlanguage{spanish}\ttfamily
f(1,2) \# devuelve 0, c is []}

{\selectlanguage{spanish}\ttfamily
f(1,2,3) \# devuelve 1, c is [3]}

{\selectlanguage{spanish}\ttfamily
f(1,2,3,4) \# devuelve 2, c is [3,4]}

\subsubsection[Llamar a una función con un número dinámico de argumentos]{\selectlanguage{spanish} Llamar a una función
con un número dinámico de argumentos}
\hypertarget{RefHeadingToc356433639824055}{}\foreignlanguage{spanish}{La sintaxis de Berry solo permite llamar con un
número fijo de argumentos. Utilice la función }\textstyleSourceText{\foreignlanguage{spanish}{call(f,
[args])}}\foreignlanguage{spanish}{ para pasar cualquier número de argumentos arbitrario.}

\foreignlanguage{spanish}{Puede agregar estáticamente cualquier número de argumentos a
}\textstyleSourceText{\foreignlanguage{spanish}{call()}}\foreignlanguage{spanish}{. Si el último argumento es una
}\textstyleSourceText{\foreignlanguage{spanish}{lista}}\foreignlanguage{spanish}{, se expande automáticamente a
argumentos discretos.}

{\selectlanguage{spanish}
Ejemplo:}


\bigskip

{\selectlanguage{spanish}\ttfamily
def f(a,b) return nil end}


\bigskip

{\selectlanguage{spanish}\ttfamily
call(f,1) \ \ \ \ \ \ \ \# llama a f(1)}

{\selectlanguage{spanish}\ttfamily
call(f,1,2) \ \ \ \ \ \# llama a f(1,2)}

{\selectlanguage{spanish}\ttfamily
call(f,1,2,3) \ \ \ \# llama a f(1,2,3), el último argumento es ignorado por f}

{\selectlanguage{spanish}\ttfamily
call(f,1,[2,3]) \ \# llama a f(1,2,3), el último argumento es ignorado por f}

{\selectlanguage{spanish}\ttfamily
call(f,[1,2]) \ \ \ \# llama a f(1,2)}

{\selectlanguage{spanish}\ttfamily
call(f,[]) \ \ \ \ \ \ \# llama a f()}


\bigskip

\foreignlanguage{spanish}{Puede combinar
}\textstyleSourceText{\foreignlanguage{spanish}{call}}\foreignlanguage{spanish}{ y vararg. Por ejemplo, creemos una
función que actúe como }\textstyleSourceText{\foreignlanguage{spanish}{print()}}\foreignlanguage{spanish}{ pero
convierta todos los argumentos a mayúsculas.}

{\selectlanguage{spanish}
Ejemplo completo:}


\bigskip

{\selectlanguage{spanish}\ttfamily
def print\_upper(*a) \# toma un número arbitrario de argumentos, args es una lista}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ import string}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ for i:0..size(a)-1}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ if type(a[i]) == 'string'}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ \ \ \ \ a[i] = string.toupper(a[i])}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ end}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ end}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ call(print, a) \# \ llama a print con todos los argumentos}

{\selectlanguage{spanish}\ttfamily
end}


\bigskip

{\selectlanguage{spanish}\ttfamily
print\_upper({\textquotedbl}a{\textquotedbl},1,{\textquotedbl}Foo{\textquotedbl},{\textquotedbl}Bar{\textquotedbl}) \ \#
imprime: A 1 FOO BAR}

\subsubsection[5.1.4 Funciones y variables locales]{\selectlanguage{spanish} 5.1.4 Funciones y variables locales}
\hypertarget{RefHeadingToc356453639824055}{}{\selectlanguage{spanish}
El cuerpo de la función en sí es un ámbito, por lo que las variables definidas en la función son todas variables
locales. A diferencia de los bloques directamente anidados, cada vez que se llama a una función, se asigna espacio para
las variables locales. El espacio para las variables locales se asigna en la pila y la información de asignación se
determina en el momento de la compilación, por lo que este proceso es muy rápido. Cuando se anidan varios niveles de
alcance en una función, el intérprete asigna espacio de pila para la cadena de anidamiento de alcance con la mayoría de
las variables locales, en lugar del número total de variables locales en la función.}

\subsubsection[5.1.5 Declaración return]{\foreignlanguage{spanish}{5.1.5 }\foreignlanguage{spanish}{Declaración
}\textstyleSourceText{\foreignlanguage{spanish}{return}}}
\hypertarget{RefHeadingToc356473639824055}{}\foreignlanguage{spanish}{La declaración
}\textstyleSourceText{\foreignlanguage{spanish}{return}}\foreignlanguage{spanish}{ se utiliza para devolver el
resultado de una función, es decir, el valor de retorno de la función. Todas las funciones en Berry tienen un valor de
retorno, pero no puede usar ninguna declaración
}\textstyleSourceText{\foreignlanguage{spanish}{return}}\foreignlanguage{spanish}{ en el cuerpo de la función. En este
momento, el intérprete generará una declaración
}\textstyleSourceText{\foreignlanguage{spanish}{return}}\foreignlanguage{spanish}{ predeterminada para garantizar que
la función regrese }\textstyleSourceText{\foreignlanguage{spanish}{return}}\foreignlanguage{spanish}{. Hay dos formas
de escribir Sentencias:}


\bigskip

{\selectlanguage{spanish}\ttfamily
´return'}

{\selectlanguage{spanish}\ttfamily
´return' expresión}


\bigskip

\foreignlanguage{spanish}{La primera forma de escribir es escribir solo la palabra clave
}\textstyleSourceText{\foreignlanguage{spanish}{return}}\foreignlanguage{spanish}{ y no la expresión que se devolverá.
En este caso, se devuelve el valor }\textstyleSourceText{\foreignlanguage{spanish}{nil}}\foreignlanguage{spanish}{
predeterminado. La segunda forma de escribir es seguir la expresión
}\foreignlanguage{spanish}{\textbf{expresión}}\foreignlanguage{spanish}{ después de la palabra clave
}\textstyleSourceText{\foreignlanguage{spanish}{return}}\foreignlanguage{spanish}{, y el valor de la expresión se usará
como valor de retorno de la función. Cuando el programa ejecuta la declaración
}\textstyleSourceText{\foreignlanguage{spanish}{return}}\foreignlanguage{spanish}{, la función que se está ejecutando
actualmente finalizará la ejecución y volverá al código que llamó a la función para continuar ejecutándose.}

\foreignlanguage{spanish}{Cuando se usa una palabra clave separada
}\textstyleSourceText{\foreignlanguage{spanish}{return}}\foreignlanguage{spanish}{ como declaración de retorno de una
función, es fácil causar ambigüedad. En ese caso se recomienda agregar un punto y coma después de
}\textstyleSourceText{\foreignlanguage{spanish}{return}}\foreignlanguage{spanish}{ para evitar errores:}


\bigskip

{\selectlanguage{spanish}\ttfamily
def func()}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ return;}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ x = 1}

{\selectlanguage{spanish}\ttfamily
end}


\bigskip

\foreignlanguage{spanish}{En este ejemplo, la declaración }\textstyleSourceText{\foreignlanguage{spanish}{x =
1}}\foreignlanguage{spanish}{ después de la declaración
}\textstyleSourceText{\foreignlanguage{spanish}{return}}\foreignlanguage{spanish}{ no se ejecutará, por lo que es
redundante. Si se evita este tipo de código redundante, la instrucción
}\textstyleSourceText{\foreignlanguage{spanish}{return}}\foreignlanguage{spanish}{ suele ir seguida de palabras clave
como }\textstyleSourceText{\foreignlanguage{spanish}{end}}\foreignlanguage{spanish}{,
}\textstyleSourceText{\foreignlanguage{spanish}{else}}\foreignlanguage{spanish}{ o
}\textstyleSourceText{\foreignlanguage{spanish}{elif}}\foreignlanguage{spanish}{. En este caso, incluso si se usa una
declaración }\textstyleSourceText{\foreignlanguage{spanish}{return}}\foreignlanguage{spanish}{ por separado, no hay
necesidad de preocuparse por la ambigüedad.}

\subsection[5.2 Cierre (closure)]{\selectlanguage{spanish} 5.2 Cierre (closure)}
\hypertarget{RefHeadingToc356493639824055}{}\subsubsection[5.2.1 Conceptos básicos]{\selectlanguage{spanish} 5.2.1
Conceptos básicos}
\hypertarget{RefHeadingToc356513639824055}{}{\selectlanguage{spanish}
Como se mencionó anteriormente, las funciones son el primer tipo de valor en Berry. Puede definir funciones en cualquier
lugar y también puede pasar funciones como parámetros o devolver valores. Cuando se define otra función en una función,
la función anidada puede acceder a las variables locales de cualquier función externa. Llamamos a las
{\textquotedbl}variables locales de la función externa{\textquotedbl} utilizadas en la función la función como
\textbf{Variables libres}. Las variables libres generalizadas también incluyen variables globales, pero no existe tal
regla en Berry. El \textbf{Cierre} es una técnica que vincula funciones a \textbf{entornos}. El entorno es un mapeo que
asocia cada variable libre de una función con un valor. En términos de implementación, los cierres asocian el prototipo
de función con sus propias variables. Los prototipos de funciones se generan en tiempo de compilación y el entorno es
un concepto de tiempo de ejecución, por lo que los cierres también se generan dinámicamente en tiempo de ejecución.
Cada cierre vincula el prototipo de función al entorno cuando se genera, como se ve en el siguiente ejemplo:}


\bigskip

{\selectlanguage{spanish}\ttfamily
def func(i) \# La función externa}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ def foo() \# La función interna (closure)}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ print(i)}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ end}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ foo()}

{\selectlanguage{spanish}\ttfamily
end}


\bigskip

\foreignlanguage{spanish}{La función interna
}\textstyleSourceText{\foreignlanguage{spanish}{foo}}\foreignlanguage{spanish}{ es un cierre y tiene una variable libre
}\textstyleSourceText{\foreignlanguage{spanish}{i}}\foreignlanguage{spanish}{, que es un parámetro de la función
externa }\textstyleSourceText{\foreignlanguage{spanish}{func}}\foreignlanguage{spanish}{. Cuando se genera el cierre
}\textstyleSourceText{\foreignlanguage{spanish}{foo}}\foreignlanguage{spanish}{, su prototipo de función se vincula al
entorno que contiene la variable libre }\textstyleSourceText{\foreignlanguage{spanish}{i}}\foreignlanguage{spanish}{.
Cuando la variable }\textstyleSourceText{\foreignlanguage{spanish}{foo}}\foreignlanguage{spanish}{ sale del alcance, el
cierre se destruirá. Por lo general, la función interna será el valor de retorno de la función externa, por ejemplo:}


\bigskip

{\selectlanguage{spanish}\ttfamily
def func(i) \# La función externa}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ return def () \# Devuelve un cierre (función anónima)}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ print(i)}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ i = i + 1}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ end}

{\selectlanguage{spanish}\ttfamily
end}


\bigskip

\foreignlanguage{spanish}{El cierre devuelto aquí es una función anónima. Cuando la función externa devuelve el cierre,
las variables locales de la función externa se destruirán y el cierre no podrá acceder directamente a las variables en
la función externa original. El sistema copiará el valor de la variable libre al entorno cuando se destruya la variable
libre. El ciclo de vida de estas variables libres es el mismo que el del cierre, y solo el cierre puede acceder a
ellas. La función o el cierre devuelto no se ejecutará automáticamente, por lo que debemos llamar al cierre devuelto
por la función }\textstyleSourceText{\foreignlanguage{spanish}{func}}\foreignlanguage{spanish}{:}


\bigskip

{\selectlanguage{spanish}\ttfamily
f = func(0)}

{\selectlanguage{spanish}\ttfamily
f()}


\bigskip

\foreignlanguage{spanish}{Este código generará
}\textstyleSourceText{\foreignlanguage{spanish}{0}}\foreignlanguage{spanish}{. Si continuamos llamando al cierre
}\textstyleSourceText{\foreignlanguage{spanish}{f}}\foreignlanguage{spanish}{, obtendremos la salida
}\textstyleSourceText{\foreignlanguage{spanish}{1}}\foreignlanguage{spanish}{,
}\textstyleSourceText{\foreignlanguage{spanish}{2}}\foreignlanguage{spanish}{,
}\textstyleSourceText{\foreignlanguage{spanish}{3}}\foreignlanguage{spanish}{... Esto puede no entenderse bien: la
variable [2.198 ] se destruye después de que la función
}\textstyleSourceText{\foreignlanguage{spanish}{func}}\foreignlanguage{spanish}{ regresa , y como la variable libre del
cierre }\textstyleSourceText{\foreignlanguage{spanish}{f}}\foreignlanguage{spanish}{,
}\textstyleSourceText{\foreignlanguage{spanish}{i}}\foreignlanguage{spanish}{ se almacenará en el entorno de cierre,
por lo que cada vez que se llame a }\textstyleSourceText{\foreignlanguage{spanish}{f}}\foreignlanguage{spanish}{, el
valor de }\textstyleSourceText{\foreignlanguage{spanish}{i}}\foreignlanguage{spanish}{ se sumará a 1 (definición de la
función }\textstyleSourceText{\foreignlanguage{spanish}{func}}\foreignlanguage{spanish}{ línea 4).}

\paragraph[Uso de cierres]{\selectlanguage{spanish} Uso de cierres}
\hypertarget{RefHeadingToc356533639824055}{}{\selectlanguage{spanish}
Los cierres tienen muchos usos. Aquí hay algunos usos comunes:}

\subparagraph[Evaluación perezosa]{\selectlanguage{spanish} Evaluación perezosa}
\hypertarget{RefHeadingToc356553639824055}{}{\selectlanguage{spanish}
El cierre no hace nada hasta que se llama.}

\subparagraph[Función de comunicación privada]{\selectlanguage{spanish} Función de comunicación privada}
\hypertarget{RefHeadingToc356573639824055}{}{\selectlanguage{spanish}
Puede permitir que algunos cierres compartan variables libres, que solo son visibles para estos cierres, y se comuniquen
entre funciones cambiando los valores de estas variables libres. Esto puede evitar el uso de variables externas.}

\subparagraph[Generar múltiples funciones]{\selectlanguage{spanish} Generar múltiples funciones}
\hypertarget{RefHeadingToc356593639824055}{}{\selectlanguage{spanish}
A veces es posible que necesitemos usar múltiples funciones, estas funciones pueden tener solo diferentes valores de
algunas variables. Podemos implementar una función y luego usar estas diferentes variables como parámetros de función.
Una mejor manera es devolver el cierre a través de una función de fábrica y usar estas variables posiblemente
diferentes como variables libres del cierre, de modo que no siempre tenga que escribir esos parámetros al llamar a la
función, y cualquier número de funciones similares puede ser generado.}

\subparagraph[Simular miembros privados]{\selectlanguage{spanish} Simular miembros privados}
\hypertarget{RefHeadingToc356613639824055}{}{\selectlanguage{spanish}
Algunos lenguajes admiten el uso de miembros privados en objetos, pero la clase de Berry no lo admite. Podemos usar las
variables libres de los cierres para simular miembros privados. Este uso no es la intención original de diseñar
cierres, pero hoy en día, este {\textquotedbl}mal uso{\textquotedbl} de los cierres es muy común.}

\subparagraph[Resultado de caché]{\selectlanguage{spanish} Resultado de caché}
\hypertarget{RefHeadingToc356633639824055}{}{\selectlanguage{spanish}
Si hay una función que requiere mucho tiempo para ejecutarse, llevará mucho tiempo llamarla cada vez. Podemos almacenar
en caché el resultado de esta función, buscarlo en el caché antes de llamar a la función y devolver el valor almacenado
en caché si lo encuentra; de lo contrario, se llama a la función y se actualiza el valor almacenado en caché. Podemos
usar los cierres para guardar el valor almacenado en caché para que no quede expuesto al alcance externo, y el
resultado almacenado en caché se conservará (hasta que se destruya el cierre).}

\subsubsection[5.2.2 Vinculación de variables libres]{\selectlanguage{spanish} 5.2.2 Vinculación de variables libres}
\hypertarget{RefHeadingToc356653639824055}{}{\selectlanguage{spanish}
Si varios cierres vinculan la misma variable libre, todos los cierres siempre compartirán esta variable libre. Por
ejemplo:}


\bigskip

{\selectlanguage{spanish}\ttfamily
def func(i) \# La función externa}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ return [\# Devuelve la lista de cierre}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ def () \# El cierre \#1}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ \ \ \ \ print({\textquotedbl}cierre 1 log:{\textquotedbl}, i)}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ \ \ \ \ i = i + 1}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ end,}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ def () \# El cierre \#2}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ \ \ \ \ print({\textquotedbl}cierre 2 log:{\textquotedbl}, i)}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ \ \ \ \ i = i + 1}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ end}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ ]}

{\selectlanguage{spanish}\ttfamily
end}


\bigskip

\foreignlanguage{spanish}{La función }\textstyleSourceText{\foreignlanguage{spanish}{func}}\foreignlanguage{spanish}{,
en este ejemplo, devuelve dos cierres a través de una lista, y estos dos cierres comparten la variable libres
}\textstyleSourceText{\foreignlanguage{spanish}{i}}\foreignlanguage{spanish}{. Si llamamos a estos cierres:}


\bigskip

{\selectlanguage{spanish}\ttfamily
f = func(0)}

{\selectlanguage{spanish}\ttfamily
f[0]() \# cierre 1 log: 0}

{\selectlanguage{spanish}\ttfamily
f[1]() \# cierre 2 log: 1}


\bigskip

\foreignlanguage{spanish}{Como puede ver, actualizamos la variable libre
}\textstyleSourceText{\foreignlanguage{spanish}{i}}\foreignlanguage{spanish}{ cuando llamamos al cierre
}\textstyleSourceText{\foreignlanguage{spanish}{f[0]}}\foreignlanguage{spanish}{, y este cambio afectó el resultado de
llamar al cierre }\textstyleSourceText{\foreignlanguage{spanish}{f[1]}}\foreignlanguage{spanish}{. Esto se debe a que
si varios cierres utilizan una variable libre, solo hay una copia de la variable libre y todos los cierres tienen una
referencia a la entidad de variable libre. Por lo tanto, cualquier modificación a la variable libre es visible para
todos los cierres que usan dicha variable.}

{\selectlanguage{spanish}
De manera similar, antes de que se destruyan las variables locales de la función externa, modificar el valor de la
variable libre también afectará el cierre:}


\bigskip

{\selectlanguage{spanish}\ttfamily
def func()}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ i = 0}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ def foo()}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ print(i)}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ end}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ i = 1}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ return foo}

{\selectlanguage{spanish}\ttfamily
end}


\bigskip

\foreignlanguage{spanish}{En este ejemplo cambiamos el valor de la variable
}\textstyleSourceText{\foreignlanguage{spanish}{i}}\foreignlanguage{spanish}{ (que es la variable libre del cierre
}\textstyleSourceText{\foreignlanguage{spanish}{foo}}\foreignlanguage{spanish}{) de
}\textstyleSourceText{\foreignlanguage{spanish}{0}}\foreignlanguage{spanish}{ a
}\textstyleSourceText{\foreignlanguage{spanish}{1}}\foreignlanguage{spanish}{ antes de que regrese la función externa
}\textstyleSourceText{\foreignlanguage{spanish}{func}}\foreignlanguage{spanish}{, luego llamamos al cierre, y después
el valor de la variable libre }\textstyleSourceText{\foreignlanguage{spanish}{i}}\foreignlanguage{spanish}{ cuando el
paquete }\textstyleSourceText{\foreignlanguage{spanish}{foo}}\foreignlanguage{spanish}{ también es
}\textstyleSourceText{\foreignlanguage{spanish}{1}}\foreignlanguage{spanish}{:}


\bigskip

{\selectlanguage{spanish}\ttfamily
func()() \# 1}

\subsubsection[5.2.3 Crear cierre en bucle]{\selectlanguage{spanish} 5.2.3 Crear cierre en bucle}
\hypertarget{RefHeadingToc356673639824055}{}\foreignlanguage{spanish}{Al construir un cierre en el cuerpo del ciclo, es
posible que no desee que las variables libres del cierre cambien con las variables del ciclo. Primero veamos un ejemplo
de cómo crear un cierre en un bucle }\textstyleSourceText{\foreignlanguage{spanish}{while}}\foreignlanguage{spanish}{:}


\bigskip

{\selectlanguage{spanish}\ttfamily
def func()}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ l = [] i = 0}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ while i {\textless}= 2}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ l.push(def () print(i) end)}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ i = i + 1}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ end}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ return l}

{\selectlanguage{spanish}\ttfamily
end}


\bigskip

\foreignlanguage{spanish}{En este ejemplo, construimos un cierre en un ciclo y colocamos este cierre en una
}\textstyleSourceText{\foreignlanguage{spanish}{lista}}\foreignlanguage{spanish}{. Obviamente, cuando finalice el
ciclo, el valor de la variable }\textstyleSourceText{\foreignlanguage{spanish}{i}}\foreignlanguage{spanish}{ será
}\textstyleSourceText{\foreignlanguage{spanish}{3}}\foreignlanguage{spanish}{, y todos los cierres de la lista
}\textstyleSourceText{\foreignlanguage{spanish}{l}}\foreignlanguage{spanish}{ también son referencias usando esta
variable. Si ejecutamos el cierre devuelto por
}\textstyleSourceText{\foreignlanguage{spanish}{func}}\foreignlanguage{spanish}{ obtendremos el mismo resultado:}


\bigskip

{\selectlanguage{spanish}\ttfamily
res = func()}

{\selectlanguage{spanish}\ttfamily
res[0]() \# 3}

{\selectlanguage{spanish}\ttfamily
res[1]() \# 3}

{\selectlanguage{spanish}\ttfamily
res[2]() \# 3}


\bigskip

{\selectlanguage{spanish}
Si queremos que cada cierre se refiera a diferentes variables libres, podemos definir otra capa de funciones y luego
vincular las variables del ciclo actual con los parámetros de la función:}


\bigskip

{\selectlanguage{spanish}\ttfamily
def func()}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ l = [] i = 0}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ while i {\textless}= 2}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ l.push(def (n)}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ \ \ \ \ return def () print(n) end}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ end (i))}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ i = i + 1}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ end}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ return l}

{\selectlanguage{spanish}\ttfamily
end}


\bigskip

{\selectlanguage{spanish}
Para ayudar a entender este código aparentemente incomprensible, nos enfocaremos en el código de las líneas 4 a 6:}


\bigskip

{\selectlanguage{spanish}\ttfamily
def (n)}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ return def ()}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ print(n)}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ end}

{\selectlanguage{spanish}\ttfamily
end (i)}


\bigskip

\foreignlanguage{spanish}{Aquí realmente se define una función anónima y se llama inmediatamente. La función de esta
función anónima temporal es vincular el valor de la variable de bucle
}\textstyleSourceText{\foreignlanguage{spanish}{i}}\foreignlanguage{spanish}{ a su parámetro
}\textstyleSourceText{\foreignlanguage{spanish}{n}}\foreignlanguage{spanish}{, y la variable
}\textstyleSourceText{\foreignlanguage{spanish}{n}}\foreignlanguage{spanish}{ también es lo que necesitamos para cerrar
las variables libres del paquete, de modo que las las variables vinculadas al cierre construido durante cada ciclo son
diferentes. Ahora obtendremos la salida deseada:}


\bigskip

{\selectlanguage{spanish}\ttfamily
res = func()}

{\selectlanguage{spanish}\ttfamily
res[0]() \# 0}

{\selectlanguage{spanish}\ttfamily
res[1]() \# 1}

{\selectlanguage{spanish}\ttfamily
res[2]() \# 2}


\bigskip

{\selectlanguage{spanish}
Hay algunas formas de resolver el problema de las variables de bucle como variables libres. Una forma un poco más simple
es definir una variable temporal en el cuerpo del bucle:}


\bigskip

{\selectlanguage{spanish}\ttfamily
def func()}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ l = [] i = 0}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ while i {\textless}= 2}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ temp = i}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ l.push(def () print(temp) end)}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ i = i + 1}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ end}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ return l}

{\selectlanguage{spanish}\ttfamily
end}


\bigskip

\foreignlanguage{spanish}{Aquí }\textstyleSourceText{\foreignlanguage{spanish}{temp}}\foreignlanguage{spanish}{ es una
variable temporal. El alcance de esta variable está en el cuerpo del ciclo, por lo que se redefinirá cada vez que se
realice un ciclo. También podemos usar la instrucción
}\textstyleSourceText{\foreignlanguage{spanish}{for}}\foreignlanguage{spanish}{ para resolver el problema:}


\bigskip

{\selectlanguage{spanish}\ttfamily
def func()}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ l = []}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ for i: 0 .. 2}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ l.push(def () print(i) end)}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ end}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ return l}

{\selectlanguage{spanish}\ttfamily
end}


\bigskip

\foreignlanguage{spanish}{Esta puede ser la forma más sencilla
de}\textstyleSourceText{\foreignlanguage{spanish}{for}}\foreignlanguage{spanish}{. La variable de iteración de la
instrucción se creará en cada ciclo. El principio es similar al método anterior.}

\subsection[5.3 Expresión lambda]{\selectlanguage{spanish} 5.3 Expresión lambda}
\hypertarget{RefHeadingToc356693639824055}{}{\selectlanguage{spanish}
La \textbf{Expresión lambda} es una función anónima especial. La expresión lambda se compone de una lista de parámetros
y un cuerpo de función, pero la forma es diferente de la función general:}

{\selectlanguage{spanish}\ttfamily
´/´ args ´-{\textgreater}´ expr ´end'}

{\selectlanguage{spanish}
\textbf{args} es la lista de parámetros, la cantidad de parámetros puede ser cero o más, y los parámetros múltiples
están separados por comas o espacios (no se pueden mezclar al mismo tiempo); \textbf{expr} es la expresión de retorno,
la expresión lambda devolverá el valor de la expresión. Las expresiones lambda son adecuadas para implementar funciones
muy simples. Por ejemplo, la expresión lambda para juzgar el tamaño de dos números es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
/ a b -{\textgreater} a {\textless} b}


\bigskip

{\selectlanguage{spanish}
Esto es más fácil que escribir una función con la misma funcionalidad. En algunos algoritmos generales de clasificación,
este tipo de función de comparación de tamaño puede necesitar un uso extensivo. El uso de expresiones lambda puede
simplificar el código y mejorar la legibilidad.}

{\selectlanguage{spanish}
Al igual que las funciones generales, las expresiones lambda pueden formar cierres. Las expresiones lambda se llaman de
la misma manera que las funciones ordinarias. Si usa el método de llamada inmediata similar a las funciones anónimas:}


\bigskip

{\selectlanguage{spanish}\ttfamily
lambda = / a b -{\textgreater} a {\textless} b}

{\selectlanguage{spanish}\ttfamily
result = lambda(1, 2) \# \ llamada normal}

{\selectlanguage{spanish}\ttfamily
result = (/ a b -{\textgreater} a {\textless} b)(1, 2) \# \ llamada directa}


\bigskip

{\selectlanguage{spanish}
Dado que el operador de llamada de función tiene una prioridad más alta, se debe agregar un par de paréntesis a la
expresión lambda cuando se realiza una llamada directa, para que se llame como un todo.}

\clearpage\section{Capítulo 6: Funciones orientadas a objetos}
\hypertarget{RefHeadingToc356713639824055}{}
\bigskip

\foreignlanguage{spanish}{Por consideraciones de optimización, Berry no consideró los tipos simples como objetos. Estos
tipos simples incluyen }\textstyleSourceText{\foreignlanguage{spanish}{nil}}\foreignlanguage{spanish}{, numéricos,
booleanos y cadena. Pero Berry proporciona clases para implementar el mecanismo de objetos. Entre los tipos de datos
básicos de Berry, }\textstyleSourceText{\foreignlanguage{spanish}{list}}\foreignlanguage{spanish}{,
}\textstyleSourceText{\foreignlanguage{spanish}{map}}\foreignlanguage{spanish}{ y
}\textstyleSourceText{\foreignlanguage{spanish}{range}}\foreignlanguage{spanish}{ son objetos de clase. Un objeto es
una colección que contiene datos y métodos, donde los datos se componen de algunas variables y los métodos son
funciones. El tipo de un objeto se denomina clase y la entidad de un objeto se denomina instancia.}

\subsection[6.1 Clase e instancia]{\selectlanguage{spanish} 6.1 Clase e instancia}
\hypertarget{RefHeadingToc356733639824055}{}\subsubsection[6.1.1 Declaración de clase]{\selectlanguage{spanish} 6.1.1
Declaración de clase}
\hypertarget{RefHeadingToc356753639824055}{}\foreignlanguage{spanish}{Para usar una clase, primero debe declararla. La
declaración de una clase comienza con la palabra clave
}\textstyleSourceText{\foreignlanguage{spanish}{class}}\foreignlanguage{spanish}{. Las variables miembro y los métodos
de la clase deben especificarse en la declaración. Este es un ejemplo de declaración de una clase:}


\bigskip

{\selectlanguage{spanish}\ttfamily
class persona}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ static var mayor = 18}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ var nombre, edad}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ def init(nombre, edad)}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ self.nombre = name}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ self.edad = edad}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ end}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ def tostring()}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ return 'nombre: '+ str(self.nombre) + ', edad:' + str(self.edad)}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ end}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ def es\_adulto()}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ return self.edad {\textgreater}= self.mayor}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ end}

{\selectlanguage{spanish}\ttfamily
end}


\bigskip

\foreignlanguage{spanish}{Las variables miembro de clase se declaran con la palabra clave
}\textstyleSourceText{\foreignlanguage{spanish}{var}}\foreignlanguage{spanish}{, mientras que los métodos miembro se
declaran con la palabra clave }\textstyleSourceText{\foreignlanguage{spanish}{def}}\foreignlanguage{spanish}{.
Actualmente, Berry no admite la inicialización de variables miembro en el momento de la definición, por lo que el
constructor debe realizar la inicialización de las variables miembro. Las propiedades de la clase no se pueden
modificar después de completar la declaración, por lo que la clase es un objeto de solo lectura.}

\foreignlanguage{spanish}{Este diseño es para garantizar que la clase se pueda construir estáticamente en el lenguaje C
cuando se implemente el intérprete y se pueda usar la propiedad
}\textstyleSourceText{\foreignlanguage{spanish}{const}}\foreignlanguage{spanish}{ modificada para ahorrar RAM}

{\selectlanguage{spanish}
La clase de Berry no admite restricciones de acceso y todas las propiedades de la clase son visibles desde el exterior.
En las clases nativas, puede usar algunos trucos para hacer que las propiedades sean invisibles para el código Berry
(por lo general, hacer que el nombre del miembro comience con un punto {\textquotedbl}.{\textquotedbl}). Puede usar
algunas convenciones para restringir el acceso a los miembros de la clase, como la convención de que los atributos que
comienzan con un guión bajo son atributos privados. Esta convención no tiene ningún uso a nivel gramatical, pero
favorece la estructura lógica del código.}

\subsubsection[6.1.2 Instanciar]{\selectlanguage{spanish} 6.1.2 Instanciar}
\hypertarget{RefHeadingToc356773639824055}{}{\selectlanguage{spanish}
La clase en sí es solo una descripción abstracta. Tomando los autos como ejemplo, conozco el concepto de autos, y cuando
realmente queremos usar autos, necesitamos autos reales. El uso de las clases es similar. No solo usaremos esta
descripción abstracta, sino que necesitaremos producir un objeto concreto basado en esta descripción. Este proceso se
llama \textbf{Instanciación de la clase}, abreviado como instanciación, y el objeto concreto producido por la
instanciación se llama \textbf{Instancia}. La clase en sí no tiene datos, y la creación de instancias produce una
instancia basada en la información descrita por la clase y proporciona datos específicos a la instancia.}

\subsubsection[6.1.3 Método y parámetros self]{\foreignlanguage{spanish}{6.1.3 }\foreignlanguage{spanish}{Método y
parámetros }\textstyleSourceText{\foreignlanguage{spanish}{self}}}
\hypertarget{RefHeadingToc356793639824055}{}\foreignlanguage{spanish}{Los métodos de clase son esencialmente funciones.
A diferencia de las funciones ordinarias, los métodos pasan implícitamente un parámetro
}\textstyleSourceText{\foreignlanguage{spanish}{self}}\foreignlanguage{spanish}{, y siempre es el primer parámetro, que
almacena una referencia a la instancia actual. Debido a la existencia de parámetros
}\textstyleSourceText{\foreignlanguage{spanish}{self}}\foreignlanguage{spanish}{, el número de parámetros del método
será uno más que el número de parámetros definidos en la declaración. Aquí usamos un ejemplo simple para demostrar:}


\bigskip

{\selectlanguage{spanish}\ttfamily
class Test}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ def metodo()}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ return self}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ end}

{\selectlanguage{spanish}\ttfamily
end}

{\selectlanguage{spanish}\ttfamily
objecto = Test()}

{\selectlanguage{spanish}\ttfamily
print(objecto)}

{\selectlanguage{spanish}\ttfamily
print(objecto.metodo())}


\bigskip

\foreignlanguage{spanish}{Este ejemplo define una clase
}\textstyleSourceText{\foreignlanguage{spanish}{Test}}\foreignlanguage{spanish}{, que tiene un método
}\textstyleSourceText{\foreignlanguage{spanish}{metodo}}\foreignlanguage{spanish}{, que devuelve su parámetro
}\textstyleSourceText{\foreignlanguage{spanish}{self}}\foreignlanguage{spanish}{. Las dos últimas líneas de la rutina
imprimen el valor de la instancia 'objeto' de la clase
}\textstyleSourceText{\foreignlanguage{spanish}{Test}}\foreignlanguage{spanish}{ y el valor de retorno del método
'metodo' respectivamente. El resultado de ejecución de este ejemplo es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
{\textless}instance: Test(){\textgreater}}

{\selectlanguage{spanish}\ttfamily
{\textless}instance: Test(){\textgreater}}


\bigskip

\foreignlanguage{spanish}{Se puede ver que el parámetro
}\textstyleSourceText{\foreignlanguage{spanish}{self}}\foreignlanguage{spanish}{ del método y el nombre de la instancia
de uso (}\textstyleSourceText{\foreignlanguage{spanish}{objecto}}\foreignlanguage{spanish}{ en el ejemplo) representan
el mismo objeto y ambos son referencias de instancia. Use
}\textstyleSourceText{\foreignlanguage{spanish}{self}}\foreignlanguage{spanish}{ para acceder a los miembros o
atributos de la instancia en el método.}

\subsubsection[Métodos sintéticos]{\selectlanguage{spanish} Métodos sintéticos}
\hypertarget{RefHeadingToc356813639824055}{}{\selectlanguage{spanish}
Puede declarar métodos y miembros dinámicos sintéticos usando \textbf{Miembros virtuales} como se describe en el
Capítulo 8.2.}

\subsubsection[Variables de clase static]{\foreignlanguage{spanish}{Variables de clase
}\textstyleSourceText{\foreignlanguage{spanish}{static}}}
\hypertarget{RefHeadingToc356833639824055}{}\foreignlanguage{spanish}{Las variables o funciones se pueden declarar
}\textstyleSourceText{\foreignlanguage{spanish}{static}}\foreignlanguage{spanish}{. Las variables estáticas tienen el
mismo }\foreignlanguage{spanish}{valor para todas las instancias de la misma clase. Se declaran como
}\textstyleSourceText{\foreignlanguage{spanish}{static a = 1}}\foreignlanguage{spanish}{ o
}\textstyleSourceText{\foreignlanguage{spanish}{static var a = 1}}\foreignlanguage{spanish}{. Las variables estáticas
se inicializan justo después de la creación de la clase.}

\subsubsection[Métodos de clase static]{\foreignlanguage{spanish}{Métodos de clase
}\textstyleSourceText{\foreignlanguage{spanish}{static}}}
\hypertarget{RefHeadingToc356853639824055}{}\foreignlanguage{spanish}{Los métodos se pueden declarar
}\textstyleSourceText{\foreignlanguage{spanish}{static}}\foreignlanguage{spanish}{, lo que significa que actúan como
una función regular y no toman }\textstyleSourceText{\foreignlanguage{spanish}{self}}\foreignlanguage{spanish}{ como
primer argumento. Dentro de los métodos estáticos, no se declara ninguna variable {\textquotedbl}auto{\textquotedbl}
implícita. Los métodos estáticos se pueden llamar a través de la clase o a través de una instancia.}


\bigskip

{\selectlanguage{spanish}\ttfamily
{\textgreater} class static\_demo}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ static def incremento\_static(i)}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ \ \ return i + 1}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ end}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ def incremento\_instancia(i)}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ \ \ return i + 1}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ end}

{\selectlanguage{spanish}\ttfamily
\ \ end}

{\selectlanguage{spanish}\ttfamily
{\textgreater} a = static\_demo()}

{\selectlanguage{spanish}\ttfamily
{\textgreater} static\_demo.incremento\_static(1) \ \ \ \# llamada via clase}

{\selectlanguage{spanish}\ttfamily
2}

{\selectlanguage{spanish}\ttfamily
{\textgreater} a.incremento\_static(1) \ \ \ \ \ \ \ \ \ \ \ \ \ \# llamada via instancia}

{\selectlanguage{spanish}\ttfamily
{\textgreater}}

{\selectlanguage{spanish}\ttfamily
{\textgreater} static\_demo.incremento\_instancia(1)}

{\selectlanguage{spanish}\ttfamily
type\_error: unsupported operand type(s) for +: 'nil' and 'int'}

{\selectlanguage{spanish}\ttfamily
stack traceback:}

{\selectlanguage{spanish}\ttfamily
\ \ \ stdin:6: in function {\textasciigrave}increment\_instancia{\textasciigrave}}

{\selectlanguage{spanish}\ttfamily
\ \ \ stdin:1: in function {\textasciigrave}main{\textasciigrave}}

{\selectlanguage{spanish}\ttfamily
{\textgreater} a.increment\_instancia(1)}

{\selectlanguage{spanish}\ttfamily
2}

\subsubsection[6.1.4 Constructor y Destructor]{\selectlanguage{spanish} 6.1.4 Constructor y Destructor}
\hypertarget{RefHeadingToc356873639824055}{}\paragraph[Constructor]{\selectlanguage{spanish} Constructor}
\hypertarget{RefHeadingToc356893639824055}{}\foreignlanguage{spanish}{El constructor de la clase es el método
}\textstyleSourceText{\foreignlanguage{spanish}{init}}\foreignlanguage{spanish}{. Se llama al constructor cuando se
crea una instancia de la clase. Por lo tanto, el constructor generalmente se usa para la inicialización de miembros,
por ejemplo:}


\bigskip

{\selectlanguage{spanish}\ttfamily
class Test}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ var a}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ def init()}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ self.a ='esto es una prueba'}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ end}

{\selectlanguage{spanish}\ttfamily
end}


\bigskip

\foreignlanguage{spanish}{El constructor de este ejemplo inicializa el miembro
}\textstyleSourceText{\foreignlanguage{spanish}{a}}\foreignlanguage{spanish}{ de la clase
}\textstyleSourceText{\foreignlanguage{spanish}{Test}}\foreignlanguage{spanish}{ con la cadena
}\textstyleSourceText{\foreignlanguage{spanish}{{}'esto es una prueba'}}\foreignlanguage{spanish}{. Si instanciamos la
clase, podemos obtener el valor del miembro
}\textstyleSourceText{\foreignlanguage{spanish}{a}}\foreignlanguage{spanish}{:}


\bigskip

{\selectlanguage{spanish}\ttfamily
class Test}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ var a}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ def init()}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ self.a ='esta es una prueba'}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ end}

{\selectlanguage{spanish}\ttfamily
end}

\paragraph[Destructor]{\selectlanguage{spanish} Destructor}
\hypertarget{RefHeadingToc356913639824055}{}\foreignlanguage{spanish}{El destructor de la clase es el método
}\textstyleSourceText{\foreignlanguage{spanish}{deinit}}\foreignlanguage{spanish}{. Se llama al destructor cuando se
destruye la instancia. El destructor se usa generalmente para completar algún trabajo de limpieza. Debido a que el
mecanismo de recolección de basura libera automáticamente la memoria de los objetos inútiles, no hay necesidad de
liberar la memoria en el destructor (y tampoco hay forma de hacerlo en el destructor). En la mayoría de los casos, no
hay necesidad de usar un destructor, a menos que cierta clase requiera cierto procesamiento cuando se destruye. Un
ejemplo típico es que un objeto de archivo debe cerrar el archivo cuando se destruye.}

\subsection[6.2 Herencia de clases]{\selectlanguage{spanish} 6.2 Herencia de clases}
\hypertarget{RefHeadingToc356933639824055}{}\foreignlanguage{spanish}{Berry solo admite herencia simple, es decir, una
clase solo puede tener una clase base, y la clase base usa el operador
}\textstyleSourceText{\foreignlanguage{spanish}{:}}\foreignlanguage{spanish}{ para declarar:}


\bigskip

{\selectlanguage{spanish}\ttfamily
class Test: Base}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ ...}

{\selectlanguage{spanish}\ttfamily
end}


\bigskip

\foreignlanguage{spanish}{Aquí la clase }\textstyleSourceText{\foreignlanguage{spanish}{Test}}\foreignlanguage{spanish}{
hereda de la clase }\textstyleSourceText{\foreignlanguage{spanish}{Base}}\foreignlanguage{spanish}{. La subclase
heredará todos los métodos y propiedades de la clase base y puede anularlos en la subclase. Este mecanismo se llama
}\foreignlanguage{spanish}{\textbf{Sobrecarga}}\foreignlanguage{spanish}{. En circunstancias normales, solo
sobrecargaremos métodos, no propiedades.}

{\selectlanguage{spanish}
El mecanismo de herencia de la clase Berry es relativamente simple. Las subclases contendrán referencias a la clase base
y los objetos de instancia son similares. Al instanciar una clase con una clase base, en realidad se generan múltiples
objetos. Estos objetos se encadenarán de acuerdo con la relación de herencia y, finalmente, obtendremos el objeto de
instancia al final de la cadena de herencia.}

\subsection[6.3 Sobrecarga de método]{\selectlanguage{spanish} 6.3 Sobrecarga de método}
\hypertarget{RefHeadingToc356953639824055}{}{\selectlanguage{spanish}
La \textbf{Sobrecarga} significa que la subclase y la clase base usan el mismo método de nombre, y el método de la
subclase anulará el mecanismo del método de la clase base. Para ser precisos, las variables miembro también se pueden
sobrecargar, pero esta sobrecarga no tiene sentido. La sobrecarga de métodos se divide en sobrecarga de métodos
ordinarios y sobrecarga de operadores.}

\subsubsection[6.3.1 Sobrecarga de método común]{\selectlanguage{spanish} 6.3.1 Sobrecarga de método común}
\hypertarget{RefHeadingToc356973639824055}{}\subsubsection[Sobrecarga del operador]{\selectlanguage{spanish} Sobrecarga
del operador}
\hypertarget{RefHeadingToc356993639824055}{}{\selectlanguage{spanish}
Puede usar la sobrecarga de operadores de la clase para hacer que la instancia admita la operación del operador
integrado. Por ejemplo, para una clase sobrecargada con el operador de suma, podemos usar el operador de suma para
realizar operaciones en la instancia. Un operador sobrecargado es un método con un nombre especial, y la forma de
función sobrecargada de un operador binario es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
´def' operador ´(´ otro ´)´}

{\selectlanguage{spanish}\ttfamily
\ \ bloque}

{\selectlanguage{spanish}\ttfamily
´end'}


\bigskip

\foreignlanguage{spanish}{\textbf{operador}}\foreignlanguage{spanish}{ es un operador binario sobrecargado. El operando
izquierdo del operador binario es el objeto
}\textstyleSourceText{\foreignlanguage{spanish}{self}}\foreignlanguage{spanish}{ y el operando derecho es el valor del
parámetro }\foreignlanguage{spanish}{\textbf{otro}}\foreignlanguage{spanish}{. La forma de función sobrecargada del
operador unario es}


\bigskip

{\selectlanguage{spanish}\ttfamily
´def' operador ´()´}

{\selectlanguage{spanish}\ttfamily
\ \ bloque}

{\selectlanguage{spanish}\ttfamily
´end'}


\bigskip

\foreignlanguage{spanish}{\textbf{operador}}\foreignlanguage{spanish}{ es un operador unario sobrecargado. Para
distinguirlo del operador de resta, el signo menos unario se escribe como
}\textstyleSourceText{\foreignlanguage{spanish}{{}-*}}\foreignlanguage{spanish}{ cuando está sobrecargado. Las
funciones sobrecargadas del operador deben tener un valor de retorno, porque el valor de retorno
}\textstyleSourceText{\foreignlanguage{spanish}{nil}}\foreignlanguage{spanish}{ predeterminado no suele ser el
resultado esperado. Tomemos una clase entera como ejemplo para ilustrar el uso de la sobrecarga de operadores. Primero
defina la clase }\textstyleSourceText{\foreignlanguage{spanish}{integer}}\foreignlanguage{spanish}{:}


\bigskip

{\selectlanguage{spanish}\ttfamily
class integer}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ var value}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ def init(v)}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ self.value = v}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ end}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ def +(other)}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ return integer(self.value + other.value)}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ end}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ def *(other)}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ return integer(self.value * other.value)}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ end}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ def -*()}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ return integer(-self.value)}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ end}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ def tostring(other)}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ return str(self.value)}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ end}

{\selectlanguage{spanish}\ttfamily
end}


\bigskip

\foreignlanguage{spanish}{La clase }\textstyleSourceText{\foreignlanguage{spanish}{integer}}\foreignlanguage{spanish}{
sobrecarga los operadores suma, multiplicación y simbólicos, y el método
}\textstyleSourceText{\foreignlanguage{spanish}{tostring}}\foreignlanguage{spanish}{ hace que la instancia use la
función }\textstyleSourceText{\foreignlanguage{spanish}{print}}\foreignlanguage{spanish}{ para generar el resultado.
Podemos usar una simple línea de código para probar la función de sobrecarga de operadores de la clase:}

{\selectlanguage{spanish}\ttfamily
integer(1) + integer(2) * -integer(3) \# -5}

\foreignlanguage{spanish}{El resultado de esta línea de código es una instancia de
}\textstyleSourceText{\foreignlanguage{spanish}{integer}}\foreignlanguage{spanish}{. El valor del miembro
}\textstyleSourceText{\foreignlanguage{spanish}{value}}\foreignlanguage{spanish}{ de esta instancia es
}\textstyleSourceText{\foreignlanguage{spanish}{{}-5}}\foreignlanguage{spanish}{, que es el mismo resultado de las
mismas cuatro operaciones aritméticas con números enteros.}

\foreignlanguage{spanish}{Los operadores lógicos no se pueden sobrecargar directamente. Si necesita una instancia para
admitir operaciones lógicas, debe implementar el método
}\textstyleSourceText{\foreignlanguage{spanish}{tobool}}\foreignlanguage{spanish}{. El método no tiene parámetros y el
valor devuelto debe ser de tipo booleano. La operación lógica de la instancia en realidad se realiza convirtiendo la
instancia en un valor booleano, por lo que la operación lógica de la instancia está completamente en línea con la
naturaleza de la operación lógica general. El operador de subíndice no se sobrecarga directamente, pero se implementa
}\foreignlanguage{spanish}{mediante los métodos
}\textstyleSourceText{\foreignlanguage{spanish}{item}}\foreignlanguage{spanish}{ y
}\textstyleSourceText{\foreignlanguage{spanish}{setitem}}\foreignlanguage{spanish}{. El método
}\textstyleSourceText{\foreignlanguage{spanish}{item}}\foreignlanguage{spanish}{ se utiliza para la lectura de
subíndices, su primer parámetro es el valor del subíndice y el valor de retorno es el resultado de la operación del
subíndice; }\textstyleSourceText{\foreignlanguage{spanish}{setitem}}\foreignlanguage{spanish}{ se utiliza para la
escritura de subíndices, y su primer parámetro es el valor del subíndice, el segundo parámetro es el valor que se va a
escribir; este método no utiliza el valor de retorno.}

{\selectlanguage{spanish}
Al operador sobrecargado se le puede asignar cualquier significado, incluso sin satisfacer las propiedades habituales de
los operadores. Dada la versatilidad del código y la dificultad de comprensión, no se recomienda que los usuarios den a
los operadores sobrecargados una función alejada del significado general.}

\paragraph[Sobrecarga del operador de asignación compuesto]{\selectlanguage{spanish} Sobrecarga del operador de
asignación compuesto}
\hypertarget{RefHeadingToc357013639824055}{}\foreignlanguage{spanish}{El operador de asignación compuesto no se puede
sobrecargar directamente, pero podemos lograr el propósito de {\textquotedbl}sobrecargar{\textquotedbl} el operador de
asignación compuesto sobrecargando el operador binario correspondiente al operador de asignación compuesto. Por
ejemplo, después de sobrecargar el operador
{\textquotedbl}}\textstyleSourceText{\foreignlanguage{spanish}{+}}\foreignlanguage{spanish}{{\textquotedbl}, puede usar
el operador
{\textquotedbl}}\textstyleSourceText{\foreignlanguage{spanish}{+=}}\foreignlanguage{spanish}{{\textquotedbl} para
instancias de clases relacionadas. Vale la pena señalar que el uso de operaciones de asignación compuestas en la
instancia hará que las variables de la instancia vinculada pierdan su referencia a la instancia.}


\bigskip

{\selectlanguage{spanish}\ttfamily
class integer}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ var valor}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ def init(x)}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ self.valor = x}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ end}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ def +(other)}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ return integer(self.valor + other.valor)}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ end}

{\selectlanguage{spanish}\ttfamily
end}

{\selectlanguage{spanish}\ttfamily
a = integer(4) \# a: {\textless}instance: 0x55edff400a78{\textgreater}}

{\selectlanguage{spanish}\ttfamily
a += integer(5) \# a: {\textless}instance: 0x55edff4011b8{\textgreater}}

{\selectlanguage{spanish}\ttfamily
print(a.valor) \# 9}


\bigskip

\foreignlanguage{spanish}{Después de que se ejecuta la línea 11 de código, la instancia enlazada en la variable
}\textstyleSourceText{\foreignlanguage{spanish}{a}}\foreignlanguage{spanish}{ realmente ha cambiado. Esta línea de
código es equivalente a }\textstyleSourceText{\foreignlanguage{spanish}{a = integer(4) +
integer(5)}}\foreignlanguage{spanish}{. Si el operador binario de la sobrecarga de clase no modifica el estado de la
instancia, entonces el operador de asignación compuesto correspondiente no modificará ninguna instancia (puede generar
nuevas instancias).}

\subsection[6.4 Instancia]{\selectlanguage{spanish} 6.4 Instancia}
\hypertarget{RefHeadingToc357033639824055}{}{\selectlanguage{spanish}
Una \textbf{Instancia} es un objeto generado después de la instanciación de la clase. Una clase se puede instanciar
varias veces para generar diferentes instancias. Las instancias de Berry están referenciadas por la clase a la que
pertenecen y los campos de datos correspondientes. Todas las instancias de una clase se referirán a esta clase, pero
los campos de datos de estas instancias son independientes entre sí.}

\subsubsection[6.4.1 Acceso al objeto de clase base]{\selectlanguage{spanish} 6.4.1 Acceso al objeto de clase base}
\hypertarget{RefHeadingToc357053639824055}{}\foreignlanguage{spanish}{La función integrada
}\textstyleSourceText{\foreignlanguage{spanish}{super}}\foreignlanguage{spanish}{ se utiliza para acceder a objetos de
clase superior. Se puede utilizar en clases o instancias.}

\foreignlanguage{spanish}{La magia ocurre cuando llamas a un método de la superclase para que se comporte como
intuitivamente crees que lo haría. Por ejemplo, el patrón común para
}\textstyleSourceText{\foreignlanguage{spanish}{init()}}\foreignlanguage{spanish}{ es el siguiente:}


\bigskip

{\selectlanguage{spanish}\ttfamily
def init({\textless}args{\textgreater})}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \# hacer cosas antes de super init}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ super(self).init({\textless}args{\textgreater})}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \# hacer cosas después de super init}

{\selectlanguage{spanish}\ttfamily
end}


\bigskip

\foreignlanguage{spanish}{Tenga en cuenta que las clases siempre contienen métodos
}\textstyleSourceText{\foreignlanguage{spanish}{init()}}\foreignlanguage{spanish}{ implícitos que no hacen nada, por lo
que siempre puede llamar a init desde la superclase incluso si no se declaró ningún método
}\textstyleSourceText{\foreignlanguage{spanish}{init()}}\foreignlanguage{spanish}{.}

{\selectlanguage{spanish}
Ejemplo completo:}


\bigskip

{\selectlanguage{spanish}\ttfamily
class A}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ var val}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ def init(val)}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ \# super(self).init(val) \ \ \ \# esto sería válido pero inútil}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ self.val = val}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ end}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ def tostring()}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ return {\textquotedbl}val={\textquotedbl} + str(self.val)}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ end}

{\selectlanguage{spanish}\ttfamily
end}


\bigskip

{\selectlanguage{spanish}\ttfamily
class B: A}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ var magia \ \ \ \# verdadero si el valor es 42}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ def init(val)}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ super(self).init(val) \ \ \ \ \# llamar a superinit}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ self.magia = (val == 42)}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ end}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ def tostring()}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ if self.magia}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ \ \ \ \ return {\textquotedbl}magia!{\textquotedbl}}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ else}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ \ \ \ \ return super(self).tostring()}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ end}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ end}

{\selectlanguage{spanish}\ttfamily
end}


\bigskip

{\selectlanguage{spanish}\ttfamily
\#\#\#\#\#\#\# Ejemplo de uso}


\bigskip

{\selectlanguage{spanish}\ttfamily
{\textgreater} b1 = B(1)}

{\selectlanguage{spanish}\ttfamily
{\textgreater} b1}

{\selectlanguage{spanish}\ttfamily
val=1}

{\selectlanguage{spanish}\ttfamily
{\textgreater} b42 = B(42)}

{\selectlanguage{spanish}\ttfamily
{\textgreater} b42}

{\selectlanguage{spanish}\ttfamily
magia!}


\bigskip

\foreignlanguage{spanish}{\textbf{Características avanzadas}}\foreignlanguage{spanish}{: Al llamar a
}\textstyleSourceText{\foreignlanguage{spanish}{super(self).{\textless}method{\textgreater}
({\textless}args{\textgreater} )}}\foreignlanguage{spanish}{ ocurre algo de magia. Cuando se llama al supermétodo, los
argumentos }\textstyleSourceText{\foreignlanguage{spanish}{self}}\foreignlanguage{spanish}{ se refieren a la clase
específica más baja. Sin embargo, el }\textstyleSourceText{\foreignlanguage{spanish}{{\textless}method{\textgreater}
}}\foreignlanguage{spanish}{no se busca desde la clase de
}\textstyleSourceText{\foreignlanguage{spanish}{self}}\foreignlanguage{spanish}{ (que siempre es la más baja), sino
desde la superclase de la clase que contiene el método que se está ejecutando }\foreignlanguage{spanish}{actualmente.}

{\selectlanguage{spanish}
Ejemplo:}


\bigskip

{\selectlanguage{spanish}\ttfamily
{\textgreater} class A}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ def init()}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ \ \ print({\textquotedbl}In A::init, self es de tipo{\textquotedbl}, classname(self))}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ end}

{\selectlanguage{spanish}\ttfamily
\ \ end}

{\selectlanguage{spanish}\ttfamily
{\textgreater} class B:A}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ def init()}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ \ \ print({\textquotedbl}In B::init, self es de tipo{\textquotedbl}, classname(self))}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ \ \ super(self).init()}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ end}

{\selectlanguage{spanish}\ttfamily
\ \ end}

{\selectlanguage{spanish}\ttfamily
{\textgreater} class C:B}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ def init()}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ \ \ print({\textquotedbl}En C::init, self es de tipo{\textquotedbl}, classname(self))}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ \ \ super(self).init()}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ end}

{\selectlanguage{spanish}\ttfamily
\ \ end}

{\selectlanguage{spanish}\ttfamily
{\textgreater} c = C()}

{\selectlanguage{spanish}\ttfamily
En C::init, self es de tipo C}

{\selectlanguage{spanish}\ttfamily
In B::init, self es de tipo C}

{\selectlanguage{spanish}\ttfamily
In A::init, self es de tipo C}

{\selectlanguage{spanish}\ttfamily
{\textgreater}}


\bigskip

{\selectlanguage{spanish}
Explicación:}

\liststyleLiv
\begin{itemize}
\item \foreignlanguage{spanish}{llamando a
}\textstyleSourceText{\foreignlanguage{spanish}{C:init()}}\foreignlanguage{spanish}{ en
}\textstyleSourceText{\foreignlanguage{spanish}{instancia{\textless}C{\textgreater} }}\foreignlanguage{spanish}{{}- en
}\textstyleSourceText{\foreignlanguage{spanish}{C:init()}}\foreignlanguage{spanish}{
}\textstyleSourceText{\foreignlanguage{spanish}{self}}\foreignlanguage{spanish}{ es
}\textstyleSourceText{\foreignlanguage{spanish}{instancia{\textless}C{\textgreater} }}\foreignlanguage{spanish}{,
}\textstyleSourceText{\foreignlanguage{spanish}{super(self).init()}}\foreignlanguage{spanish}{ se refiere a la
superclase de }\textstyleSourceText{\foreignlanguage{spanish}{C}}\foreignlanguage{spanish}{ (método actual), es decir,
}\textstyleSourceText{\foreignlanguage{spanish}{B}}\foreignlanguage{spanish}{, por lo que
}\textstyleSourceText{\foreignlanguage{spanish}{B:init()}}\foreignlanguage{spanish}{ se llama con
}\textstyleSourceText{\foreignlanguage{spanish}{instance{\textless}C{\textgreater}
}}\foreignlanguage{spanish}{argumento - en
}\textstyleSourceText{\foreignlanguage{spanish}{B:init()}}\foreignlanguage{spanish}{
}\textstyleSourceText{\foreignlanguage{spanish}{self}}\foreignlanguage{spanish}{ es
}\textstyleSourceText{\foreignlanguage{spanish}{instancia{\textless}C{\textgreater} }}\foreignlanguage{spanish}{,
}\textstyleSourceText{\foreignlanguage{spanish}{super(self).init()}}\foreignlanguage{spanish}{ se refiere a la
superclase de }\textstyleSourceText{\foreignlanguage{spanish}{B}}\foreignlanguage{spanish}{ (método actual), es decir,
}\textstyleSourceText{\foreignlanguage{spanish}{A}}\foreignlanguage{spanish}{, por lo que
}\textstyleSourceText{\foreignlanguage{spanish}{A:init()}}\foreignlanguage{spanish}{ se llama con
}\textstyleSourceText{\foreignlanguage{spanish}{instance{\textless}C{\textgreater}
}}\foreignlanguage{spanish}{argumento - en
}\textstyleSourceText{\foreignlanguage{spanish}{A:init()}}\foreignlanguage{spanish}{
}\textstyleSourceText{\foreignlanguage{spanish}{self}}\foreignlanguage{spanish}{ es
}\textstyleSourceText{\foreignlanguage{spanish}{instancia{\textless}C{\textgreater} }}\foreignlanguage{spanish}{,
imprimir y devolver}
\end{itemize}
\foreignlanguage{spanish}{Nota: por compatibilidad con versiones anteriores, super puede tomar un segundo argumento
}\textstyleSourceText{\foreignlanguage{spanish}{super(instancia, clase)}}\foreignlanguage{spanish}{ para especificar la
clase donde resolver el método. Esta función no debe usarse más, ya que es propensa a errores.}

\clearpage\section[Capítulo 7: Bibliotecas y Módulos]{Capítulo 7: \foreignlanguage{spanish}{Bibliotecas y Módulos}}
\hypertarget{RefHeadingToc357073639824055}{}
\bigskip

\subsection[7.1 Biblioteca básica]{\selectlanguage{spanish} 7.1 Biblioteca básica}
\hypertarget{RefHeadingToc357093639824055}{}{\selectlanguage{spanish}
Hay algunas funciones y clases que se pueden usar directamente en la biblioteca estándar. Proporcionan servicios básicos
para los programas de Berry, por lo que también se denominan bibliotecas básicas. Las funciones y clases de la
biblioteca básica están visibles en el ámbito global (perteneciente al ámbito integrado), por lo que se pueden utilizar
en cualquier lugar. No defina variables con el mismo nombre que las funciones o clases en la biblioteca base. Si lo
hace, será imposible hacer referencia a las funciones y clases en la biblioteca base.}

\subsubsection[7.1.1 Función integrada]{\selectlanguage{spanish} 7.1.1 Función integrada}
\hypertarget{RefHeadingToc357113639824055}{}\paragraph[Función print]{\foreignlanguage{spanish}{Función
}\textstyleSourceText{\foreignlanguage{spanish}{print}}}
\hypertarget{RefHeadingToc357133639824055}{}{\selectlanguage{spanish}\bfseries
Ejemplo}

{\selectlanguage{spanish}\ttfamily
print(...)}

{\selectlanguage{spanish}\bfseries
Descripción}

\foreignlanguage{spanish}{Esta función imprime los parámetros de entrada en el dispositivo de salida estándar. La
función puede aceptar cualquier tipo y cualquier número de parámetros. Todos los tipos imprimirán su valor
directamente, y para una instancia, esta función verificará si la instancia tiene un método
}\textstyleSourceText{\foreignlanguage{spanish}{tostring()}}\foreignlanguage{spanish}{, y si lo hay, imprimirá el valor
de retorno de la instancia llamando al método
}\textstyleSourceText{\foreignlanguage{spanish}{tostring()}}\foreignlanguage{spanish}{, de lo contrario, imprimirá la
dirección de la instancia.}


\bigskip

{\selectlanguage{spanish}\ttfamily
print('Hola mundo!') \# Hola mundo!}

{\selectlanguage{spanish}\ttfamily
print([1, 2, '3']) \# [1, 2, '3']}

{\selectlanguage{spanish}\ttfamily
print(print) \# {\textless}function: 0x561092293780{\textgreater}}

\paragraph[Función input]{\foreignlanguage{spanish}{Función }\textstyleSourceText{\foreignlanguage{spanish}{input}}}
\hypertarget{RefHeadingToc357153639824055}{}{\selectlanguage{spanish}\bfseries
Ejemplo}

{\selectlanguage{spanish}\ttfamily
input()}

{\selectlanguage{spanish}\ttfamily
input(prompt)}

{\selectlanguage{spanish}\bfseries
Descripción}

\foreignlanguage{spanish}{La función }\textstyleSourceText{\foreignlanguage{spanish}{input}}\foreignlanguage{spanish}{
se usa para ingresar una línea de cadena de caracteres desde el dispositivo de entrada estándar. Esta función puede
usar el parámetro }\textstyleSourceText{\foreignlanguage{spanish}{prompt}}\foreignlanguage{spanish}{ como un indicador
de entrada, y el parámetro }\textstyleSourceText{\foreignlanguage{spanish}{prompt}}\foreignlanguage{spanish}{ debe ser
de tipo cadena. Después de llamar a la función
}\textstyleSourceText{\foreignlanguage{spanish}{input}}\foreignlanguage{spanish}{, los caracteres se leerán desde el
búfer del teclado hasta que se encuentre un carácter de nueva línea.}

{\selectlanguage{spanish}\ttfamily
input('por favor ingrese una cadena:') \# por favor ingrese una cadena:}

\foreignlanguage{spanish}{La función }\textstyleSourceText{\foreignlanguage{spanish}{input}}\foreignlanguage{spanish}{
no regresa hasta que se presiona la tecla {\textquotedbl}Enter{\textquotedbl}, por lo que el programa queda
{\textquotedbl}atascado{\textquotedbl} y no es un error.}

\paragraph[Función type]{\foreignlanguage{spanish}{Función }\textstyleSourceText{\foreignlanguage{spanish}{type}}}
\hypertarget{RefHeadingToc357173639824055}{}{\selectlanguage{spanish}\bfseries
Ejemplo:}


\bigskip

{\selectlanguage{spanish}\ttfamily
type(valor)}


\bigskip

\liststyleLv
\begin{itemize}
\item {\selectlanguage{spanish}
\textit{valor}: parámetro de entrada (se espera obtener su tipo).}
\item {\selectlanguage{spanish}
\textit{valor devuelto}: una cadena que describe el tipo de parámetro.}
\end{itemize}

\bigskip

{\selectlanguage{spanish}\bfseries
Descripción}

{\selectlanguage{spanish}
Esta función recibe un parámetro de cualquier tipo y devuelve el tipo del parámetro. El valor devuelto es una cadena que
describe el tipo del parámetro. La siguiente tabla muestra los valores de retorno correspondientes a los principales
tipos de parámetros:}


\bigskip

\begin{center}
\tablefirsthead{{\selectlanguage{spanish}\bfseries Tipo de parámetro} &
{\selectlanguage{spanish}\bfseries Valor devuelto} &
{\selectlanguage{spanish}\bfseries Tipo de parámetro} &
{\selectlanguage{spanish}\bfseries Valor devuelto}\\}
\tablehead{{\selectlanguage{spanish}\bfseries Tipo de parámetro} &
{\selectlanguage{spanish}\bfseries Valor devuelto} &
{\selectlanguage{spanish}\bfseries Tipo de parámetro} &
{\selectlanguage{spanish}\bfseries Valor devuelto}\\}
\tabletail{}
\tablelasttail{}
\begin{supertabular}{m{3.779cm}m{3.779cm}m{3.779cm}m{3.781cm}}
{\selectlanguage{spanish} Nil} &
\textstyleSourceText{\foreignlanguage{spanish}{{}'nil'}} &
{\selectlanguage{spanish} Integer} &
\textstyleSourceText{\foreignlanguage{spanish}{{}'int'}}\\
{\selectlanguage{spanish} Real} &
\textstyleSourceText{\foreignlanguage{spanish}{{}'real'}} &
{\selectlanguage{spanish} Boolean} &
\textstyleSourceText{\foreignlanguage{spanish}{{}'bool'}}\\
{\selectlanguage{spanish} Function} &
\textstyleSourceText{\foreignlanguage{spanish}{{}'function'}} &
{\selectlanguage{spanish} Class} &
\textstyleSourceText{\foreignlanguage{spanish}{{}'class'}}\\
{\selectlanguage{spanish} String} &
\textstyleSourceText{\foreignlanguage{spanish}{{}'string'}} &
{\selectlanguage{spanish} Instance} &
\textstyleSourceText{\foreignlanguage{spanish}{{}'instance'}}\\
{\selectlanguage{spanish} puntero nativo} &
\textstyleSourceText{\foreignlanguage{spanish}{{}'ptr'}} &
~
 &
~
\\
\end{supertabular}
\end{center}

\bigskip

{\selectlanguage{spanish}\ttfamily
type(0) \# 'int'}

{\selectlanguage{spanish}\ttfamily
type(0.5) \# 'real'}

{\selectlanguage{spanish}\ttfamily
type('hello') \# 'string'}

{\selectlanguage{spanish}\ttfamily
type(print) \# 'función'}

\paragraph[Función classname]{\foreignlanguage{spanish}{Función
}\textstyleSourceText{\foreignlanguage{spanish}{classname}}}
\hypertarget{RefHeadingToc357193639824055}{}{\selectlanguage{spanish}\bfseries
Ejemplo}

{\selectlanguage{spanish}\ttfamily
classname(objeto)}


\bigskip

{\selectlanguage{spanish}\bfseries
Descripción}

\foreignlanguage{spanish}{Esta función devuelve el nombre de clase (cadena) del parámetro. Por lo tanto, el parámetro
debe ser una clase o instancia, y otros tipos de parámetros devolverán
}\textstyleSourceText{\foreignlanguage{spanish}{nil}}\foreignlanguage{spanish}{.}


\bigskip

{\selectlanguage{spanish}\ttfamily
classname(list) \# 'list'}

{\selectlanguage{spanish}\ttfamily
classname(list()) \# 'list'}

{\selectlanguage{spanish}\ttfamily
classname(\{\}) \# 'map'}

{\selectlanguage{spanish}\ttfamily
classname(0) \# nil}

\paragraph[Función classof]{\foreignlanguage{spanish}{Función }\textstyleSourceText{\foreignlanguage{spanish}{classof}}}
\hypertarget{RefHeadingToc357213639824055}{}{\selectlanguage{spanish}\bfseries
Ejemplo}

{\selectlanguage{spanish}\ttfamily
classof(objeto)}


\bigskip

{\selectlanguage{spanish}\bfseries
Descripción}

\foreignlanguage{spanish}{Devuelve la clase de un objeto de instancia. El parámetro
}\textstyleSourceText{\foreignlanguage{spanish}{objeto}}\foreignlanguage{spanish}{ debe ser una instancia. Si la
}\foreignlanguage{spanish}{función se llama con éxito, devolverá la clase a la que pertenece la instancia; de lo
contrario, devolverá }\textstyleSourceText{\foreignlanguage{spanish}{nil}}\foreignlanguage{spanish}{.}


\bigskip

{\selectlanguage{spanish}\ttfamily
classof(list) \# nil}

{\selectlanguage{spanish}\ttfamily
classof(list()) \# {\textless}class: list{\textgreater}}

{\selectlanguage{spanish}\ttfamily
classof(\{\}) \# {\textless}class: map{\textgreater}}

{\selectlanguage{spanish}\ttfamily
classof(0) \# nil}

\paragraph[Función str]{\foreignlanguage{spanish}{Función }\textstyleSourceText{\foreignlanguage{spanish}{str}}}
\hypertarget{RefHeadingToc357233639824055}{}{\selectlanguage{spanish}\bfseries
Ejemplo}

{\selectlanguage{spanish}\ttfamily
str(valor)}

{\selectlanguage{spanish}\bfseries
Descripción}

\foreignlanguage{spanish}{Esta función convierte los parámetros en cadenas y los devuelve. Las funciones
}\textstyleSourceText{\foreignlanguage{spanish}{str}}\foreignlanguage{spanish}{ pueden aceptar cualquier tipo de
parámetros y convertirlos. Cuando el tipo de parámetro es una instancia, verificará si la instancia tiene un método
}\textstyleSourceText{\foreignlanguage{spanish}{tostring()}}\foreignlanguage{spanish}{, si lo hay, se usará el valor de
retorno del método; de lo contrario, la dirección de la instancia se convertirá en una cadena.}


\bigskip

{\selectlanguage{spanish}\ttfamily
str(0) \# '0'}

{\selectlanguage{spanish}\ttfamily
str(nil) \# 'nil'}

{\selectlanguage{spanish}\ttfamily
str(list) \# 'list'}

{\selectlanguage{spanish}\ttfamily
str([0, 1, 2]) \# '[0, 1, 2]'}

\subparagraph[Función number]{\foreignlanguage{spanish}{Función
}\textstyleSourceText{\foreignlanguage{spanish}{number}}}
\hypertarget{RefHeadingToc357253639824055}{}{\selectlanguage{spanish}\ttfamily
number(valor)}

{\selectlanguage{spanish}\bfseries
Descripción}

\foreignlanguage{spanish}{Esta función convierte la cadena o el número de entrada en un tipo numérico y lo devuelve. Si
el parámetro de entrada es un número entero o real, devuelve directamente. Si es una cadena de caracteres, intenta
convertir la cadena de caracteres en un valor numérico en formato decimal. El número entero o real se juzgará
automáticamente durante la conversión. Otros tipos devuelven
}\textstyleSourceText{\foreignlanguage{spanish}{nil}}\foreignlanguage{spanish}{.}

{\selectlanguage{spanish}\bfseries
Ejemplo}


\bigskip

{\selectlanguage{spanish}\ttfamily
number(5) \# 5}

{\selectlanguage{spanish}\ttfamily
number('45.6') \# 45.6}

{\selectlanguage{spanish}\ttfamily
number('50') \# 50}

{\selectlanguage{spanish}\ttfamily
number(list) \# nil}

\subparagraph[Función int]{\foreignlanguage{spanish}{Función }\textstyleSourceText{\foreignlanguage{spanish}{int}}}
\hypertarget{RefHeadingToc357273639824055}{}{\selectlanguage{spanish}\ttfamily
int(valor)}


\bigskip

{\selectlanguage{spanish}\bfseries
Descripción}

\foreignlanguage{spanish}{Esta función convierte la cadena o el número de entrada en un número entero y lo devuelve. Si
el parámetro de entrada es un número entero, regresa directamente, si es un número real, descarta la parte decimal. Si
es una cadena, intenta convertir la cadena en un número entero en decimal. Otros tipos devuelven
}\textstyleSourceText{\foreignlanguage{spanish}{nil}}\foreignlanguage{spanish}{. Cuando el tipo de parámetro es una
instancia, }\foreignlanguage{spanish}{verificará si la instancia tiene un método
}\textstyleSourceText{\foreignlanguage{spanish}{toint()}}\foreignlanguage{spanish}{, si lo hay, se utilizará el valor
de retorno del método.}

{\selectlanguage{spanish}\bfseries
Ejemplo}


\bigskip

{\selectlanguage{spanish}\ttfamily
int(5) \# 5}

{\selectlanguage{spanish}\ttfamily
int(45.6) \# 45}

{\selectlanguage{spanish}\ttfamily
int('50') \# 50}

{\selectlanguage{spanish}\ttfamily
int('0x10) \# 16 - literal hexadecimal es válido}

{\selectlanguage{spanish}\ttfamily
int(list) \# nil}

\subparagraph[Función real]{\foreignlanguage{spanish}{Función }\textstyleSourceText{\foreignlanguage{spanish}{real}}}
\hypertarget{RefHeadingToc357293639824055}{}{\selectlanguage{spanish}\ttfamily
real(valor)}

{\selectlanguage{spanish}\bfseries
Descripción}

\foreignlanguage{spanish}{Esta función convierte la cadena o el número de entrada en un número real y lo devuelve. Si el
parámetro de entrada es un número real, devolverá directamente, si es un número entero, se convertirá en un número
real. Si es una cadena, intenta convertir la cadena en un número real en decimal. Otros tipos devuelven
}\textstyleSourceText{\foreignlanguage{spanish}{nil}}\foreignlanguage{spanish}{.}

{\selectlanguage{spanish}\bfseries
Ejemplo}


\bigskip

{\selectlanguage{spanish}\ttfamily
real(5) \# 5, type(real(5)) $\rightarrow $'real'}

{\selectlanguage{spanish}\ttfamily
real(45.6) \# 45.6}

{\selectlanguage{spanish}\ttfamily
real('50.5') \# 50.5}

{\selectlanguage{spanish}\ttfamily
real(list) \# nil}

\subparagraph[Función bool]{\foreignlanguage{spanish}{Función }\textstyleSourceText{\foreignlanguage{spanish}{bool}}}
\hypertarget{RefHeadingToc357313639824055}{}{\selectlanguage{spanish}\ttfamily
bool(valor)}


\bigskip

{\selectlanguage{spanish}\bfseries
Descripción}

{\selectlanguage{spanish}
Esta función convierte la cadena o el número de entrada en un valor booleano y lo devuelve.}

{\selectlanguage{spanish}
La conversión sigue las siguientes reglas:}

\liststyleLvi
\begin{itemize}
\item \textstyleSourceText{\foreignlanguage{spanish}{nil}}\foreignlanguage{spanish}{: convertido a
}\textstyleSourceText{\foreignlanguage{spanish}{falso}}\foreignlanguage{spanish}{.}
\item \foreignlanguage{spanish}{\textbf{Entero}}\foreignlanguage{spanish}{: cuando el valor es
}\textstyleSourceText{\foreignlanguage{spanish}{0}}\foreignlanguage{spanish}{, se convierte en
}\textstyleSourceText{\foreignlanguage{spanish}{falso}}\foreignlanguage{spanish}{, de lo contrario, se convierte en
}\textstyleSourceText{\foreignlanguage{spanish}{verdadero}}\foreignlanguage{spanish}{.}
\item \foreignlanguage{spanish}{\textbf{Número real}}\foreignlanguage{spanish}{: cuando el valor es
}\textstyleSourceText{\foreignlanguage{spanish}{0.0}}\foreignlanguage{spanish}{, se convierte en
}\textstyleSourceText{\foreignlanguage{spanish}{falso}}\foreignlanguage{spanish}{, de lo contrario, se convierte en
}\textstyleSourceText{\foreignlanguage{spanish}{verdadero}}\foreignlanguage{spanish}{.}
\item \foreignlanguage{spanish}{\textbf{Cadena}}\foreignlanguage{spanish}{: cuando el valor es
{\textquotedbl}{\textquotedbl} (cadena vacía) se convierte en
}\textstyleSourceText{\foreignlanguage{spanish}{falso}}\foreignlanguage{spanish}{ de lo contrario, se convierte en
}\textstyleSourceText{\foreignlanguage{spanish}{verdadero}}\foreignlanguage{spanish}{.}
\item \foreignlanguage{spanish}{\textbf{Comobj}}\foreignlanguage{spanish}{ y
}\foreignlanguage{spanish}{\textbf{Comptr}}\foreignlanguage{spanish}{: cuando el puntero interno es
}\textstyleSourceText{\foreignlanguage{spanish}{NULL}}\foreignlanguage{spanish}{ es convertido a
}\textstyleSourceText{\foreignlanguage{spanish}{falso}}\foreignlanguage{spanish}{, de lo contrario se convierte a
}\textstyleSourceText{\foreignlanguage{spanish}{verdadero}}\foreignlanguage{spanish}{.}
\item \foreignlanguage{spanish}{\textbf{Instancia}}\foreignlanguage{spanish}{: si la instancia contiene un método
}\textstyleSourceText{\foreignlanguage{spanish}{tobool()}}\foreignlanguage{spanish}{, se utilizará el valor de retorno
del método, de lo contrario, se convertirá en
}\textstyleSourceText{\foreignlanguage{spanish}{verdadero}}\foreignlanguage{spanish}{.}
\item \foreignlanguage{spanish}{Todos los demás tipos: convierte a
}\textstyleSourceText{\foreignlanguage{spanish}{verdadero}}\foreignlanguage{spanish}{.}


\bigskip
\end{itemize}
{\selectlanguage{spanish}\bfseries
Ejemplo}


\bigskip

{\selectlanguage{spanish}\ttfamily
bool() \# false}

{\selectlanguage{spanish}\ttfamily
bool(nil) \# false}

{\selectlanguage{spanish}\ttfamily
bool(false) \# false}

{\selectlanguage{spanish}\ttfamily
bool(true) \# true}

{\selectlanguage{spanish}\ttfamily
bool(0) \# false}

{\selectlanguage{spanish}\ttfamily
bool(1) \# true}

{\selectlanguage{spanish}\ttfamily
bool({\textquotedbl}{\textquotedbl}) \# false}

{\selectlanguage{spanish}\ttfamily
bool({\textquotedbl}a{\textquotedbl}) \# true}

{\selectlanguage{spanish}\ttfamily
bool(3.5) \# true}

{\selectlanguage{spanish}\ttfamily
bool(list) \# true}

{\selectlanguage{spanish}\ttfamily
bool([]) \# true}

{\selectlanguage{spanish}\ttfamily
bool(\{\}) \# true}

{\selectlanguage{spanish}\ttfamily
\# avanzado}

{\selectlanguage{spanish}\ttfamily
import introspect}

{\selectlanguage{spanish}\ttfamily
bool(introspect.toptr(0)) \# false}

{\selectlanguage{spanish}\ttfamily
bool(introspect.toptr(0x1000)) \# true}

\subparagraph[Función size]{\foreignlanguage{spanish}{Función }\textstyleSourceText{\foreignlanguage{spanish}{size}}}
\hypertarget{RefHeadingToc357333639824055}{}{\selectlanguage{spanish}\ttfamily
size(valor)}


\bigskip

{\selectlanguage{spanish}\bfseries
Descripción}

\foreignlanguage{spanish}{Esta función devuelve el tamaño de la cadena de entrada. Si el parámetro de entrada no es una
cadena, se devuelve 0. La longitud de la cadena se calcula en bytes. Esta función también funciona para instancias de
}\textstyleSourceText{\foreignlanguage{spanish}{list}}\foreignlanguage{spanish}{ y
}\textstyleSourceText{\foreignlanguage{spanish}{map}}\foreignlanguage{spanish}{ y devuelve el número de elementos.}

{\selectlanguage{spanish}\bfseries
Ejemplo}


\bigskip

{\selectlanguage{spanish}\ttfamily
size(10) \# 0}

{\selectlanguage{spanish}\ttfamily
size('s') \# 1}

{\selectlanguage{spanish}\ttfamily
size('string') \# 6}

{\selectlanguage{spanish}\ttfamily
size([1,2]) \# 2}

{\selectlanguage{spanish}\ttfamily
size(\{{\textquotedbl}a{\textquotedbl}:1\}) \# 1}

\subparagraph[Función super]{\foreignlanguage{spanish}{Función }\textstyleSourceText{\foreignlanguage{spanish}{super}}}
\hypertarget{RefHeadingToc357353639824055}{}{\selectlanguage{spanish}\ttfamily
super(objeto)}


\bigskip

{\selectlanguage{spanish}\bfseries
Descripción}

\foreignlanguage{spanish}{Esta función devuelve el objeto principal de la instancia. Cuando crea una instancia de una
clase derivada, también creará una instancia de su clase base. Se requiere la función
}\textstyleSourceText{\foreignlanguage{spanish}{super}}\foreignlanguage{spanish}{ para acceder a la instancia de la
clase base (es decir, el objeto principal).}

\foreignlanguage{spanish}{Consulte el capítulo 6 sobre el comportamiento mágico de
}\textstyleSourceText{\foreignlanguage{spanish}{super(objeto)}}\foreignlanguage{spanish}{ al llamar a un supermétodo.}

{\selectlanguage{spanish}\bfseries
Ejemplo}


\bigskip

{\selectlanguage{spanish}\ttfamily
class mi\_lista: lista end}

{\selectlanguage{spanish}\ttfamily
l = mi\_lista() \# classname(l) -{}-{\textgreater}'mi\_lista'}

{\selectlanguage{spanish}\ttfamily
sl = super(l) \# classname(sl) -{}-{\textgreater}'lista'}

\subparagraph[Función assert]{\foreignlanguage{spanish}{Función
}\textstyleSourceText{\foreignlanguage{spanish}{assert}}}
\hypertarget{RefHeadingToc357373639824055}{}{\selectlanguage{spanish}\ttfamily
assert(expresión)}

{\selectlanguage{spanish}\ttfamily
assert(expresión, mensaje)}


\bigskip

{\selectlanguage{spanish}\bfseries
Descripción}

\foreignlanguage{spanish}{Esta función se utiliza para implementar la función de aserción. La función
}\textstyleSourceText{\foreignlanguage{spanish}{assert}}\foreignlanguage{spanish}{ acepta un parámetro. Cuando el valor
del parámetro es }\textstyleSourceText{\foreignlanguage{spanish}{false}}\foreignlanguage{spanish}{ o
}\textstyleSourceText{\foreignlanguage{spanish}{nil}}\foreignlanguage{spanish}{, la función activará un error de
aserción; de lo contrario, la función no tendrá ningún efecto. Cabe señalar que incluso si el parámetro es un valor
equivalente a }\textstyleSourceText{\foreignlanguage{spanish}{false}}\foreignlanguage{spanish}{ en operaciones lógicas
(por ejemplo, }\textstyleSourceText{\foreignlanguage{spanish}{0}}\foreignlanguage{spanish}{), no generará un error de
aserción. El parámetro }\textstyleSourceText{\foreignlanguage{spanish}{mensaje}}\foreignlanguage{spanish}{ es opcional
y debe ser una cadena. Si se utiliza este parámetro, la información de texto proporcionada en
}\textstyleSourceText{\foreignlanguage{spanish}{message}}\foreignlanguage{spanish}{ se mostrará cuando se produzca un
error de aserción; de lo contrario, se mostrará el mensaje predeterminado
{\textquotedbl}}\textstyleSourceText{\foreignlanguage{spanish}{Assert Fail}}\foreignlanguage{spanish}{{\textquotedbl}.}

{\selectlanguage{spanish}\bfseries
Ejemplo}


\bigskip

{\selectlanguage{spanish}\ttfamily
assert(false) \# aserción fallida!}

{\selectlanguage{spanish}\ttfamily
assert(nil) \# aserción fallida!}

{\selectlanguage{spanish}\ttfamily
assert() \# aserción fallida!}

{\selectlanguage{spanish}\ttfamily
assert(0) \# aserción fallida!}

{\selectlanguage{spanish}\ttfamily
assert(false,'mensaje de aserción del usuario.') \# mensaje de aserción.}

{\selectlanguage{spanish}\ttfamily
assert(true) \# pasa}

\subparagraph[Función compile]{\foreignlanguage{spanish}{Función
}\textstyleSourceText{\foreignlanguage{spanish}{compile}}}
\hypertarget{RefHeadingToc357393639824055}{}{\selectlanguage{spanish}\ttfamily
compile(cadena)}

{\selectlanguage{spanish}\ttfamily
compile(cadena, 'string')}

{\selectlanguage{spanish}\ttfamily
compile(nombre\_archivo, 'file')}


\bigskip

{\selectlanguage{spanish}\bfseries
Descripción}

\foreignlanguage{spanish}{Esta función compila el código fuente de Berry en una función. El código fuente puede ser una
cadena o un archivo de texto. El primer parámetro de la función
}\textstyleSourceText{\foreignlanguage{spanish}{compile}}\foreignlanguage{spanish}{ es una cadena, y el segundo
parámetro es una }\textstyleSourceText{\foreignlanguage{spanish}{{}'cadena'}}\foreignlanguage{spanish}{ o
}\textstyleSourceText{\foreignlanguage{spanish}{{}'archivo'}}\foreignlanguage{spanish}{. Cuando el segundo parámetro es
}\textstyleSourceText{\foreignlanguage{spanish}{{}'cadena'}}\foreignlanguage{spanish}{ o no hay un segundo parámetro,
la función }\textstyleSourceText{\foreignlanguage{spanish}{compile}}\foreignlanguage{spanish}{ compilará el primer
parámetro como código fuente. Cuando el segundo parámetro es
}\textstyleSourceText{\foreignlanguage{spanish}{{}'file'}}\foreignlanguage{spanish}{, la función
}\textstyleSourceText{\foreignlanguage{spanish}{compile}}\foreignlanguage{spanish}{ compilará el archivo
correspondiente al primer parámetro. Si la compilación es exitosa,
}\textstyleSourceText{\foreignlanguage{spanish}{compile}}\foreignlanguage{spanish}{ devolverá la función compilada; de
lo contrario, devolverá }\textstyleSourceText{\foreignlanguage{spanish}{nil}}\foreignlanguage{spanish}{.}

{\selectlanguage{spanish}\bfseries
Ejemplo}


\bigskip

{\selectlanguage{spanish}\ttfamily
compile('print({\textbackslash}'Hola mundo!{\textbackslash}')')() \# Hola mundo!}

{\selectlanguage{spanish}\ttfamily
compile('test.be','file')}

\subsubsection[7.1.2 Clase list]{\foreignlanguage{spanish}{7.1.2 }\foreignlanguage{spanish}{Clase
}\textstyleSourceText{\foreignlanguage{spanish}{list}}}
\hypertarget{RefHeadingToc357413639824055}{}\textstyleSourceText{\foreignlanguage{spanish}{list}}\foreignlanguage{spanish}{
es un tipo incorporado, y define un contenedor de almacenamiento secuencial que admite la lectura y escritura de
subíndices. Es similar a las matrices en otros lenguajes de programación. La obtención de una instancia de la clase
}\textstyleSourceText{\foreignlanguage{spanish}{list}}\foreignlanguage{spanish}{ se puede construir usando un par de
corchetes: }\textstyleSourceText{\foreignlanguage{spanish}{[]}}\foreignlanguage{spanish}{ generará una instancia vacía
de }\textstyleSourceText{\foreignlanguage{spanish}{list}}\foreignlanguage{spanish}{, y
}\textstyleSourceText{\foreignlanguage{spanish}{[expr, expr, ...]}}\foreignlanguage{spanish}{ generará
}\foreignlanguage{spanish}{una }\textstyleSourceText{\foreignlanguage{spanish}{list}}\foreignlanguage{spanish}{ ejemplo
con varios elementos. También se puede instanciar llamando a la clase
}\textstyleSourceText{\foreignlanguage{spanish}{list}}\foreignlanguage{spanish}{: ejecutar
}\textstyleSourceText{\foreignlanguage{spanish}{list()}}\foreignlanguage{spanish}{ obtendrá una instancia vacía de
}\textstyleSourceText{\foreignlanguage{spanish}{list}}\foreignlanguage{spanish}{, y
}\textstyleSourceText{\foreignlanguage{spanish}{list(expr, expr, ...)}}\foreignlanguage{spanish}{ devolverá una
instancia con varios elementos.}

\paragraph[Método list (Constructor)]{\foreignlanguage{spanish}{Método
}\textstyleSourceText{\foreignlanguage{spanish}{list}}\foreignlanguage{spanish}{ (Constructor)}}
\hypertarget{RefHeadingToc357433639824055}{}\foreignlanguage{spanish}{Inicializa el contenedor
}\textstyleSourceText{\foreignlanguage{spanish}{list}}\foreignlanguage{spanish}{. Este método puede aceptar de 0 a
múltiples parámetros. La instancia }\textstyleSourceText{\foreignlanguage{spanish}{list}}\foreignlanguage{spanish}{
generada cuando se pasan múltiples parámetros tendrá estos parámetros como elementos, y el orden de disposición de los
elementos es coherente con el orden de disposición de los parámetros.}

\paragraph[Método tostring]{\foreignlanguage{spanish}{Método }\textstyleSourceText{\foreignlanguage{spanish}{tostring}}}
\hypertarget{RefHeadingToc357453639824055}{}\foreignlanguage{spanish}{Serializa la instancia de
}\textstyleSourceText{\foreignlanguage{spanish}{list}}\foreignlanguage{spanish}{ en una cadena y la devuelve. Por
ejemplo, el resultado de ejecutar }\textstyleSourceText{\foreignlanguage{spanish}{[1, [],
1.5].tostring()}}\foreignlanguage{spanish}{ es }\textstyleSourceText{\foreignlanguage{spanish}{{}'[1, [], 1.5]'{}'. Si
el contenedor }}\foreignlanguage{spanish}{list{\textasciigrave} se refiere a sí mismo, la posición correspondiente
utilizará puntos suspensivos en lugar del valor específico:}


\bigskip

{\selectlanguage{spanish}\ttfamily
l = [1, 2]}

{\selectlanguage{spanish}\ttfamily
l[0] = l}

{\selectlanguage{spanish}\ttfamily
print(l) \# [[...], 2]}

\paragraph[Método concat]{\foreignlanguage{spanish}{Método }\textstyleSourceText{\foreignlanguage{spanish}{concat}}}
\hypertarget{RefHeadingToc357473639824055}{}{\selectlanguage{spanish}
Convierte cada elemento de la lista en cadenas y la concatena usando la cadena proporcionada.}


\bigskip

{\selectlanguage{spanish}\ttfamily
l = [1, 2, 3]}

{\selectlanguage{spanish}\ttfamily
l.concat() \ \# '123'}

{\selectlanguage{spanish}\ttfamily
l.concat({\textquotedbl}, {\textquotedbl}) \ \# '1, 2, 3'}

\paragraph[Método push]{\foreignlanguage{spanish}{Método }\textstyleSourceText{\foreignlanguage{spanish}{push}}}
\hypertarget{RefHeadingToc357493639824055}{}\foreignlanguage{spanish}{Agrega un elemento al final del contenedor
}\textstyleSourceText{\foreignlanguage{spanish}{list}}\foreignlanguage{spanish}{. El prototipo de este método es
}\textstyleSourceText{\foreignlanguage{spanish}{push(valor)}}\foreignlanguage{spanish}{, el parámetro
}\textstyleSourceText{\foreignlanguage{spanish}{valor}}\foreignlanguage{spanish}{ es el valor que se agregará, y el
valor agregado se almacena al final del contenedor
}\textstyleSourceText{\foreignlanguage{spanish}{list}}\foreignlanguage{spanish}{. La operación de agregar aumenta el
número de elementos en el contenedor }\textstyleSourceText{\foreignlanguage{spanish}{list}}\foreignlanguage{spanish}{
en 1. Puede agregar cualquier tipo de valor a la instancia de
}\textstyleSourceText{\foreignlanguage{spanish}{lista}}\foreignlanguage{spanish}{.}

\paragraph[Método insert]{\foreignlanguage{spanish}{Método }\textstyleSourceText{\foreignlanguage{spanish}{insert}}}
\hypertarget{RefHeadingToc357513639824055}{}\foreignlanguage{spanish}{Inserta un elemento en la posición especificada
del contenedor }\textstyleSourceText{\foreignlanguage{spanish}{list}}\foreignlanguage{spanish}{. El prototipo de este
método es }\textstyleSourceText{\foreignlanguage{spanish}{insert(indice, valor)}}\foreignlanguage{spanish}{, el
parámetro }\textstyleSourceText{\foreignlanguage{spanish}{indice}}\foreignlanguage{spanish}{ es la posición a insertar,
y }\textstyleSourceText{\foreignlanguage{spanish}{valor}}\foreignlanguage{spanish}{ es el valor a insertar. Después de
insertar un elemento en la posición }\textstyleSourceText{\foreignlanguage{spanish}{indice}}\foreignlanguage{spanish}{,
todos los elementos que originalmente comenzaron desde esta posición se moverán hacia atrás un elemento. La operación
de inserción aumenta el número de elementos en el contenedor
}\textstyleSourceText{\foreignlanguage{spanish}{list}}\foreignlanguage{spanish}{ en 1. Puede insertar cualquier tipo de
valor en el contenedor }\textstyleSourceText{\foreignlanguage{spanish}{list}}\foreignlanguage{spanish}{.}

\foreignlanguage{spanish}{Supongamos que el valor de una instancia de
}\textstyleSourceText{\foreignlanguage{spanish}{lista}}\foreignlanguage{spanish}{
}\textstyleSourceText{\foreignlanguage{spanish}{l}}\foreignlanguage{spanish}{ es
}\textstyleSourceText{\foreignlanguage{spanish}{[0, 1, 2]}}\foreignlanguage{spanish}{, e insertamos una cadena
}\textstyleSourceText{\foreignlanguage{spanish}{{}'cadena'}}\foreignlanguage{spanish}{ en la posición 1, y necesitamos
llamar a }\textstyleSourceText{\foreignlanguage{spanish}{l.insert(1, 'cadena')}}\foreignlanguage{spanish}{. Finalmente,
el nuevo valor de }\textstyleSourceText{\foreignlanguage{spanish}{lista}}\foreignlanguage{spanish}{ es
}\textstyleSourceText{\foreignlanguage{spanish}{[0, 'cadena', 1, 2]}}\foreignlanguage{spanish}{.}

\foreignlanguage{spanish}{Si el número de elementos en un contenedor
}\textstyleSourceText{\foreignlanguage{spanish}{list}}\foreignlanguage{spanish}{ es
}\foreignlanguage{spanish}{\textit{S}}\foreignlanguage{spanish}{, el rango de valores de la posición de inserción es
\{}\foreignlanguage{spanish}{\textit{i}}\foreignlanguage{spanish}{ ${\in}$ $\mathbb{Z}$ : $-$
}\foreignlanguage{spanish}{\textit{S}}\foreignlanguage{spanish}{ ${\leq}$
}\foreignlanguage{spanish}{\textit{i}}\foreignlanguage{spanish}{ {\textless}
}\foreignlanguage{spanish}{\textit{S}}\foreignlanguage{spanish}{\}. Cuando la posición de inserción es positiva, indexa
hacia atrás desde el principio del contenedor
}\textstyleSourceText{\foreignlanguage{spanish}{list}}\foreignlanguage{spanish}{; de lo contrario, indexa hacia
adelante desde el final del contenedor
}\textstyleSourceText{\foreignlanguage{spanish}{list}}\foreignlanguage{spanish}{.}

\paragraph[Método remove]{\foreignlanguage{spanish}{Método }\textstyleSourceText{\foreignlanguage{spanish}{remove}}}
\hypertarget{RefHeadingToc357533639824055}{}\foreignlanguage{spanish}{Quita un elemento del contenedor. El prototipo de
este método es }\textstyleSourceText{\foreignlanguage{spanish}{remove(indice)}}\foreignlanguage{spanish}{, y el
parámetro }\textstyleSourceText{\foreignlanguage{spanish}{indice}}\foreignlanguage{spanish}{ es la posición del
elemento a eliminar. Después de eliminar el elemento, el elemento detrás del elemento eliminado avanzará un elemento y
la cantidad de elementos en el contenedor se reducirá en 1. Al igual que el método
}\textstyleSourceText{\foreignlanguage{spanish}{insert}}\foreignlanguage{spanish}{, el método
}\textstyleSourceText{\foreignlanguage{spanish}{remove}}\foreignlanguage{spanish}{ también puede usar índices positivos
o negativos.}

\paragraph[Método item]{\foreignlanguage{spanish}{Método }\textstyleSourceText{\foreignlanguage{spanish}{item}}}
\hypertarget{RefHeadingToc357553639824055}{}\foreignlanguage{spanish}{Obtiene un elemento en el contenedor
}\textstyleSourceText{\foreignlanguage{spanish}{list}}\foreignlanguage{spanish}{. El prototipo de este método es
}\textstyleSourceText{\foreignlanguage{spanish}{item(indice)}}\foreignlanguage{spanish}{, el parámetro
}\textstyleSourceText{\foreignlanguage{spanish}{indice}}\foreignlanguage{spanish}{ es el índice del elemento a obtener,
y el valor de retorno del método es el elemento en la posición del índice.
}\textstyleSourceText{\foreignlanguage{spanish}{list}}\foreignlanguage{spanish}{ El contenedor admite múltiples métodos
de indexación:}

\liststyleLvii
\begin{itemize}
\item \foreignlanguage{spanish}{Índice entero: El valor del índice puede ser un número entero positivo o un entero
negativo. Si el índice es negativo, es relativo al final de la lista; es decir,
}\textstyleSourceText{\foreignlanguage{spanish}{{}-1}}\foreignlanguage{spanish}{ indica el último elemento de la lista.
El valor de retorno de }\textstyleSourceText{\foreignlanguage{spanish}{item}}\foreignlanguage{spanish}{ es el elemento
en la posición del índice. Si la posición del índice excede el número de elementos en el contenedor o está antes del
elemento 0, el método }\textstyleSourceText{\foreignlanguage{spanish}{item}}\foreignlanguage{spanish}{ devuelve
}\textstyleSourceText{\foreignlanguage{spanish}{nil}}\foreignlanguage{spanish}{.}
\item \foreignlanguage{spanish}{Índice }\textstyleSourceText{\foreignlanguage{spanish}{list}}\foreignlanguage{spanish}{:
Utilizando una lista de enteros como índice,
}\textstyleSourceText{\foreignlanguage{spanish}{item}}\foreignlanguage{spanish}{ devuelve una
}\textstyleSourceText{\foreignlanguage{spanish}{lista}}\foreignlanguage{spanish}{, y cada elemento en el valor devuelto
}\textstyleSourceText{\foreignlanguage{spanish}{lista}}\foreignlanguage{spanish}{ es un elemento correspondiente a cada
índice entero en el parámetro }\textstyleSourceText{\foreignlanguage{spanish}{lista}}\foreignlanguage{spanish}{. los el
valor de la expresión }\textstyleSourceText{\foreignlanguage{spanish}{[3, 2, 1].item([0,
2])}}\foreignlanguage{spanish}{ es }\textstyleSourceText{\foreignlanguage{spanish}{[3, 1]}}\foreignlanguage{spanish}{.
Si una tipo de elemento en el parámetro
}\textstyleSourceText{\foreignlanguage{spanish}{lista}}\foreignlanguage{spanish}{ no es un número entero, entonces el
el valor en esa posición en el valor de retorno
}\textstyleSourceText{\foreignlanguage{spanish}{lista}}\foreignlanguage{spanish}{ es
}\textstyleSourceText{\foreignlanguage{spanish}{nil}}\foreignlanguage{spanish}{.}
\item \foreignlanguage{spanish}{Índice
}\textstyleSourceText{\foreignlanguage{spanish}{range}}\foreignlanguage{spanish}{: Usando un rango de enteros como
índice, }\textstyleSourceText{\foreignlanguage{spanish}{item}}\foreignlanguage{spanish}{ devuelve una
}\textstyleSourceText{\foreignlanguage{spanish}{lista}}\foreignlanguage{spanish}{. El valor devuelto almacena los
elementos indexados de la }\textstyleSourceText{\foreignlanguage{spanish}{lista}}\foreignlanguage{spanish}{ desde el
límite inferior hasta el límite superior del parámetro
}\textstyleSourceText{\foreignlanguage{spanish}{range}}\foreignlanguage{spanish}{. Si el índice excede el rango de
índice de la 'lista' indexada, el retorno value
}\textstyleSourceText{\foreignlanguage{spanish}{list}}\foreignlanguage{spanish}{ usará
}\textstyleSourceText{\foreignlanguage{spanish}{nil}}\foreignlanguage{spanish}{ para llenar la posición más allá del
índice.}
\end{itemize}
\paragraph[Método setitem]{\foreignlanguage{spanish}{Método }\textstyleSourceText{\foreignlanguage{spanish}{setitem}}}
\hypertarget{RefHeadingToc357573639824055}{}\foreignlanguage{spanish}{Establece el valor de la posición especificada en
el contenedor. El prototipo de este método es }\textstyleSourceText{\foreignlanguage{spanish}{setitem(indice,
valor)}}\foreignlanguage{spanish}{, }\textstyleSourceText{\foreignlanguage{spanish}{indice}}\foreignlanguage{spanish}{
es la posición del elemento a escribir y
}\textstyleSourceText{\foreignlanguage{spanish}{valor}}\foreignlanguage{spanish}{ es el valor a escribir.
}\textstyleSourceText{\foreignlanguage{spanish}{indice}}\foreignlanguage{spanish}{ es el valor de índice entero de la
posición de escritura. Las posiciones de índice fuera del rango de índice del contenedor harán que
}\textstyleSourceText{\foreignlanguage{spanish}{setitem}}\foreignlanguage{spanish}{ no se ejecute.}

\paragraph[Método size]{\foreignlanguage{spanish}{Método }\textstyleSourceText{\foreignlanguage{spanish}{size}}}
\hypertarget{RefHeadingToc357593639824055}{}\foreignlanguage{spanish}{Devuelve el número de elementos en el contenedor,
que es la longitud del contenedor. El prototipo de este método es
}\textstyleSourceText{\foreignlanguage{spanish}{size()}}\foreignlanguage{spanish}{.}

\paragraph[Método resize]{\foreignlanguage{spanish}{Método }\textstyleSourceText{\foreignlanguage{spanish}{resize}}}
\hypertarget{RefHeadingToc357613639824055}{}\foreignlanguage{spanish}{Restablece la
}\textstyleSourceText{\foreignlanguage{spanish}{lista}}\foreignlanguage{spanish}{ a la longitud del contenedor. El
prototipo de este método es }\textstyleSourceText{\foreignlanguage{spanish}{resize(count)}}\foreignlanguage{spanish}{,
y el parámetro }\textstyleSourceText{\foreignlanguage{spanish}{count}}\foreignlanguage{spanish}{ es la nueva longitud
del contenedor. Al usar }\textstyleSourceText{\foreignlanguage{spanish}{resize}}\foreignlanguage{spanish}{ para
aumentar la longitud del contenedor, el nuevo elemento se inicializará en
}\textstyleSourceText{\foreignlanguage{spanish}{nil}}\foreignlanguage{spanish}{. El uso de
}\textstyleSourceText{\foreignlanguage{spanish}{resize}}\foreignlanguage{spanish}{ para reducir la longitud del
contenedor descartará algunos elementos al final del contenedor. P.ej:}


\bigskip

{\selectlanguage{spanish}\ttfamily
l = [1, 2, 3]}

{\selectlanguage{spanish}\ttfamily
l.resize(5) \# Expansion, l == [1, 2, 3, nil, nil]}

{\selectlanguage{spanish}\ttfamily
l.resize(2) \# Reduce, l == [1, 2]}

\paragraph[Método iter]{\foreignlanguage{spanish}{Método }\textstyleSourceText{\foreignlanguage{spanish}{iter}}}
\hypertarget{RefHeadingToc357633639824055}{}\foreignlanguage{spanish}{Devuelve un iterador para recorrer el contenedor
}\textstyleSourceText{\foreignlanguage{spanish}{list}}\foreignlanguage{spanish}{ actual.}

\paragraph[Método find]{\foreignlanguage{spanish}{Método }\textstyleSourceText{\foreignlanguage{spanish}{find}}}
\hypertarget{RefHeadingToc357653639824055}{}\foreignlanguage{spanish}{Similar a
}\textstyleSourceText{\foreignlanguage{spanish}{item}}\foreignlanguage{spanish}{ o
}\textstyleSourceText{\foreignlanguage{spanish}{list[idx]}}\foreignlanguage{spanish}{. La única diferencia es que si el
índice está fuera de rango, }\textstyleSourceText{\foreignlanguage{spanish}{find}}\foreignlanguage{spanish}{ devuelve
}\textstyleSourceText{\foreignlanguage{spanish}{nil}}\foreignlanguage{spanish}{ en su lugar o genera una excepción.}

\paragraph[Método reverse]{\foreignlanguage{spanish}{Método }\textstyleSourceText{\foreignlanguage{spanish}{reverse}}}
\hypertarget{RefHeadingToc357673639824055}{}{\selectlanguage{spanish}
Cambia la lista en el lugar e invierte el orden de los elementos. También devuelve la lista resultante.}

\subsubsection[7.1.3 Clase map]{\foreignlanguage{spanish}{7.1.3 }\foreignlanguage{spanish}{Clase
}\textstyleSourceText{\foreignlanguage{spanish}{map}}}
\hypertarget{RefHeadingToc357693639824055}{}\foreignlanguage{spanish}{La clase
}\textstyleSourceText{\foreignlanguage{spanish}{map}}\foreignlanguage{spanish}{ es un tipo de clase incorporado que se
utiliza para proporcionar un contenedor desordenado de pares clave-valor. Dentro del intérprete de Berry,
}\textstyleSourceText{\foreignlanguage{spanish}{map}}\foreignlanguage{spanish}{ usa la tabla Hash para su
implementación. Puede utilizar pares de llaves para construir un contenedor
}\textstyleSourceText{\foreignlanguage{spanish}{map}}\foreignlanguage{spanish}{. El uso de un par de llaves vacías
}\textstyleSourceText{\foreignlanguage{spanish}{\{\}}}\foreignlanguage{spanish}{ generará una instancia de
}\textstyleSourceText{\foreignlanguage{spanish}{map}}\foreignlanguage{spanish}{ vacía. Si necesita construir una
instancia de }\textstyleSourceText{\foreignlanguage{spanish}{map}}\foreignlanguage{spanish}{ que no esté vacía, use dos
puntos para separar la clave y el valor, y use un punto y coma para separar varios pares clave-valor. Por ejemplo,
}\textstyleSourceText{\foreignlanguage{spanish}{\{0: 1, 2: 3\}}}\foreignlanguage{spanish}{ tiene dos pares clave-valor
(0,1) y (2,3). También puede obtener una instancia de
}\textstyleSourceText{\foreignlanguage{spanish}{map}}\foreignlanguage{spanish}{ vacía llamando a la clase
}\textstyleSourceText{\foreignlanguage{spanish}{map}}\foreignlanguage{spanish}{.}

\paragraph[Método map (Constructor)]{\foreignlanguage{spanish}{Método
}\textstyleSourceText{\foreignlanguage{spanish}{map}}\foreignlanguage{spanish}{ (Constructor)}}
\hypertarget{RefHeadingToc357713639824055}{}\foreignlanguage{spanish}{Inicializa el contenedor
}\textstyleSourceText{\foreignlanguage{spanish}{map}}\foreignlanguage{spanish}{, este método no acepta parámetros.
Ejecutar }\textstyleSourceText{\foreignlanguage{spanish}{map()}}\foreignlanguage{spanish}{ obtendrá una instancia de
}\textstyleSourceText{\foreignlanguage{spanish}{map}}\foreignlanguage{spanish}{ vacía.}

\paragraph[Método tostring]{\foreignlanguage{spanish}{Método }\textstyleSourceText{\foreignlanguage{spanish}{tostring}}}
\hypertarget{RefHeadingToc357733639824055}{}\foreignlanguage{spanish}{Serializa
}\textstyleSourceText{\foreignlanguage{spanish}{map}}\foreignlanguage{spanish}{ como una cadena y regresa. La cadena
serializada es similar a la escritura literal. Por ejemplo, el resultado de ejecutar
}\textstyleSourceText{\foreignlanguage{spanish}{{}'str': 1, 0: 2}}\foreignlanguage{spanish}{ es
}\textstyleSourceText{\foreignlanguage{spanish}{{\textquotedbl}'str': 1, 0:
2{\textquotedbl}}}\foreignlanguage{spanish}{. Si el contenedor
}\textstyleSourceText{\foreignlanguage{spanish}{map}}\foreignlanguage{spanish}{ se refiere a sí mismo, la posición
correspondiente utilizará puntos suspensivos en lugar del valor específico:}


\bigskip

{\selectlanguage{spanish}\ttfamily
m = \{'map': nil,'texto':'hola'\}}

{\selectlanguage{spanish}\ttfamily
m['map'] = m}

{\selectlanguage{spanish}\ttfamily
print(m) \# \{'texto':'hola','map': \{...\}\}}

\paragraph[Método insert]{\foreignlanguage{spanish}{Método }\textstyleSourceText{\foreignlanguage{spanish}{insert}}}
\hypertarget{RefHeadingToc357753639824055}{}\foreignlanguage{spanish}{Inserta un par clave-valor en el contenedor
}\textstyleSourceText{\foreignlanguage{spanish}{map}}\foreignlanguage{spanish}{. El prototipo de este método es
}\textstyleSourceText{\foreignlanguage{spanish}{insert(llave, valor)}}\foreignlanguage{spanish}{, el parámetro
}\textstyleSourceText{\foreignlanguage{spanish}{llave}}\foreignlanguage{spanish}{ es la clave a insertar, y
}\textstyleSourceText{\foreignlanguage{spanish}{valor}}\foreignlanguage{spanish}{ es el valor a insertar. Si el
}\textstyleSourceText{\foreignlanguage{spanish}{map}}\foreignlanguage{spanish}{ clave que se va a insertar existe en el
contenedor, se actualizará el par clave-valor original.}

\paragraph[Método remove]{\foreignlanguage{spanish}{Método }\textstyleSourceText{\foreignlanguage{spanish}{remove}}}
\hypertarget{RefHeadingToc357773639824055}{}\foreignlanguage{spanish}{Elimina un par clave-valor del contenedor
}\textstyleSourceText{\foreignlanguage{spanish}{map}}\foreignlanguage{spanish}{. El prototipo de este método es
}\textstyleSourceText{\foreignlanguage{spanish}{remove(llave)}}\foreignlanguage{spanish}{, y el parámetro
}\textstyleSourceText{\foreignlanguage{spanish}{llave}}\foreignlanguage{spanish}{ es la clave del par clave-valor que
se eliminará.}

\paragraph[Método item]{\foreignlanguage{spanish}{Método }\textstyleSourceText{\foreignlanguage{spanish}{item}}}
\hypertarget{RefHeadingToc357793639824055}{}\foreignlanguage{spanish}{Obtiene un valor en el contenedor
}\textstyleSourceText{\foreignlanguage{spanish}{map}}\foreignlanguage{spanish}{. El prototipo de este método es
}\textstyleSourceText{\foreignlanguage{spanish}{item(llave)}}\foreignlanguage{spanish}{, el parámetro
}\textstyleSourceText{\foreignlanguage{spanish}{llave}}\foreignlanguage{spanish}{ es la clave del valor a obtener, y el
valor de retorno del método es el valor correspondiente a la clave.}

\paragraph[Método setitem]{\foreignlanguage{spanish}{Método }\textstyleSourceText{\foreignlanguage{spanish}{setitem}}}
\hypertarget{RefHeadingToc357813639824055}{}\foreignlanguage{spanish}{Establece el valor correspondiente a la clave
especificada en el contenedor. El prototipo de este método es
}\textstyleSourceText{\foreignlanguage{spanish}{setitem(clave, valor)}}\foreignlanguage{spanish}{,
}\textstyleSourceText{\foreignlanguage{spanish}{clave}}\foreignlanguage{spanish}{ es la clave del par clave-valor a
escribir, y }\textstyleSourceText{\foreignlanguage{spanish}{valor}}\foreignlanguage{spanish}{ es el valor a escribir.
Si no hay un par clave-valor con la clave
}\textstyleSourceText{\foreignlanguage{spanish}{clave}}\foreignlanguage{spanish}{ en el contenedor, el método
}\textstyleSourceText{\foreignlanguage{spanish}{setitem}}\foreignlanguage{spanish}{ fallará.}

\paragraph[Método size]{\foreignlanguage{spanish}{Método }\textstyleSourceText{\foreignlanguage{spanish}{size}}}
\hypertarget{RefHeadingToc357833639824055}{}\foreignlanguage{spanish}{Devuelve el número de pares clave-valor del
contenedor }\textstyleSourceText{\foreignlanguage{spanish}{map}}\foreignlanguage{spanish}{, que es la longitud del
contenedor. El prototipo de este método es
}\textstyleSourceText{\foreignlanguage{spanish}{size()}}\foreignlanguage{spanish}{.}

\paragraph[Método contains]{\foreignlanguage{spanish}{Método }\textstyleSourceText{\foreignlanguage{spanish}{contains}}}
\hypertarget{RefHeadingToc357853639824055}{}\foreignlanguage{spanish}{Devuelve
}\textstyleSourceText{\foreignlanguage{spanish}{true}}\foreignlanguage{spanish}{ booleano si se encuentra un par
clave-valor coincidente en el contenedor
}\textstyleSourceText{\foreignlanguage{spanish}{map}}\foreignlanguage{spanish}{; de lo contrario,
}\textstyleSourceText{\foreignlanguage{spanish}{false}}\foreignlanguage{spanish}{. El prototipo de este método es
}\textstyleSourceText{\foreignlanguage{spanish}{contains(llave)}}\foreignlanguage{spanish}{.}

\paragraph[Método find]{\foreignlanguage{spanish}{Método }\textstyleSourceText{\foreignlanguage{spanish}{find}}}
\hypertarget{RefHeadingToc357873639824055}{}\foreignlanguage{spanish}{Devuelve el valor correspondiente a la clave
especificada en el contenedor. El prototipo de este método es
}\textstyleSourceText{\foreignlanguage{spanish}{find(llave)}}\foreignlanguage{spanish}{ o
}\textstyleSourceText{\foreignlanguage{spanish}{find(llave, valor\_defecto)}}\foreignlanguage{spanish}{,
}\textstyleSourceText{\foreignlanguage{spanish}{llave}}\foreignlanguage{spanish}{ es la clave del par clave-valor al
que se accederá, y }\textstyleSourceText{\foreignlanguage{spanish}{valor\_defecto}}\foreignlanguage{spanish}{ es el
valor predeterminado devuelto si la clave no se encuentra. Si no se especifica ningún valor predeterminado, se devuelve
}\textstyleSourceText{\foreignlanguage{spanish}{nil}}\foreignlanguage{spanish}{ en su lugar.}

\subsubsection[7.1.4 Clase range]{\foreignlanguage{spanish}{7.1.4 }\foreignlanguage{spanish}{Clase
}\textstyleSourceText{\foreignlanguage{spanish}{range}}}
\hypertarget{RefHeadingToc357893639824055}{}\foreignlanguage{spanish}{La clase se usa para representar un intervalo
cerrado entero. Utilice el operador binario
}\textstyleSourceText{\foreignlanguage{spanish}{..}}\foreignlanguage{spanish}{ para construir una instancia de
}\textstyleSourceText{\foreignlanguage{spanish}{range}}\foreignlanguage{spanish}{. Los operandos izquierdo y derecho
del operador deben ser números enteros. Por ejemplo,
}\textstyleSourceText{\foreignlanguage{spanish}{0..10}}\foreignlanguage{spanish}{ significa el intervalo entero [0,10]
${\cap}$ $\mathbb{Z}$.}

\foreignlanguage{spanish}{Si no especifica el rango alto, se establece en
}\textstyleSourceText{\foreignlanguage{spanish}{MAXINT}}\foreignlanguage{spanish}{. Ejemplo:
}\textstyleSourceText{\foreignlanguage{spanish}{imprimir(0..) \# (0..9223372036854775807)}}

{\selectlanguage{spanish}
Por lo general, hay dos formas de recorrer una lista:}


\bigskip

{\selectlanguage{spanish}\ttfamily
l = [1,2,3,4]}

{\selectlanguage{spanish}\ttfamily
for e:l print(e) end \# 1/2/3/4}

{\selectlanguage{spanish}\ttfamily
for i:0..size(l)-1 print(l[i]) end \# 1/2/3/4}

\subsubsection[Clase bytes]{\foreignlanguage{spanish}{Clase }\textstyleSourceText{\foreignlanguage{spanish}{bytes}}}
\hypertarget{RefHeadingToc357913639824055}{}\foreignlanguage{spanish}{Los objetos
}\textstyleSourceText{\foreignlanguage{spanish}{bytes}}\foreignlanguage{spanish}{ se representan como matrices de bytes
hexadecimales. El constructor }\textstyleSourceText{\foreignlanguage{spanish}{bytes}}\foreignlanguage{spanish}{ toma
una cadena de Hex y construye el búfer en memoria.}

{\selectlanguage{spanish}
Ejemplo:}


\bigskip

{\selectlanguage{spanish}\ttfamily
b = bytes()}

{\selectlanguage{spanish}\ttfamily
print(b) \ \ \# bytes('{}')}

{\selectlanguage{spanish}\ttfamily
b = bytes({\textquotedbl}1155AA{\textquotedbl}) \ \# secuencia de bytes 0x11 0x55 0xAA}

{\selectlanguage{spanish}\ttfamily
size(b) \ \# 3 = 3 bytes}

{\selectlanguage{spanish}\ttfamily
b[0] \ \ \ \ \# 17 (0x11)}

{\selectlanguage{spanish}\ttfamily
b[0] = 16 \ \# \ asigna el primer byte}

{\selectlanguage{spanish}\ttfamily
print(b) \ \ \# bytes('1055AA')}

\paragraph[Método bytes (Constructor)]{\foreignlanguage{spanish}{Método
}\textstyleSourceText{\foreignlanguage{spanish}{bytes}}\foreignlanguage{spanish}{ (Constructor)}}
\hypertarget{RefHeadingToc357933639824055}{}{\selectlanguage{spanish}
Inicializar una matriz de bytes. Hay varias opciones.}

{\selectlanguage{spanish}\bfseries
Opción 1: valor vacío}

\textstyleSourceText{\foreignlanguage{spanish}{bytes()}}\foreignlanguage{spanish}{ crea una nueva matriz de bytes vacía.
}\textstyleSourceText{\foreignlanguage{spanish}{tamaño(bytes()) == 0}}\foreignlanguage{spanish}{.}

{\selectlanguage{spanish}
No hay límite en el tamaño de una matriz de bytes, excepto la memoria disponible. Se asigna un búfer interno y se
reasigna en caso de que el anterior fuera demasiado pequeño. El búfer inicial es de 36 bytes, pero puede preasignar un
búfer más grande (o más pequeño) si sabe de antemano el tamaño necesario.}

{\selectlanguage{spanish}
De manera similar, el búfer se reduce automáticamente si se usa menos del tamaño necesario.}


\bigskip

{\selectlanguage{spanish}\ttfamily
b = bytes(4096) \ \ \# 4096 bytes preasignados}


\bigskip

{\selectlanguage{spanish}\bfseries
Opción 2: valor inicial}

{\selectlanguage{spanish}
Si el primer argumento es una {\textquotedbl}cadena{\textquotedbl}, se analiza como una lista de valores hexadecimales.
Puede agregar un segundo argumento opcional para preasignar un búfer más grande.}


\bigskip

{\selectlanguage{spanish}\ttfamily
b = bytes({\textquotedbl}BEEF0000{\textquotedbl})}

{\selectlanguage{spanish}\ttfamily
print(b) \ \ \# bytes('beef0000')}

{\selectlanguage{spanish}\ttfamily
b = bytes({\textquotedbl}112233{\textquotedbl}, 128) \ \ \# \ preasignar 128 bytes internamente}

{\selectlanguage{spanish}\ttfamily
print(b) \ \ \# bytes('112233')}


\bigskip

{\selectlanguage{spanish}\bfseries
Opción 3: tamaño fijo}

{\selectlanguage{spanish}
Si el tamaño proporcionado es negativo, el tamaño de la matriz es fijo y no se puede reducir ni aumentar.}


\bigskip

{\selectlanguage{spanish}\ttfamily
b = bytes(-8)}

{\selectlanguage{spanish}\ttfamily
print(b) \ \ \# bytes('0000000000000000')}


\bigskip

{\selectlanguage{spanish}\ttfamily
b = bytes({\textquotedbl}AA{\textquotedbl}, -4)}

{\selectlanguage{spanish}\ttfamily
print(b) \ \ \# bytes('AA000000')}


\bigskip

{\selectlanguage{spanish}\ttfamily
b = bytes({\textquotedbl}1122334455{\textquotedbl}, -4)}

{\selectlanguage{spanish}\ttfamily
atributo\_error: tamaño del objeto en bytes es fijo y no se puede cambiar el tamaño}


\bigskip

{\selectlanguage{spanish}\bfseries
Opción 4: asignación de memoria}

{\selectlanguage{spanish}\bfseries
Precaución, use con mucho cuidado}

\foreignlanguage{spanish}{En este modo, la matriz de bytes se asigna a una región específica de la memoria. Debe
proporcionar la dirección base como }\textstyleSourceText{\foreignlanguage{spanish}{comptr}}\foreignlanguage{spanish}{
y el tamaño. El tamaño siempre se fija, ya sea positivo o negativo. Esta función es
}\foreignlanguage{spanish}{\textbf{peligrosa}}\foreignlanguage{spanish}{ ya que puede acceder a cualquier ubicación de
la memoria, lo que provoca un bloqueo si la ubicación está protegida o no es válida. Usar con cuidado.}

\foreignlanguage{spanish}{En este caso,
}\textstyleSourceText{\foreignlanguage{spanish}{b.ismapped()}}\foreignlanguage{spanish}{ devuelve
}\textstyleSourceText{\foreignlanguage{spanish}{true}}\foreignlanguage{spanish}{ indicando un búfer de memoria mapeado.
En todos los demás casos, }\textstyleSourceText{\foreignlanguage{spanish}{b.ismapped()}}\foreignlanguage{spanish}{
devuelve }\textstyleSourceText{\foreignlanguage{spanish}{falso}}\foreignlanguage{spanish}{. Esto se usa típicamente
para saber si Berry asignó el búfer o no, y si los subelementos deben desasignarse explícitamente.}

{\selectlanguage{spanish}
Ejemplo:}


\bigskip

{\selectlanguage{spanish}\ttfamily
import introspect}

{\selectlanguage{spanish}\ttfamily
def f() return 0 end}


\bigskip

{\selectlanguage{spanish}\ttfamily
addr = introspect.toptr(f)}

{\selectlanguage{spanish}\ttfamily
print(addr) \ \ \# {\textless}ptr: 0x3ffeaf88{\textgreater}}


\bigskip

{\selectlanguage{spanish}\ttfamily
b = bytes(addr, 8)}

{\selectlanguage{spanish}\ttfamily
print(b) \ \ \# bytes('F8EAFE3F24000000')}

{\selectlanguage{spanish}\ttfamily
\# \ este ejemplo muestra los primeros 8 bytes del objeto de función en la memoria}

\paragraph[Método size]{\foreignlanguage{spanish}{Método }\textstyleSourceText{\foreignlanguage{spanish}{size}}}
\hypertarget{RefHeadingToc357953639824055}{}{\selectlanguage{spanish}
Devuelve el número de bytes en la matriz de bytes}


\bigskip

{\selectlanguage{spanish}\ttfamily
b = bytes({\textquotedbl}1122334455{\textquotedbl})}

{\selectlanguage{spanish}\ttfamily
b.size() \ \ \# 5}

{\selectlanguage{spanish}\ttfamily
size(b) \ \ \ \# 5}

\paragraph[Método tostring]{\foreignlanguage{spanish}{Método }\textstyleSourceText{\foreignlanguage{spanish}{tostring}}}
\hypertarget{RefHeadingToc357973639824055}{}\foreignlanguage{spanish}{Muestra una forma legible por humanos la matriz de
bytes en hexadecimal. Por defecto, muestra solo los primeros 32 caracteres. Puede solicitar más caracteres agregando un
argumento int con la cantidad máxima de bytes que desea convertir.
}\textstyleSourceText{\foreignlanguage{spanish}{tostring}}\foreignlanguage{spanish}{ se usa internamente cuando se
imprime un objeto. }\textstyleSourceText{\foreignlanguage{spanish}{print(b)}}\foreignlanguage{spanish}{ es equivalente
a }\textstyleSourceText{\foreignlanguage{spanish}{print(b.tostring())}}\foreignlanguage{spanish}{. Es diferente de
}\textstyleSourceText{\foreignlanguage{spanish}{asstring}}\foreignlanguage{spanish}{, que convierte una matriz de bytes
en el objeto de cadena de bajo nivel equivalente sin ninguna codificación.}


\bigskip

{\selectlanguage{spanish}\ttfamily
b = bytes({\textquotedbl}1122334455{\textquotedbl})}

{\selectlanguage{spanish}\ttfamily
b.tostring() \ \ \# 'bytes({\textbackslash}'1122334455{\textbackslash}')'}


\bigskip

{\selectlanguage{spanish}\ttfamily
b = bytes()}

{\selectlanguage{spanish}\ttfamily
b.resize(64) \ \ \# redimenciona a 64 bytes}

{\selectlanguage{spanish}\ttfamily
b.tostring() \ \ \#
'bytes({\textbackslash}'0000000000000000000000000000000000000000000000000000000000000000...{\textbackslash}')'}

{\selectlanguage{spanish}\ttfamily
b.tostring(500) \#
'bytes({\textbackslash}'00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000{\textbackslash}')'}

\paragraph[Método tohex]{\foreignlanguage{spanish}{Método }\textstyleSourceText{\foreignlanguage{spanish}{tohex}}}
\hypertarget{RefHeadingToc357993639824055}{}\foreignlanguage{spanish}{Convierte la matriz de bytes en una cadena
hexadecimal, similar a la devuelta por
}\textstyleSourceText{\foreignlanguage{spanish}{tostring()}}\foreignlanguage{spanish}{ pero sin decoradores.}


\bigskip

{\selectlanguage{spanish}\ttfamily
b = bytes({\textquotedbl}1122334455{\textquotedbl})}

{\selectlanguage{spanish}\ttfamily
b.tohex() \ \ \# '1122334455'}

\paragraph[Método fromhex]{\foreignlanguage{spanish}{Método }\textstyleSourceText{\foreignlanguage{spanish}{fromhex}}}
\hypertarget{RefHeadingToc358013639824055}{}{\selectlanguage{spanish}
Actualiza el contenido de la matriz de bytes a partir de una nueva cadena hexadecimal. Esto permite cargar una nueva
cadena hexadecimal sin asignar un nuevo objeto de bytes.}


\bigskip

{\selectlanguage{spanish}\ttfamily
b = bytes({\textquotedbl}1122334455{\textquotedbl})}

{\selectlanguage{spanish}\ttfamily
b.fromhex({\textquotedbl}AABBCC{\textquotedbl}) \ \# bytes('AABBCC')}

\paragraph[Método clear]{\foreignlanguage{spanish}{Método }\textstyleSourceText{\foreignlanguage{spanish}{clear}}}
\hypertarget{RefHeadingToc358033639824055}{}{\selectlanguage{spanish}
Vuelve a poner la matriz de bytes en vacío}


\bigskip

{\selectlanguage{spanish}\ttfamily
b = bytes({\textquotedbl}1122{\textquotedbl})}

{\selectlanguage{spanish}\ttfamily
b.clear()}

{\selectlanguage{spanish}\ttfamily
print(b) \ \ \# bytes()}

\paragraph[Método resize]{\foreignlanguage{spanish}{Método }\textstyleSourceText{\foreignlanguage{spanish}{resize}}}
\hypertarget{RefHeadingToc358053639824055}{}{\selectlanguage{spanish}
Reduce o expande la matriz de bytes para que coincida con el tamaño especificado. Si se expande, se agregan bytes NULL
(0x00) al final del búfer.}


\bigskip

{\selectlanguage{spanish}\ttfamily
b = bytes({\textquotedbl}11223344{\textquotedbl})}

{\selectlanguage{spanish}\ttfamily
b.resize(6)}

{\selectlanguage{spanish}\ttfamily
print(b) \ \ \# bytes('112233440000')}

{\selectlanguage{spanish}\ttfamily
b.resize(2)}

{\selectlanguage{spanish}\ttfamily
print(b) \ \ \# bytes('1122')}

\paragraph[Métodos de concatenación + y ..]{\foreignlanguage{spanish}{Métodos de concatenación
}\textstyleSourceText{\foreignlanguage{spanish}{+}}\foreignlanguage{spanish}{ y
}\textstyleSourceText{\foreignlanguage{spanish}{..}}}
\hypertarget{RefHeadingToc358073639824055}{}\foreignlanguage{spanish}{Puede usar
}\textstyleSourceText{\foreignlanguage{spanish}{+}}\foreignlanguage{spanish}{ para concatenar dos listas de
}\textstyleSourceText{\foreignlanguage{spanish}{bytes}}\foreignlanguage{spanish}{, creando un nuevo objeto
}\textstyleSourceText{\foreignlanguage{spanish}{bytes}}\foreignlanguage{spanish}{.
}\textstyleSourceText{\foreignlanguage{spanish}{..}}\foreignlanguage{spanish}{ cambia la lista en su lugar y se puede
usar para agregar un objeto }\textstyleSourceText{\foreignlanguage{spanish}{int}}\foreignlanguage{spanish}{ (1 byte) o
}\textstyleSourceText{\foreignlanguage{spanish}{bytes.}}


\bigskip

{\selectlanguage{spanish}\ttfamily
b = bytes({\textquotedbl}1122{\textquotedbl})}

{\selectlanguage{spanish}\ttfamily
c = bytes({\textquotedbl}3344{\textquotedbl})}

{\selectlanguage{spanish}\ttfamily
d = b + c \ \ \ \ \ \ \ \ \ \ \# b y c no cambian}

{\selectlanguage{spanish}\ttfamily
print(d) \ \ \ \ \ \ \ \ \ \ \ \# bytes('11223344')}

{\selectlanguage{spanish}\ttfamily
print(b) \ \ \ \ \ \ \ \ \ \ \ \# bytes('1122')}

{\selectlanguage{spanish}\ttfamily
print(c) \ \ \ \ \ \ \ \ \ \ \ \# bytes('3344')}


\bigskip

{\selectlanguage{spanish}\ttfamily
e = b..c \ \ \ \ \ \ \ \ \ \ \ \# ahora b ha cambiado}

{\selectlanguage{spanish}\ttfamily
print(e) \ \ \ \ \ \ \ \ \ \ \ \# bytes('11223344')}

{\selectlanguage{spanish}\ttfamily
print(b) \ \ \ \ \ \ \ \ \ \ \ \# bytes('11223344')}

{\selectlanguage{spanish}\ttfamily
print(c) \ \ \ \ \ \ \ \ \ \ \ \# bytes('3344')}

\paragraph[Método de acceso a bytes [{]}]{\foreignlanguage{spanish}{Método de acceso a bytes
}\textstyleSourceText{\foreignlanguage{spanish}{[]}}}
\hypertarget{RefHeadingToc358093639824055}{}{\selectlanguage{spanish}
Puede acceder a bytes individuales como enteros, para leer y escribir. Los valores que no están en el rango de 0 a 255
se cortan silenciosamente.}


\bigskip

{\selectlanguage{spanish}\ttfamily
b = bytes({\textquotedbl}010203{\textquotedbl})}

{\selectlanguage{spanish}\ttfamily
print(b[0]) \ \ \ \ \ \ \ \ \# 1}


\bigskip

{\selectlanguage{spanish}\ttfamily
\# \ índices negativos cuentan desde el final}

{\selectlanguage{spanish}\ttfamily
print(b[-1]) \ \ \ \ \ \ \ \# 3}


\bigskip

{\selectlanguage{spanish}\ttfamily
\# \ fuera de los límites genera una excepción}

{\selectlanguage{spanish}\ttfamily
print(b[5]) \ \ \ \ \ \ \ \ \# index\_error: índice de bytes fuera de rango}


\bigskip

{\selectlanguage{spanish}\ttfamily
b[0] = -1}

{\selectlanguage{spanish}\ttfamily
print(b) \ \ \ \ \ \ \ \ \ \ \ \# bytes('FF0203')}


\bigskip

{\selectlanguage{spanish}\ttfamily
b[1] = 256}

{\selectlanguage{spanish}\ttfamily
print(b) \ \ \ \ \ \ \ \ \ \ \ \# bytes('FF0003')}

\paragraph[Método de acceso de rango [{]}]{\foreignlanguage{spanish}{Método de acceso de rango
}\textstyleSourceText{\foreignlanguage{spanish}{[]}}}
\hypertarget{RefHeadingToc358113639824055}{}\foreignlanguage{spanish}{Puede usar el descriptor de acceso
}\textstyleSourceText{\foreignlanguage{spanish}{[]}}\foreignlanguage{spanish}{ con un rango para obtener una sublista
de }\textstyleSourceText{\foreignlanguage{spanish}{bytes}}\foreignlanguage{spanish}{. Si un índice es negativo, se toma
del final de la matriz.}

\foreignlanguage{spanish}{Esta construcción no se puede usar como un
}\foreignlanguage{spanish}{\textit{lvalue}}\foreignlanguage{spanish}{, es decir, no se puede empalmar como:}

\textstyleSourceText{\foreignlanguage{spanish}{b[1..2] = bytes({\textquotedbl}0011{\textquotedbl}) \# no
permitido}}\foreignlanguage{spanish}{.}

{\selectlanguage{spanish}\ttfamily
b = bytes({\textquotedbl}001122334455{\textquotedbl})}

{\selectlanguage{spanish}\ttfamily
print(b[1..2]) \ \ \ \ \ \# bytes('1122')}


\bigskip

{\selectlanguage{spanish}\ttfamily
\# elimina los primeros 2 bytes}

{\selectlanguage{spanish}\ttfamily
print(b[2..-1]) \ \ \ \ \# bytes('22334455')}


\bigskip

{\selectlanguage{spanish}\ttfamily
\# eliminar los últimos 2 bytes}

{\selectlanguage{spanish}\ttfamily
print(b[0..-3]) \ \ \ \ \# bytes('00112233')}


\bigskip

{\selectlanguage{spanish}\ttfamily
\# \ se permite el sobreimpulso}

{\selectlanguage{spanish}\ttfamily
print(b[4..10]) \ \ \ \ \# bytes('4455')}


\bigskip

{\selectlanguage{spanish}\ttfamily
\# \ índices invertidos devuelven una matriz vacía}

{\selectlanguage{spanish}\ttfamily
print(b[5..4]) \ \ \ \ \ \# bytes('{}')}


\bigskip

\foreignlanguage{spanish}{Los métodos estándar
}\textstyleSourceText{\foreignlanguage{spanish}{item}}\foreignlanguage{spanish}{ y
}\textstyleSourceText{\foreignlanguage{spanish}{setitem}}\foreignlanguage{spanish}{ se implementan y se asignan de
forma transparente al operador }\textstyleSourceText{\foreignlanguage{spanish}{[]}}\foreignlanguage{spanish}{.}

\paragraph[Método copy]{\foreignlanguage{spanish}{Método }\textstyleSourceText{\foreignlanguage{spanish}{copy}}}
\hypertarget{RefHeadingToc358133639824055}{}\foreignlanguage{spanish}{Crea una nueva copia nueva del objeto
}\textstyleSourceText{\foreignlanguage{spanish}{bytes}}\foreignlanguage{spanish}{. Se asigna un nuevo búfer de memoria
y se duplican los datos.}


\bigskip

{\selectlanguage{spanish}\ttfamily
b = bytes({\textquotedbl}1122{\textquotedbl})}

{\selectlanguage{spanish}\ttfamily
print(b) \ \ \ \ \ \ \ \ \ \# bytes('1122')}


\bigskip

{\selectlanguage{spanish}\ttfamily
c = b.copy()}

{\selectlanguage{spanish}\ttfamily
print(c) \ \ \ \ \ \ \ \ \ \# bytes('1122')}


\bigskip

{\selectlanguage{spanish}\ttfamily
b.clear()}

{\selectlanguage{spanish}\ttfamily
print(b) \ \ \ \ \ \ \ \ \ \# bytes('{}')}

{\selectlanguage{spanish}\ttfamily
print(c) \ \ \ \ \ \ \ \ \ \# bytes('1122')bytes('1122')}

\paragraph[Métodos get, geti]{\foreignlanguage{spanish}{Métodos }\textstyleSourceText{\foreignlanguage{spanish}{get,
geti}}}
\hypertarget{RefHeadingToc358153639824055}{}\foreignlanguage{spanish}{Lea un valor de 1/2/4 bytes de cualquier
desplazamiento en la matriz de bytes. El modo estándar es little endian, si se especifica un tamaño negativo habilita
big endian. }\textstyleSourceText{\foreignlanguage{spanish}{get}}\foreignlanguage{spanish}{ devuelve valores sin signo,
mientras que }\textstyleSourceText{\foreignlanguage{spanish}{geti}}\foreignlanguage{spanish}{ devuelve valores con
signo.}


\bigskip

{\selectlanguage{spanish}\ttfamily
b.get({\textless}offset{\textgreater}, {\textless}size{\textgreater}) -{\textgreater} \ objeto de bytes}


\bigskip

\foreignlanguage{spanish}{Si el desplazamiento está fuera de rango, se devuelve
}\textstyleSourceText{\foreignlanguage{spanish}{0}}\foreignlanguage{spanish}{ (no se genera ninguna excepción).}

{\selectlanguage{spanish}
Ejemplo:}


\bigskip

{\selectlanguage{spanish}\ttfamily
b = bytes({\textquotedbl}010203040506{\textquotedbl})}

{\selectlanguage{spanish}\ttfamily
print(b.get(2,2)) \ \ \ \ \ \ \ \ \# 1027 - 0x0403 read 2 bytes little endian}

{\selectlanguage{spanish}\ttfamily
print(b.get(2,-2)) \ \ \ \ \ \ \ \# \ 772 - 0x0304 read 2 bytes big endian}


\bigskip

{\selectlanguage{spanish}\ttfamily
print(b.get(2,4)) \ \ \ \ \ \ \ \ \# 100992003 - 0x06050403 - little endian}

{\selectlanguage{spanish}\ttfamily
print(b.get(2,-4)) \ \ \ \ \ \ \ \# \ 50595078 - 0x03040506 - big endian}


\bigskip

{\selectlanguage{spanish}\ttfamily
b = bytes({\textquotedbl}FEFF{\textquotedbl})}

{\selectlanguage{spanish}\ttfamily
print(b.get(0, 2)) \ \ \ \ \ \ \ \# 65534 - 0xFFFE}

{\selectlanguage{spanish}\ttfamily
print(b.geti(0, 2)) \ \ \ \ \ \ \# -2 - 0xFFFE}

\paragraph[Métodos set, seti]{\foreignlanguage{spanish}{Métodos }\textstyleSourceText{\foreignlanguage{spanish}{set,
seti}}}
\hypertarget{RefHeadingToc358173639824055}{}\foreignlanguage{spanish}{Similar a
}\textstyleSourceText{\foreignlanguage{spanish}{get}}\foreignlanguage{spanish}{ y
}\textstyleSourceText{\foreignlanguage{spanish}{geti}}\foreignlanguage{spanish}{, permite establecer un valor de 1/2/4
bytes en cualquier desplazamiento. }\textstyleSourceText{\foreignlanguage{spanish}{seti}}\foreignlanguage{spanish}{ usa
números enteros con signo, }\textstyleSourceText{\foreignlanguage{spanish}{set}}\foreignlanguage{spanish}{ no tiene
signo (en realidad, no hace la diferencia).}

{\selectlanguage{spanish}
Si el desplazamiento está fuera de rango, no se realiza ningún cambio (no se genera ninguna excepción).}


\bigskip

{\selectlanguage{spanish}\ttfamily
bytes.set({\textless}offset{\textgreater}, {\textless}valor{\textgreater}, {\textless}tamaño{\textgreater})}

\paragraph[Método add]{\foreignlanguage{spanish}{Método }\textstyleSourceText{\foreignlanguage{spanish}{add}}}
\hypertarget{RefHeadingToc358193639824055}{}{\selectlanguage{spanish}
Este método agrega valor de 1/2/4 bytes (little endian o big endian) al final del búfer. Si el tamaño es negativo, el
valor se trata como big endian.}

{\selectlanguage{spanish}\ttfamily
b.add({\textless}valor{\textgreater}, {\textless}tamaño{\textgreater})}


\bigskip

{\selectlanguage{spanish}
Ejemplo:}


\bigskip

{\selectlanguage{spanish}\ttfamily
b = bytes({\textquotedbl}0011{\textquotedbl})}

{\selectlanguage{spanish}\ttfamily
b.add(0x22, 1)}

{\selectlanguage{spanish}\ttfamily
print(b) \ \ \ \ \ \ \ \ \ \ \ \ \# bytes('001122')}

{\selectlanguage{spanish}\ttfamily
b.add(0x2233, 2)}

{\selectlanguage{spanish}\ttfamily
print(b) \ \ \ \ \ \ \ \ \ \ \ \ \# bytes('0011223322')}

{\selectlanguage{spanish}\ttfamily
b.add(0x22334455, 4)}

{\selectlanguage{spanish}\ttfamily
print(b) \ \ \ \ \ \ \ \ \ \ \ \ \# bytes('001122332255443322')}

{\selectlanguage{spanish}\ttfamily
b.add(0x00)}

{\selectlanguage{spanish}\ttfamily
print(b) \ \ \ \ \ \ \ \ \ \ \ \ \# bytes('00112233225544332200')}

{\selectlanguage{spanish}\ttfamily
b.clear()}

{\selectlanguage{spanish}\ttfamily
b.add(0x0102, -2)}

{\selectlanguage{spanish}\ttfamily
print(b) \ \ \ \ \ \ \ \ \ \ \ \ \# bytes('0102')}

{\selectlanguage{spanish}\ttfamily
b.add(0x01020304, -4)}

{\selectlanguage{spanish}\ttfamily
print(b) \ \ \ \ \ \ \ \ \ \ \ \ \# bytes('010201020304')}

\paragraph[Método asstring]{\foreignlanguage{spanish}{Método }\textstyleSourceText{\foreignlanguage{spanish}{asstring}}}
\hypertarget{RefHeadingToc358213639824055}{}{\selectlanguage{spanish}
Convierte un búfer de bytes en una cadena. El búfer se convierte tal cual sin ninguna consideración de codificación. Si
el búfer contiene caracteres NULL, la cadena se truncará.}


\bigskip

{\selectlanguage{spanish}\ttfamily
b=bytes({\textquotedbl}3344{\textquotedbl})}

{\selectlanguage{spanish}\ttfamily
print(b.asstring()) \ \ \# '3D'}

\paragraph[Método fromstring]{\foreignlanguage{spanish}{Método
}\textstyleSourceText{\foreignlanguage{spanish}{fromstring}}}
\hypertarget{RefHeadingToc358233639824055}{}{\selectlanguage{spanish}
Convierte un búfer de bytes en una cadena. El búfer se convierte tal cual sin ninguna consideración de codificación. Si
el búfer contiene caracteres NULL, la cadena se truncará.}


\bigskip

{\selectlanguage{spanish}\ttfamily
b=bytes().fromstring({\textquotedbl}Hola{\textquotedbl})}

{\selectlanguage{spanish}\ttfamily
print(b) \ \ \ \ \ \ \ \ \ \ \ \ \ \# bytes('48656C6C6F')}

\paragraph[Métodos de manipulación de bits setbits, getbits]{\foreignlanguage{spanish}{Métodos de manipulación de bits
}\textstyleSourceText{\foreignlanguage{spanish}{setbits, getbits}}}
\hypertarget{RefHeadingToc358253639824055}{}{\selectlanguage{spanish}
Puede leer y escribir a nivel de subbytes, especificando de qué bit a qué bit. El desplazamiento está en bits, no en
bytes. Agregue el número de bytes * 8.}


\bigskip

{\selectlanguage{spanish}\ttfamily
b.setbits({\textless}offset\_bits{\textgreater}, {\textless}len\_bits{\textgreater}, {\textless}value{\textgreater})}

{\selectlanguage{spanish}\ttfamily
b.getbits({\textless}offset\_bits{\textgreater}, {\textless}len\_bits{\textgreater})}

\paragraph[Codificación en base64, método tob64]{\foreignlanguage{spanish}{Codificación en base64, método
}\textstyleSourceText{\foreignlanguage{spanish}{tob64}}}
\hypertarget{RefHeadingToc358273639824055}{}{\selectlanguage{spanish}
Convierte una matriz de bytes en una cadena base64.}


\bigskip

{\selectlanguage{spanish}\ttfamily
b = bytes('deadbeef0011')}

{\selectlanguage{spanish}\ttfamily
s = b.tob64()}

{\selectlanguage{spanish}\ttfamily
print(s) \ \ \ \ \ \ \ \ \ \ \ \ \ \ \# 3q2+7wAR}

\paragraph[Decodificación en base64, método fromb64]{\foreignlanguage{spanish}{Decodificación en base64, método
}\textstyleSourceText{\foreignlanguage{spanish}{fromb64}}}
\hypertarget{RefHeadingToc358293639824055}{}{\selectlanguage{spanish}
Convierte una cadena base64 en una matriz de bytes.}


\bigskip

{\selectlanguage{spanish}\ttfamily
s = '3q2+7wAR'}

{\selectlanguage{spanish}\ttfamily
b = bytes().fromb64(s)}

{\selectlanguage{spanish}\ttfamily
print(b) \ \ \ \ \ \ \ \ \ \ \ \ \ \ \# bytes('DEADBEEF0011')}

\paragraph[Métodos getfloat y setfloat]{\foreignlanguage{spanish}{Métodos
}\textstyleSourceText{\foreignlanguage{spanish}{getfloat}}\foreignlanguage{spanish}{ y
}\textstyleSourceText{\foreignlanguage{spanish}{setfloat}}}
\hypertarget{RefHeadingToc358313639824055}{}\foreignlanguage{spanish}{Similar a
}\textstyleSourceText{\foreignlanguage{spanish}{get/set}}\foreignlanguage{spanish}{, permite leer o escribir un valor
en coma flotante de 32 bits.}


\bigskip

{\selectlanguage{spanish}\ttfamily
b.getfloat({\textless}offset{\textgreater})}

{\selectlanguage{spanish}\ttfamily
b.getfloat({\textless}offset{\textgreater}, {\textless}number{\textgreater})}

{\selectlanguage{spanish}\ttfamily
b = bytes({\textquotedbl}00000000{\textquotedbl})}

{\selectlanguage{spanish}\ttfamily
b.getfloat(0) \ \ \ \ \# 0}

{\selectlanguage{spanish}\ttfamily
b.setfloat(0, -1.5)}

{\selectlanguage{spanish}\ttfamily
print(b) \ \# bytes('0000C0BF')}

{\selectlanguage{spanish}\ttfamily
b.getfloat(0) \ \# -1.5}

\paragraph[Método \_buffer]{\foreignlanguage{spanish}{Método }\textstyleSourceText{\foreignlanguage{spanish}{\_buffer}}}
\hypertarget{RefHeadingToc358333639824055}{}{\selectlanguage{spanish}
\textbf{Característica avanzada}: devuelve la dirección del búfer en la memoria, para usar con código C.}


\bigskip

{\selectlanguage{spanish}\ttfamily
b = bytes('1122')}

{\selectlanguage{spanish}\ttfamily
b.\_buffer() \ \# {\textless}ptr: 0x600000c283c0{\textgreater}}

\paragraph[Método \_change\_buffer]{\foreignlanguage{spanish}{Método
}\textstyleSourceText{\foreignlanguage{spanish}{\_change\_buffer}}}
\hypertarget{RefHeadingToc358353639824055}{}\foreignlanguage{spanish}{\textbf{Característica
avanzada}}\foreignlanguage{spanish}{: funciona solo para búferes mapeados (es decir,
}\textstyleSourceText{\foreignlanguage{spanish}{b.ismapped() == true}}\foreignlanguage{spanish}{), permite reasignar el
búfer a una nueva dirección de memoria. Esto permite reutilizar el objeto bytes() sin reasignar una nueva instancia.}


\bigskip

{\selectlanguage{spanish}\ttfamily
\# \ este ejemplo usa la asignación de punteros, use con mucho cuidado}

{\selectlanguage{spanish}\ttfamily
b1 = bytes({\textquotedbl}11223344{\textquotedbl})}

{\selectlanguage{spanish}\ttfamily
b2 = bytes({\textquotedbl}AABBCCDD{\textquotedbl})}

{\selectlanguage{spanish}\ttfamily
b1.\_buffer() \ \# {\textless}ptr: 0x600000c2c390{\textgreater}}

{\selectlanguage{spanish}\ttfamily
b2.\_buffer() \ \# {\textless}ptr: 0x600000c24270{\textgreater}}


\bigskip

{\selectlanguage{spanish}\ttfamily
\# ahora creamos c como un búfer asignado de 4 bytes a la dirección de b1}

{\selectlanguage{spanish}\ttfamily
c = bytes(b1.\_buffer(), 4)}

{\selectlanguage{spanish}\ttfamily
print(c) \ \# bytes('11223344') -{}- asignado a b1}

{\selectlanguage{spanish}\ttfamily
c.\_buffer() \ \ \# {\textless}ptr: 0x600000c2c390{\textgreater}}


\bigskip

{\selectlanguage{spanish}\ttfamily
\# \ cambiemos un byte para probarlo}

{\selectlanguage{spanish}\ttfamily
c[0] = 254}

{\selectlanguage{spanish}\ttfamily
print(c) \ \# bytes('FE223344')}

{\selectlanguage{spanish}\ttfamily
print(b1) \# bytes('FE223344') -{}- b1 ha cambiado}


\bigskip

{\selectlanguage{spanish}\ttfamily
\# \ reasignar c al mapa b2}

{\selectlanguage{spanish}\ttfamily
c.\_change\_buffer(b2.\_buffer())}

{\selectlanguage{spanish}\ttfamily
print(c) \ \# bytes('AABBCCDD')}

{\selectlanguage{spanish}\ttfamily
c.\_buffer() \ \# {\textless}ptr: 0x600000c24270{\textgreater}}

\subsection[7.2 Módulos de expansión]{\selectlanguage{spanish} 7.2 Módulos de expansión}
\hypertarget{RefHeadingToc358373639824055}{}\subsubsection[7.2.1 Módulo JSON]{\selectlanguage{spanish} 7.2.1 Módulo
JSON}
\hypertarget{RefHeadingToc358393639824055}{}{\selectlanguage{spanish}
JSON es un formato ligero de intercambio de datos. Es un subconjunto de JavaScript. Utiliza un formato de texto que es
completamente independiente del lenguaje de programación para representar datos. Berry proporciona un módulo JSON para
proporcionar soporte para datos JSON. El módulo JSON solo contiene dos funciones, {\textquotedbl}cargar{\textquotedbl}
y {\textquotedbl}volcar{\textquotedbl}, que se utilizan para analizar cadenas JSON y multiplicar objetos Berry y
serializar un objeto Berry en texto JSON.}

\paragraph[Función load]{\foreignlanguage{spanish}{Función }\textstyleSourceText{\foreignlanguage{spanish}{load}}}
\hypertarget{RefHeadingToc358413639824055}{}{\selectlanguage{spanish}\ttfamily
load(text)}


\bigskip

{\selectlanguage{spanish}\bfseries
Descripción}

\foreignlanguage{spanish}{Esta función se usa para convertir el texto JSON de entrada en un objeto Berry y devolverlo.
Las reglas de conversión se muestran en la Tabla 9 . Si hay un error de sintaxis en el texto JSON, la función devolverá
}\textstyleSourceText{\foreignlanguage{spanish}{nil}}\foreignlanguage{spanish}{.}


\bigskip

\begin{center}
\tablefirsthead{\centering{\selectlanguage{spanish}\bfseries Tipo JSON} &
\centering\arraybslash{\selectlanguage{spanish}\bfseries Tipo Berry}\\}
\tablehead{\centering{\selectlanguage{spanish}\bfseries Tipo JSON} &
\centering\arraybslash{\selectlanguage{spanish}\bfseries Tipo Berry}\\}
\tabletail{}
\tablelasttail{}
\begin{supertabular}{m{7.76cm}m{7.76cm}}
\centering \textstyleSourceText{\foreignlanguage{spanish}{nulo}} &
\centering\arraybslash \textstyleSourceText{\foreignlanguage{spanish}{nil}}\\
\centering \textstyleSourceText{\foreignlanguage{spanish}{número}} &
\centering\arraybslash \textstyleSourceText{\foreignlanguage{spanish}{entero}}\foreignlanguage{spanish}{ o
}\textstyleSourceText{\foreignlanguage{spanish}{real}}\\
\centering \textstyleSourceText{\foreignlanguage{spanish}{cadena}} &
\centering\arraybslash \textstyleSourceText{\foreignlanguage{spanish}{cadena}}\\
\centering \textstyleSourceText{\foreignlanguage{spanish}{matriz}} &
\centering\arraybslash \textstyleSourceText{\foreignlanguage{spanish}{lista}}\\
\centering \textstyleSourceText{\foreignlanguage{spanish}{objeto}} &
\centering\arraybslash \textstyleSourceText{\foreignlanguage{spanish}{mapa}}\\
\end{supertabular}
\end{center}
{\selectlanguage{spanish}\itshape
Tabla 9: Reglas de conversión de tipo JSON a tipo Berry}


\bigskip

{\selectlanguage{spanish}\bfseries
Ejemplo}

{\selectlanguage{spanish}\ttfamily
import json}

{\selectlanguage{spanish}\ttfamily
json.load('0') \# 0}

{\selectlanguage{spanish}\ttfamily
json.load('[\{{\textquotedbl}nombre{\textquotedbl}: {\textquotedbl}liu{\textquotedbl},
{\textquotedbl}edad{\textquotedbl}: 13\}, 10.0]') \# [\{'nombre':'liu','edad': 13\}, 10]}

\paragraph[Función dump]{\foreignlanguage{spanish}{Función }\textstyleSourceText{\foreignlanguage{spanish}{dump}}}
\hypertarget{RefHeadingToc358433639824055}{}{\selectlanguage{spanish}\ttfamily
dump(objectp, ['formato'])}


\bigskip

{\selectlanguage{spanish}\bfseries
Descripción}

{\selectlanguage{spanish}
Esta función se usa para serializar el objeto Berry en texto JSON. Las reglas de conversión para la serialización se
muestran en la Tabla 10 .}


\bigskip

\begin{center}
\tablefirsthead{\centering{\selectlanguage{spanish}\bfseries Tipo berry} &
\centering\arraybslash{\selectlanguage{spanish}\bfseries Tipo JSON}\\}
\tablehead{\centering{\selectlanguage{spanish}\bfseries Tipo berry} &
\centering\arraybslash{\selectlanguage{spanish}\bfseries Tipo JSON}\\}
\tabletail{}
\tablelasttail{}
\begin{supertabular}{m{7.76cm}m{7.76cm}}
\centering \textstyleSourceText{\foreignlanguage{spanish}{cero}} &
\centering\arraybslash \textstyleSourceText{\foreignlanguage{spanish}{nulo}}\\
\centering \textstyleSourceText{\foreignlanguage{spanish}{entero}} &
\centering\arraybslash \textstyleSourceText{\foreignlanguage{spanish}{número}}\\
\centering \textstyleSourceText{\foreignlanguage{spanish}{verdadero}} &
\centering\arraybslash \textstyleSourceText{\foreignlanguage{spanish}{número}}\\
\centering \textstyleSourceText{\foreignlanguage{spanish}{lista}} &
\centering\arraybslash \textstyleSourceText{\foreignlanguage{spanish}{matriz}}\\
\centering \textstyleSourceText{\foreignlanguage{spanish}{mapa}} &
\centering\arraybslash \textstyleSourceText{\foreignlanguage{spanish}{objeto}}\\
\centering \textstyleSourceText{\foreignlanguage{spanish}{mapa}}\foreignlanguage{spanish}{ Clave de} &
\centering\arraybslash \textstyleSourceText{\foreignlanguage{spanish}{cadena}}\\
\centering{\selectlanguage{spanish} otro} &
\centering\arraybslash \textstyleSourceText{\foreignlanguage{spanish}{cadena}}\\
\end{supertabular}
\end{center}
{\selectlanguage{spanish}\itshape
Tabla 10: Reglas de conversión de tipo Berry a tipo JSON}


\bigskip

{\selectlanguage{spanish}\bfseries
Ejemplo}


\bigskip

{\selectlanguage{spanish}\ttfamily
import json}

{\selectlanguage{spanish}\ttfamily
json.dump('string') \#'{\textquotedbl}string{\textquotedbl}'}

{\selectlanguage{spanish}\ttfamily
json.dump('string') \#'{\textquotedbl}string{\textquotedbl}'}

{\selectlanguage{spanish}\ttfamily
json.dump(\{0:'item 0','list': [0, 1, 2]\}) \#'\{{\textquotedbl}0{\textquotedbl}:{\textquotedbl}item
0{\textquotedbl},{\textquotedbl}list{\textquotedbl}:[0,1,2]\}'}

{\selectlanguage{spanish}\ttfamily
json.dump(\{0:'item 0','list': [0, 1, 2],'func': print\},'format')}

{\selectlanguage{spanish}\ttfamily
\#-}

{\selectlanguage{spanish}\ttfamily
\{}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ {\textquotedbl}0{\textquotedbl}: {\textquotedbl}item 0{\textquotedbl},}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ {\textquotedbl}list{\textquotedbl}: [}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ 0,}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ 1,}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ 2}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ ],}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ {\textquotedbl}func{\textquotedbl}: {\textquotedbl}{\textless}function: 00410310{\textgreater}{\textquotedbl}}

{\selectlanguage{spanish}\ttfamily
\}}

{\selectlanguage{spanish}\ttfamily
{}-\#}

\subsubsection[7.2.2 Módulo matemático]{\selectlanguage{spanish} 7.2.2 Módulo matemático}
\hypertarget{RefHeadingToc358453639824055}{}\foreignlanguage{spanish}{Este módulo se utiliza para proporcionar soporte
para funciones matemáticas, como las funciones trigonométricas y las funciones de raíz cuadrada de uso común. Para usar
el módulo matemático, primero use la instrucción }\textstyleSourceText{\foreignlanguage{spanish}{import
math}}\foreignlanguage{spanish}{. Todos los ejemplos de esta sección asumen que el módulo se ha importado
correctamente.}

\paragraph[Constante pi]{\foreignlanguage{spanish}{Constante }\textstyleSourceText{\foreignlanguage{spanish}{pi}}}
\hypertarget{RefHeadingToc358473639824055}{}{\selectlanguage{spanish}
El valor de Pi \textit{$\pi $} es un tipo de número real, aproximadamente igual a 3.141592654.}

{\selectlanguage{spanish}\bfseries
Ejemplo}

{\selectlanguage{spanish}\ttfamily
math.pi \# 3.14159}

\paragraph[Función abs]{\foreignlanguage{spanish}{Función }\textstyleSourceText{\foreignlanguage{spanish}{abs}}}
\hypertarget{RefHeadingToc358493639824055}{}{\selectlanguage{spanish}\ttfamily
abs(valor)}

{\selectlanguage{spanish}\bfseries
Descripción}

\foreignlanguage{spanish}{Esta función devuelve el valor absoluto del parámetro, que puede ser un número entero o un
número real. Si no hay parámetros, la función devuelve
}\textstyleSourceText{\foreignlanguage{spanish}{0}}\foreignlanguage{spanish}{, si hay varios parámetros, solo se
procesa el primer parámetro. El tipo de retorno de la función
}\textstyleSourceText{\foreignlanguage{spanish}{abs}}\foreignlanguage{spanish}{ es un número real.}

{\selectlanguage{spanish}\bfseries
Ejemplo}

{\selectlanguage{spanish}\ttfamily
math.abs(-1) \# 1}

{\selectlanguage{spanish}\ttfamily
math.abs(1.5) \# 1.5}

\paragraph[Función ceil]{\foreignlanguage{spanish}{Función }\textstyleSourceText{\foreignlanguage{spanish}{ceil}}}
\hypertarget{RefHeadingToc358513639824055}{}{\selectlanguage{spanish}\ttfamily
ceil(valor)}


\bigskip

{\selectlanguage{spanish}\bfseries
Descripción}

\foreignlanguage{spanish}{Esta función devuelve el valor redondeado hacia arriba del parámetro, es decir, el valor
entero más pequeño mayor o igual que el parámetro. El parámetro puede ser un número entero o un número real. Si no hay
parámetros, la función devuelve }\textstyleSourceText{\foreignlanguage{spanish}{0}}\foreignlanguage{spanish}{, si hay
varios parámetros, solo se procesa el primero. El tipo de retorno de la función es un número real.}

{\selectlanguage{spanish}\bfseries
Ejemplo}


\bigskip

{\selectlanguage{spanish}\ttfamily
math.ceil(-1.2) \# -1}

{\selectlanguage{spanish}\ttfamily
math.ceil(1.5) \# 2}

\paragraph[Función floor]{\foreignlanguage{spanish}{Función }\textstyleSourceText{\foreignlanguage{spanish}{floor}}}
\hypertarget{RefHeadingToc358533639824055}{}{\selectlanguage{spanish}\ttfamily
floor(valor)}


\bigskip

{\selectlanguage{spanish}\bfseries
Descripción}

\foreignlanguage{spanish}{Esta función devuelve el valor redondeado hacia abajo del parámetro, que no es mayor que el
valor entero máximo del parámetro. El parámetro puede ser un número entero o un número real. Si no hay parámetros, la
función devuelve }\textstyleSourceText{\foreignlanguage{spanish}{0}}\foreignlanguage{spanish}{, si hay varios
parámetros, solo se procesa el primero. El tipo de retorno de la función es un número real.}

{\selectlanguage{spanish}\bfseries
Ejemplo}


\bigskip

{\selectlanguage{spanish}\ttfamily
math.floor(-1.2) \# -2}

{\selectlanguage{spanish}\ttfamily
math.floor(1.5) \# 1}

\paragraph[Función sin]{\foreignlanguage{spanish}{Función }\textstyleSourceText{\foreignlanguage{spanish}{sin}}}
\hypertarget{RefHeadingToc358553639824055}{}{\selectlanguage{spanish}\ttfamily
sin(valor)}


\bigskip

{\selectlanguage{spanish}\bfseries
Descripción}

\foreignlanguage{spanish}{Esta función devuelve el valor de la función seno del parámetro. El parámetro puede ser un
número entero o un número real, y la unidad son los radianes. Si no hay parámetros, la función devuelve
}\textstyleSourceText{\foreignlanguage{spanish}{0}}\foreignlanguage{spanish}{, si hay varios parámetros, solo se
procesa el primer parámetro. El tipo de retorno de la función es un número real.}

{\selectlanguage{spanish}\bfseries
Ejemplo}


\bigskip

{\selectlanguage{spanish}\ttfamily
math.sin(1) \# 0.841471}

{\selectlanguage{spanish}\ttfamily
math.sin(math.pi * 0.5) \# 1}

\paragraph[Función cos]{\foreignlanguage{spanish}{Función }\textstyleSourceText{\foreignlanguage{spanish}{cos}}}
\hypertarget{RefHeadingToc358573639824055}{}{\selectlanguage{spanish}\ttfamily
cos(valor)}


\bigskip

{\selectlanguage{spanish}\bfseries
Descripción}

\foreignlanguage{spanish}{Esta función devuelve el valor de la función coseno del parámetro. El parámetro puede ser un
número entero o un número real en radianes. Si no hay parámetros, la función devuelve
}\textstyleSourceText{\foreignlanguage{spanish}{0}}\foreignlanguage{spanish}{, si hay varios parámetros, solo se
procesa el primero. El tipo de retorno de la función es un número real.}

{\selectlanguage{spanish}\bfseries
Ejemplo}


\bigskip

{\selectlanguage{spanish}\ttfamily
math.cos(1) \# 0.540302}

{\selectlanguage{spanish}\ttfamily
math.cos(math.pi) \# -1}

\paragraph[Función tan]{\foreignlanguage{spanish}{Función }\textstyleSourceText{\foreignlanguage{spanish}{tan}}}
\hypertarget{RefHeadingToc358593639824055}{}{\selectlanguage{spanish}\ttfamily
tan(valor)}


\bigskip

{\selectlanguage{spanish}\bfseries
Descripción}

\foreignlanguage{spanish}{Esta función devuelve el valor de la función tangente del parámetro. El parámetro puede ser un
número entero o un número real, en radianes. Si no hay parámetros, la función devuelve
}\textstyleSourceText{\foreignlanguage{spanish}{0}}\foreignlanguage{spanish}{, si hay varios parámetros, solo se
procesa el primero. El tipo de retorno de la función es un número real.}

{\selectlanguage{spanish}\bfseries
Ejemplo}


\bigskip

{\selectlanguage{spanish}\ttfamily
math.tan(1) \# 1.55741}

{\selectlanguage{spanish}\ttfamily
math.tan(math.pi / 4) \# 1}

\paragraph[Función asin]{\foreignlanguage{spanish}{Función }\textstyleSourceText{\foreignlanguage{spanish}{asin}}}
\hypertarget{RefHeadingToc358613639824055}{}{\selectlanguage{spanish}\ttfamily
asin(valor)}


\bigskip

{\selectlanguage{spanish}\bfseries
Descripción}

\foreignlanguage{spanish}{Esta función devuelve el valor de la función arco seno del parámetro. El parámetro puede ser
un número entero o un número real. El rango de valores es [$-$1,1]. Si no hay parámetros, la función devuelve
}\textstyleSourceText{\foreignlanguage{spanish}{0}}\foreignlanguage{spanish}{, si hay varios parámetros, solo se
procesa el primero. El tipo de retorno de la función es un número real y la unidad es radianes.}

{\selectlanguage{spanish}\bfseries
Ejemplo}


\bigskip

{\selectlanguage{spanish}\ttfamily
math.asin(1) \# 1.5708}

{\selectlanguage{spanish}\ttfamily
math.asin(0.5) * 180 / math.pi \# 30}

\paragraph[Función acos]{\foreignlanguage{spanish}{Función }\textstyleSourceText{\foreignlanguage{spanish}{acos}}}
\hypertarget{RefHeadingToc358633639824055}{}{\selectlanguage{spanish}\ttfamily
acos(valor)}


\bigskip

{\selectlanguage{spanish}\bfseries
Descripción}

\foreignlanguage{spanish}{Esta función devuelve el valor de la función de arco coseno del parámetro. El parámetro puede
ser un número entero o un número real. El rango de valores es [$-$1,1]. Si no hay parámetros, la función devuelve
}\textstyleSourceText{\foreignlanguage{spanish}{0}}\foreignlanguage{spanish}{, si hay varios parámetros, solo se
procesa el primero. El tipo de retorno de la función es un número real y la unidad es radianes.}

{\selectlanguage{spanish}\bfseries
Ejemplo}


\bigskip

{\selectlanguage{spanish}\ttfamily
math.acos(1) \# 0}

{\selectlanguage{spanish}\ttfamily
math.acos(0) \# 1.5708}

\paragraph[Función atán]{\foreignlanguage{spanish}{Función }\textstyleSourceText{\foreignlanguage{spanish}{atán}}}
\hypertarget{RefHeadingToc358653639824055}{}{\selectlanguage{spanish}\ttfamily
atan(valor)}


\bigskip

{\selectlanguage{spanish}\bfseries
Descripción}

\foreignlanguage{spanish}{Esta función devuelve el valor de la función arco tangente del parámetro. El parámetro puede
ser un número entero o un número real. El rango de valores es [$-{\infty}$,+${\infty}$]. Si no hay parámetros, la
función devuelve }\textstyleSourceText{\foreignlanguage{spanish}{0}}\foreignlanguage{spanish}{, si hay varios
parámetros, solo se procesa el primero. El tipo de retorno de la función es un número real y la unidad es radianes.}

{\selectlanguage{spanish}\bfseries
Ejemplo}


\bigskip

{\selectlanguage{spanish}\ttfamily
math.atan(1) * 180 / math.pi \# 45}

\paragraph[Función sinh]{\foreignlanguage{spanish}{Función }\textstyleSourceText{\foreignlanguage{spanish}{sinh}}}
\hypertarget{RefHeadingToc358673639824055}{}{\selectlanguage{spanish}\ttfamily
sinh(valor)}


\bigskip

{\selectlanguage{spanish}\bfseries
Descripción}

\foreignlanguage{spanish}{Esta función devuelve el valor de función de seno hiperbólico del parámetro. Si no hay
parámetros, la función devuelve }\textstyleSourceText{\foreignlanguage{spanish}{0}}\foreignlanguage{spanish}{, si hay
varios parámetros, solo se procesa el primer parámetro. El tipo de retorno de la función es un número real.}

{\selectlanguage{spanish}\bfseries
Ejemplo}


\bigskip

{\selectlanguage{spanish}\ttfamily
math.sinh(1) \# 1.1752}

\paragraph[Función cosh]{\foreignlanguage{spanish}{Función }\textstyleSourceText{\foreignlanguage{spanish}{cosh}}}
\hypertarget{RefHeadingToc358693639824055}{}{\selectlanguage{spanish}\ttfamily
cosh(valor)}


\bigskip

{\selectlanguage{spanish}\bfseries
Descripción}

\foreignlanguage{spanish}{Esta función devuelve el valor de la función coseno hiperbólico del parámetro. Si no hay
parámetros, la función devuelve }\textstyleSourceText{\foreignlanguage{spanish}{0}}\foreignlanguage{spanish}{, si hay
varios parámetros, solo se procesa el primero. El tipo de retorno de la función es un número real.}

{\selectlanguage{spanish}\bfseries
Ejemplo}


\bigskip

{\selectlanguage{spanish}\ttfamily
math.cosh(1) \# 1.54308}

\paragraph[Función tanh]{\foreignlanguage{spanish}{Función }\textstyleSourceText{\foreignlanguage{spanish}{tanh}}}
\hypertarget{RefHeadingToc358713639824055}{}{\selectlanguage{spanish}\ttfamily
tanh(valor)}


\bigskip

{\selectlanguage{spanish}\bfseries
Descripción}

\foreignlanguage{spanish}{Esta función devuelve el valor de la función tangente hiperbólica del parámetro. Si no hay
parámetros, la función devuelve }\textstyleSourceText{\foreignlanguage{spanish}{0}}\foreignlanguage{spanish}{, si hay
varios parámetros, solo se procesa el primero. El tipo de retorno de la función es un número real.}

{\selectlanguage{spanish}\bfseries
Ejemplo}

{\selectlanguage{spanish}\ttfamily
math.tanh(1) \# 0.761594}

\paragraph[Función sqrt]{\foreignlanguage{spanish}{Función }\textstyleSourceText{\foreignlanguage{spanish}{sqrt}}}
\hypertarget{RefHeadingToc358733639824055}{}{\selectlanguage{spanish}\ttfamily
sqrt(valor)}


\bigskip

{\selectlanguage{spanish}\bfseries
Descripción}

\foreignlanguage{spanish}{Esta función devuelve la raíz cuadrada del argumento. El parámetro de esta función no puede
ser negativo. Si no hay parámetros, la función devuelve
}\textstyleSourceText{\foreignlanguage{spanish}{0}}\foreignlanguage{spanish}{, si hay varios parámetros, solo se
procesa el primero. El tipo de retorno de la función es un número real.}

{\selectlanguage{spanish}\bfseries
Ejemplo}


\bigskip

{\selectlanguage{spanish}\ttfamily
math.sqrt(2) \# 1.41421}

\paragraph[Función exp]{\foreignlanguage{spanish}{Función }\textstyleSourceText{\foreignlanguage{spanish}{exp}}}
\hypertarget{RefHeadingToc358753639824055}{}{\selectlanguage{spanish}\ttfamily
exp(valor)}


\bigskip

{\selectlanguage{spanish}\bfseries
Descripción}

\foreignlanguage{spanish}{Esta función devuelve el valor de la función exponencial del parámetro en función de la
constante natural }\foreignlanguage{spanish}{\textit{e}}\foreignlanguage{spanish}{. Si no hay parámetros, la función
devuelve }\textstyleSourceText{\foreignlanguage{spanish}{0}}\foreignlanguage{spanish}{, si hay varios parámetros, solo
se procesa el primero. El tipo de retorno de la función es un número real.}

{\selectlanguage{spanish}\bfseries
Ejemplo}


\bigskip

{\selectlanguage{spanish}\ttfamily
math.exp(1) \# 2.71828}

\paragraph[Función log]{\foreignlanguage{spanish}{Función }\textstyleSourceText{\foreignlanguage{spanish}{log}}}
\hypertarget{RefHeadingToc358773639824055}{}{\selectlanguage{spanish}\ttfamily
log(valor)}


\bigskip

{\selectlanguage{spanish}\bfseries
Descripción}

\foreignlanguage{spanish}{Esta función devuelve el logaritmo natural del argumento. El parámetro debe ser un número
positivo. Si no hay parámetros, la función devuelve
}\textstyleSourceText{\foreignlanguage{spanish}{0}}\foreignlanguage{spanish}{, si hay varios parámetros, solo se
procesa el primero. El tipo de retorno de la función es un número real.}

{\selectlanguage{spanish}\bfseries
Ejemplo}


\bigskip

{\selectlanguage{spanish}\ttfamily
log(valor)}

\paragraph[Función log10]{\foreignlanguage{spanish}{Función }\textstyleSourceText{\foreignlanguage{spanish}{log10}}}
\hypertarget{RefHeadingToc358793639824055}{}{\selectlanguage{spanish}\ttfamily
log10(valor)}


\bigskip

{\selectlanguage{spanish}\bfseries
Descripción}

\foreignlanguage{spanish}{Esta función devuelve el logaritmo del parámetro en base 10. El parámetro debe ser un número
positivo. Si no hay parámetros, la función devuelve
}\textstyleSourceText{\foreignlanguage{spanish}{0}}\foreignlanguage{spanish}{, si hay varios parámetros, solo se
procesa el primero. El tipo de retorno de la función es un número real.}

{\selectlanguage{spanish}\bfseries
Ejemplo}


\bigskip

{\selectlanguage{spanish}\ttfamily
math.log10(10) \# 1}

\paragraph[Función deg]{\foreignlanguage{spanish}{Función }\textstyleSourceText{\foreignlanguage{spanish}{deg}}}
\hypertarget{RefHeadingToc358813639824055}{}{\selectlanguage{spanish}\ttfamily
deg(valor)}


\bigskip

{\selectlanguage{spanish}\bfseries
Descripción}

\foreignlanguage{spanish}{Esta función se utiliza para convertir radianes en ángulos. La unidad del parámetro es
radianes. Si no hay parámetros, la función devuelve
}\textstyleSourceText{\foreignlanguage{spanish}{0}}\foreignlanguage{spanish}{, si hay varios parámetros, solo se
procesa el primero. El tipo de retorno de la función es un número real y la unidad es un ángulo.}

{\selectlanguage{spanish}\bfseries
Ejemplo}


\bigskip

{\selectlanguage{spanish}\ttfamily
math.deg(math.pi) \# 180}

\paragraph[Función rad]{\foreignlanguage{spanish}{Función }\textstyleSourceText{\foreignlanguage{spanish}{rad}}}
\hypertarget{RefHeadingToc358833639824055}{}{\selectlanguage{spanish}\ttfamily
rad(valor)}


\bigskip

{\selectlanguage{spanish}\bfseries
Descripción}

\foreignlanguage{spanish}{Esta función se utiliza para convertir ángulos a radianes. La unidad del parámetro es el
ángulo. Si no hay parámetros, la función devuelve
}\textstyleSourceText{\foreignlanguage{spanish}{0}}\foreignlanguage{spanish}{, si hay varios parámetros, solo se
procesa el primero. El tipo de retorno de la función es un número real y la unidad es radianes.}

{\selectlanguage{spanish}\bfseries
Ejemplo}


\bigskip

{\selectlanguage{spanish}\ttfamily
math.rad(180) \# 3.14159}

\paragraph[Función pow]{\foreignlanguage{spanish}{Función }\textstyleSourceText{\foreignlanguage{spanish}{pow}}}
\hypertarget{RefHeadingToc358853639824055}{}{\selectlanguage{spanish}\ttfamily
pow(x, y)}


\bigskip

{\selectlanguage{spanish}\bfseries
Descripción}

\foreignlanguage{spanish}{El valor de retorno de esta función es el resultado de la expresión
}\foreignlanguage{spanish}{\textit{x}}\foreignlanguage{spanish}{
}\foreignlanguage{spanish}{\textit{y}}\foreignlanguage{spanish}{ , que es el parámetro
}\textstyleSourceText{\foreignlanguage{spanish}{x}}\foreignlanguage{spanish}{ elevado a
}\textstyleSourceText{\foreignlanguage{spanish}{y}}\foreignlanguage{spanish}{. Si los parámetros no están completos, la
función devuelve }\textstyleSourceText{\foreignlanguage{spanish}{0}}\foreignlanguage{spanish}{, si hay parámetros
adicionales, solo se procesan los dos primeros parámetros. El tipo de retorno de la función es un número real.}

{\selectlanguage{spanish}\bfseries
Ejemplo}


\bigskip

{\selectlanguage{spanish}\ttfamily
math.pow(2, 3) \# 8}

\paragraph[Función srand]{\foreignlanguage{spanish}{Función }\textstyleSourceText{\foreignlanguage{spanish}{srand}}}
\hypertarget{RefHeadingToc358873639824055}{}{\selectlanguage{spanish}\ttfamily
srand(valor)}


\bigskip

{\selectlanguage{spanish}\bfseries
Descripción}

{\selectlanguage{spanish}
Esta función se utiliza para establecer la semilla del generador de números aleatorios. El tipo del parámetro debe ser
un número entero.}

{\selectlanguage{spanish}\bfseries
Ejemplo}


\bigskip

{\selectlanguage{spanish}\ttfamily
math.srand(2)}

\paragraph[Función rand]{\foreignlanguage{spanish}{Función }\textstyleSourceText{\foreignlanguage{spanish}{rand}}}
\hypertarget{RefHeadingToc358893639824055}{}{\selectlanguage{spanish}\ttfamily
Rand()}


\bigskip

{\selectlanguage{spanish}\bfseries
Descripción}

{\selectlanguage{spanish}
Esta función se utiliza para obtener un número entero aleatorio.}

{\selectlanguage{spanish}\bfseries
Ejemplo}


\bigskip

{\selectlanguage{spanish}\ttfamily
math.rand()}

\subsubsection[7.2.3 Módulo de tiempo]{\selectlanguage{spanish} 7.2.3 Módulo de tiempo}
\hypertarget{RefHeadingToc358913639824055}{}{\selectlanguage{spanish}
Este módulo se utiliza para proporcionar funciones relacionadas con el tiempo.}

\paragraph[Función time]{\foreignlanguage{spanish}{Función }\textstyleSourceText{\foreignlanguage{spanish}{time}}}
\hypertarget{RefHeadingToc358933639824055}{}{\selectlanguage{spanish}\ttfamily
time()}


\bigskip

{\selectlanguage{spanish}\bfseries
Descripción}

{\selectlanguage{spanish}
Devuelve la marca de tiempo actual. La marca de tiempo es el tiempo transcurrido desde Unix Epoch (1 de enero de 1970
00:00:00 UTC), en segundos.}

\paragraph[Función dump]{\foreignlanguage{spanish}{Función }\textstyleSourceText{\foreignlanguage{spanish}{dump}}}
\hypertarget{RefHeadingToc358953639824055}{}{\selectlanguage{spanish}\ttfamily
dump(ts)}


\bigskip

{\selectlanguage{spanish}\bfseries
Descripción}

\foreignlanguage{spanish}{La marca de tiempo de entrada
}\textstyleSourceText{\foreignlanguage{spanish}{ts}}\foreignlanguage{spanish}{ se convierte en un
}\textstyleSourceText{\foreignlanguage{spanish}{map}}\foreignlanguage{spanish}{ de tiempo, y la correspondencia
clave-valor se muestra en la siguiente tabla:}


\bigskip

\begin{center}
\tablefirsthead{\centering{\selectlanguage{spanish}\bfseries clave} &
\centering{\selectlanguage{spanish}\bfseries valor} &
\centering{\selectlanguage{spanish}\bfseries clave} &
\centering{\selectlanguage{spanish}\bfseries valor} &
\centering{\selectlanguage{spanish}\bfseries clave} &
\centering\arraybslash{\selectlanguage{spanish}\bfseries valor}\\}
\tablehead{\centering{\selectlanguage{spanish}\bfseries clave} &
\centering{\selectlanguage{spanish}\bfseries valor} &
\centering{\selectlanguage{spanish}\bfseries clave} &
\centering{\selectlanguage{spanish}\bfseries valor} &
\centering{\selectlanguage{spanish}\bfseries clave} &
\centering\arraybslash{\selectlanguage{spanish}\bfseries valor}\\}
\tabletail{}
\tablelasttail{}
\begin{supertabular}{m{2.453cm}m{2.453cm}m{2.453cm}m{2.453cm}m{2.453cm}m{2.455cm}}
\centering \textstyleSourceText{\foreignlanguage{spanish}{{}'year'}} &
\centering{\selectlanguage{spanish} Año (desde 1900)} &
\centering \textstyleSourceText{\foreignlanguage{spanish}{{}'month'}} &
\centering{\selectlanguage{spanish} Mes (1-12)} &
\centering \textstyleSourceText{\foreignlanguage{spanish}{{}'day'}} &
\centering\arraybslash{\selectlanguage{spanish} Día (1-31)}\\
\centering \textstyleSourceText{\foreignlanguage{spanish}{{}'hour'}} &
\centering{\selectlanguage{spanish} Hora (0-23)} &
\centering \textstyleSourceText{\foreignlanguage{spanish}{{}'min'}} &
\centering{\selectlanguage{spanish} Puntos (0-59)} &
\centering \textstyleSourceText{\foreignlanguage{spanish}{{}'sec'}} &
\centering\arraybslash{\selectlanguage{spanish} Segundos (0-59)}\\
\centering \textstyleSourceText{\foreignlanguage{spanish}{{}'weekday'}} &
\centering{\selectlanguage{spanish} Semana (1-7)} &
~
 &
~
 &
~
 &
~
\\
\end{supertabular}
\end{center}
\foreignlanguage{spanish}{\textit{Tabla 11: La relación clave-valor del valor de retorno de la función
}}\textstyleSourceText{\foreignlanguage{spanish}{time.dump}}


\bigskip

\paragraph[Función clock]{\foreignlanguage{spanish}{Función }\textstyleSourceText{\foreignlanguage{spanish}{clock}}}
\hypertarget{RefHeadingToc358973639824055}{}{\selectlanguage{spanish}\ttfamily
Clock()}


\bigskip

{\selectlanguage{spanish}\bfseries
Descripción}

{\selectlanguage{spanish}
Esta función devuelve el tiempo transcurrido desde el inicio de la ejecución del intérprete hasta que se llama a la
función en segundos. El valor de retorno de esta función es del tipo {\textquotedbl}real{\textquotedbl} y su precisión
de tiempo está determinada por la plataforma específica.}

\subsubsection[7.2.4 Módulo de cadena (string)]{\selectlanguage{spanish} 7.2.4 Módulo de cadena (string)}
\hypertarget{RefHeadingToc358993639824055}{}\foreignlanguage{spanish}{El módulo
}\textstyleSourceText{\foreignlanguage{spanish}{cadena}}\foreignlanguage{spanish}{ proporciona funciones de
procesamiento de cadenas.}

\foreignlanguage{spanish}{Para usar el módulo de cadena, primero use la instrucción
}\textstyleSourceText{\foreignlanguage{spanish}{import string}}\foreignlanguage{spanish}{. Todos los ejemplos de esta
sección asumen que el módulo se ha importado correctamente.}

\paragraph[Función count]{\foreignlanguage{spanish}{Función }\textstyleSourceText{\foreignlanguage{spanish}{count}}}
\hypertarget{RefHeadingToc359013639824055}{}{\selectlanguage{spanish}\ttfamily
string.count(s, sub[, inicio[, fin]])}

\foreignlanguage{spanish}{Cuenta el número de ocurrencias de la subcadena en la cadena s. Busque desde la posición entre
}\textstyleSourceText{\foreignlanguage{spanish}{inicio}}\foreignlanguage{spanish}{ y
}\textstyleSourceText{\foreignlanguage{spanish}{fin}}\foreignlanguage{spanish}{ de
}\textstyleSourceText{\foreignlanguage{spanish}{s}}\foreignlanguage{spanish}{ (el valor predeterminado es 0 y
tamaño(s)).}

\paragraph[Función split]{\foreignlanguage{spanish}{Función }\textstyleSourceText{\foreignlanguage{spanish}{split}}}
\hypertarget{RefHeadingToc359033639824055}{}{\selectlanguage{spanish}\ttfamily
string.split(s, pos)}

\foreignlanguage{spanish}{Divide la cadena s en dos subcadenas en la posición
}\textstyleSourceText{\foreignlanguage{spanish}{pos}}\foreignlanguage{spanish}{ y devuelve la lista de esas cadenas.}

{\selectlanguage{spanish}\ttfamily
string.split(s, sep[, num])}

{\selectlanguage{spanish}
Divide la cadena s en subcadenas dondequiera que ocurra sep, y devuelve la lista de esas cadenas. Dividir como máximo un
número de veces (el valor predeterminado es string.count(s, sep)).}

\paragraph[Función find]{\foreignlanguage{spanish}{Función }\textstyleSourceText{\foreignlanguage{spanish}{find}}}
\hypertarget{RefHeadingToc359053639824055}{}{\selectlanguage{spanish}\ttfamily
string.find(s, sub[, inicio[, fin]])}

{\selectlanguage{spanish}
Compruebe si la cadena s contiene la subcadena sub. Si se especifican el inicio y el final (el valor predeterminado es 0
y el tamaño(s)), se buscarán en este rango.}

\paragraph[Función hex]{\foreignlanguage{spanish}{Función }\textstyleSourceText{\foreignlanguage{spanish}{hex}}}
\hypertarget{RefHeadingToc359073639824055}{}{\selectlanguage{spanish}\ttfamily
hex(numero)}

{\selectlanguage{spanish}
Convertir número a cadena hexadecimal.}

\paragraph[Función byte]{\foreignlanguage{spanish}{Función }\textstyleSourceText{\foreignlanguage{spanish}{byte}}}
\hypertarget{RefHeadingToc359093639824055}{}{\selectlanguage{spanish}\ttfamily
byte(s)}

{\selectlanguage{spanish}
Obtiene el valor del código del primer byte de la cadena s.}

\paragraph[Función char]{\foreignlanguage{spanish}{Función }\textstyleSourceText{\foreignlanguage{spanish}{char}}}
\hypertarget{RefHeadingToc359113639824055}{}{\selectlanguage{spanish}\ttfamily
char(numero)}

{\selectlanguage{spanish}
Convierte el número usado como código en un carácter.}

\paragraph[Función format]{\foreignlanguage{spanish}{Función }\textstyleSourceText{\foreignlanguage{spanish}{format}}}
\hypertarget{RefHeadingToc359133639824055}{}{\selectlanguage{spanish}\ttfamily
string.format(fmt[, args])}

{\selectlanguage{spanish}
Devuelve una cadena formateada. El patrón que comienza con '\%' en la plantilla de formato fmt será reemplazado por el
valor de [args]: \%[flags][fieldwidth][.precision]type}


\bigskip

\begin{center}
\tablefirsthead{{\selectlanguage{spanish}\bfseries Tipo} &
{\selectlanguage{spanish}\bfseries Descripción}\\}
\tablehead{{\selectlanguage{spanish}\bfseries Tipo} &
{\selectlanguage{spanish}\bfseries Descripción}\\}
\tabletail{}
\tablelasttail{}
\begin{supertabular}{m{7.76cm}m{7.76cm}}
{\selectlanguage{spanish} \%d} &
{\selectlanguage{spanish} Entero decimal}\\
{\selectlanguage{spanish} \%o} &
{\selectlanguage{spanish} Entero octal}\\
{\selectlanguage{spanish} \%x} &
{\selectlanguage{spanish} Entero hexadecimal en minúsculas}\\
{\selectlanguage{spanish} \%X} &
{\selectlanguage{spanish} Entero hexadecimal en mayúsculas}\\
{\selectlanguage{spanish} \%x} &
{\selectlanguage{spanish} Entero octal en minúsculas}\\
{\selectlanguage{spanish} \%X} &
{\selectlanguage{spanish} Entero octal en mayúsculas}\\
{\selectlanguage{spanish} \%f} &
{\selectlanguage{spanish} Punto flotante en la forma [-]nnnn.nnnn}\\
{\selectlanguage{spanish} \%e \%E} &
{\selectlanguage{spanish} Punto flotante en exp. forma [-]n.nnnn e [+{\textbar}-]nnn, mayúsculas si \%E}\\
{\selectlanguage{spanish} \%g \%G} &
{\selectlanguage{spanish} Punto flotante como \%f si $-$4 {\textless} exp. ${\leq}$ precision, sino como \%e; mayúsculas
si \%G}\\
{\selectlanguage{spanish} \%c} &
{\selectlanguage{spanish} Carácter que tiene el código pasado como entero}\\
{\selectlanguage{spanish} \%s} &
{\selectlanguage{spanish} Cadena sin ceros incrustados}\\
{\selectlanguage{spanish} \%q} &
{\selectlanguage{spanish} Cadena entre comillas dobles, con caracteres especiales escapados}\\
{\selectlanguage{spanish} \%\%} &
{\selectlanguage{spanish} El carácter '\%' (escapado)}\\
\end{supertabular}
\end{center}
\begin{center}
\tablefirsthead{{\selectlanguage{spanish}\bfseries Tipo} &
{\selectlanguage{spanish}\bfseries Descripción}\\}
\tablehead{{\selectlanguage{spanish}\bfseries Tipo} &
{\selectlanguage{spanish}\bfseries Descripción}\\}
\tabletail{}
\tablelasttail{}
\begin{supertabular}{m{7.76cm}m{7.76cm}}
{\selectlanguage{spanish} {}-} &
{\selectlanguage{spanish} Justificación a la izquierda, el valor predeterminado es justificación a la derecha}\\
{\selectlanguage{spanish} +} &
{\selectlanguage{spanish} antepone el signo (se aplica a los números)}\\
{\selectlanguage{spanish} (espacio)} &
{\selectlanguage{spanish} Antepone signo si es negativo, de lo contrario espacio}\\
{\selectlanguage{spanish} \#} &
{\selectlanguage{spanish} Agrega {\textquotedbl}0x{\textquotedbl} antes de \%x, fuerza el punto decimal; para \%e, \%f,
deja ceros finales para \%g}\\
\end{supertabular}
\end{center}
\begin{center}
\tablefirsthead{{\selectlanguage{spanish}\bfseries Ancho de campo y precisión} &
{\selectlanguage{spanish}\bfseries Descripción}\\}
\tablehead{{\selectlanguage{spanish}\bfseries Ancho de campo y precisión} &
{\selectlanguage{spanish}\bfseries Descripción}\\}
\tabletail{}
\tablelasttail{}
\begin{supertabular}{m{7.76cm}m{7.76cm}}
{\selectlanguage{spanish} n} &
{\selectlanguage{spanish} Pone al menos n caracteres, rellena con espacios en blanco}\\
{\selectlanguage{spanish} 0n} &
{\selectlanguage{spanish} Pone al menos n caracteres, teclado izquierdo con ceros}\\
{\selectlanguage{spanish} .n} &
{\selectlanguage{spanish} Usa al menos n dígitos para números enteros, redondee a n decimales para punto flotante o no
más de n caracteres. para cadenas}\\
\end{supertabular}
\end{center}
\subsubsection[7.2.5 Módulo os]{\foreignlanguage{spanish}{7.2.5 }\foreignlanguage{spanish}{Módulo
}\textstyleSourceText{\foreignlanguage{spanish}{os}}}
\hypertarget{RefHeadingToc359153639824055}{}{\selectlanguage{spanish}
El módulo OS proporciona funciones relacionadas con el sistema, como funciones relacionadas con archivos y rutas. Estas
funciones están relacionadas con la plataforma. Actualmente, los códigos de estilo Windows VC y POSIX se implementan en
el intérprete de Berry. Si se ejecuta en otras plataformas, no se garantiza que se proporcionen las funciones en el
módulo del sistema operativo.}

{\selectlanguage{spanish}
[COMPLETAR]}

\subsubsection[7.2.6 Módulo global]{\foreignlanguage{spanish}{7.2.6 }\foreignlanguage{spanish}{Módulo
}\textstyleSourceText{\foreignlanguage{spanish}{global}}}
\hypertarget{RefHeadingToc359173639824055}{}\foreignlanguage{spanish}{El módulo
}\textstyleSourceText{\foreignlanguage{spanish}{global}}\foreignlanguage{spanish}{ proporciona una forma de acceder a
las variables globales a través de un módulo. El compilador Berry comprueba que existe un global al compilar el código.
Sin embargo, hay casos en los que los globales se crean dinámicamente por código y aún no se conocen en tiempo de
compilación. El uso del módulo }\textstyleSourceText{\foreignlanguage{spanish}{global}}\foreignlanguage{spanish}{ da
total libertad para acceder a variables globales estáticas o dinámicas.}

\foreignlanguage{spanish}{Acceder a un global es simplay hecho con
}\textstyleSourceText{\foreignlanguage{spanish}{global.{\textless}name{\textgreater} }}\foreignlanguage{spanish}{para
leer y escribir. También puede usar la sintaxis especial
}\textstyleSourceText{\foreignlanguage{spanish}{global.(nombre)}}\foreignlanguage{spanish}{ si
}\textstyleSourceText{\foreignlanguage{spanish}{nombre}}\foreignlanguage{spanish}{ es una variable que contiene el
nombre del global como cadena.}

{\selectlanguage{spanish}
Ejemplo:}


\bigskip

{\selectlanguage{spanish}\ttfamily
{\textgreater} import global}

{\selectlanguage{spanish}\ttfamily
{\textgreater} a = 1}

{\selectlanguage{spanish}\ttfamily
{\textgreater} global.a}

{\selectlanguage{spanish}\ttfamily
1}

{\selectlanguage{spanish}\ttfamily
{\textgreater}}

{\selectlanguage{spanish}\ttfamily
{\textgreater} b}

{\selectlanguage{spanish}\ttfamily
syntax\_error: stdin:1: 'b' no declarado (primer uso en esta función)}

{\selectlanguage{spanish}\ttfamily
{\textgreater} global.b = 2}

{\selectlanguage{spanish}\ttfamily
{\textgreater} b}

{\selectlanguage{spanish}\ttfamily
2}

{\selectlanguage{spanish}\ttfamily
{\textgreater} global.b}

{\selectlanguage{spanish}\ttfamily
2}

{\selectlanguage{spanish}\ttfamily
{\textgreater} var nombre = {\textquotedbl}b{\textquotedbl}}

{\selectlanguage{spanish}\ttfamily
{\textgreater} global.(nombre)}

{\selectlanguage{spanish}\ttfamily
2}


\bigskip

\foreignlanguage{spanish}{Llamar a }\textstyleSourceText{\foreignlanguage{spanish}{global()}}\foreignlanguage{spanish}{
devuelve la lista de todos los nombres globales actualmente definidos (los componentes integrados no están incluidos).}


\bigskip

{\selectlanguage{spanish}\ttfamily
{\textgreater} import global}

{\selectlanguage{spanish}\ttfamily
{\textgreater} a = 1}

{\selectlanguage{spanish}\ttfamily
{\textgreater} global.b = 2}

{\selectlanguage{spanish}\ttfamily
{\textgreater} global()}

{\selectlanguage{spanish}\ttfamily
['\_argv', 'b', 'global', 'a']}

\textstyleSourceText{\foreignlanguage{spanish}{global.contains({\textless}nombre){\textgreater} -{\textgreater}
bool}}\foreignlanguage{spanish}{ proporciona una manera fácil de saber si un nombre global ya está definido.}

{\selectlanguage{spanish}\ttfamily
{\textgreater} import global}

{\selectlanguage{spanish}\ttfamily
{\textgreater} global.contains({\textquotedbl}g{\textquotedbl})}

{\selectlanguage{spanish}\ttfamily
false}

{\selectlanguage{spanish}\ttfamily
{\textgreater} g = 1}

{\selectlanguage{spanish}\ttfamily
{\textgreater} global.contains({\textquotedbl}g{\textquotedbl})}

{\selectlanguage{spanish}\ttfamily
true}

\subsubsection[7.2.7 Módulo introspect]{\foreignlanguage{spanish}{7.2.7 }\foreignlanguage{spanish}{Módulo
}\textstyleSourceText{\foreignlanguage{spanish}{introspect}}}
\hypertarget{RefHeadingToc359193639824055}{}\foreignlanguage{spanish}{El módulo
}\textstyleSourceText{\foreignlanguage{spanish}{introspect}}\foreignlanguage{spanish}{ proporciona primitivas para
acceder dinámicamente a variables o módulos. Usar con }\textstyleSourceText{\foreignlanguage{spanish}{import
introspect}}\foreignlanguage{spanish}{.}

\textstyleSourceText{\foreignlanguage{spanish}{introspect.members(objeto: clase o módulo o instancia o nil)
-{\textgreater} lista}}\foreignlanguage{spanish}{ devuelve la lista de nombres de miembros para la
}\textstyleSourceText{\foreignlanguage{spanish}{clase}}\foreignlanguage{spanish}{,
}\textstyleSourceText{\foreignlanguage{spanish}{instancia}}\foreignlanguage{spanish}{ o
}\textstyleSourceText{\foreignlanguage{spanish}{módulo}}\foreignlanguage{spanish}{. Tenga en cuenta que no incluye
miembros virtuales potenciales creados a través de
}\textstyleSourceText{\foreignlanguage{spanish}{member}}\foreignlanguage{spanish}{ y
}\textstyleSourceText{\foreignlanguage{spanish}{setmember}}\foreignlanguage{spanish}{.}

\textstyleSourceText{\foreignlanguage{spanish}{introspect.members()}}\foreignlanguage{spanish}{ devuelve la lista de
variables globales (sin incluir las incorporadas) y es equivalente a
}\textstyleSourceText{\foreignlanguage{spanish}{global()}}

\textstyleSourceText{\foreignlanguage{spanish}{introspect.get(objeto: clase o instancia o módulo, nombre:cadena)
-{\textgreater} cualquiera}}\foreignlanguage{spanish}{ e
}\textstyleSourceText{\foreignlanguage{spanish}{introspect.set(objeto: clase o instancia o módulo, nombre:cadena,
valor:cualquiera) -{\textgreater} nil}}\foreignlanguage{spanish}{ permite leer y escribir cualquier miembro por su
nombre.}

\textstyleSourceText{\foreignlanguage{spanish}{introspect.get(o,
{\textquotedbl}a{\textquotedbl})}}\foreignlanguage{spanish}{ es equivalente a
}\textstyleSourceText{\foreignlanguage{spanish}{oa}}\foreignlanguage{spanish}{,
}\textstyleSourceText{\foreignlanguage{spanish}{introspect.set(o, {\textquotedbl}a{\textquotedbl},
1)}}\foreignlanguage{spanish}{ es equivalente a }\textstyleSourceText{\foreignlanguage{spanish}{oa =
1}}\foreignlanguage{spanish}{. También hay una sintaxis alternativa:
}\textstyleSourceText{\foreignlanguage{spanish}{o.({\textquotedbl}a{\textquotedbl})}}\foreignlanguage{spanish}{ es
equivalente a }\textstyleSourceText{\foreignlanguage{spanish}{oa}}\foreignlanguage{spanish}{ y
}\textstyleSourceText{\foreignlanguage{spanish}{o.({\textquotedbl}a) = 1}}\foreignlanguage{spanish}{ es equivalente a
}\textstyleSourceText{\foreignlanguage{spanish}{oa = 1}}\foreignlanguage{spanish}{.}

\textstyleSourceText{\foreignlanguage{spanish}{introspect.module(nombre:cadena) -{\textgreater}
any}}\foreignlanguage{spanish}{ es equivalente a }\textstyleSourceText{\foreignlanguage{spanish}{import
nombre}}\foreignlanguage{spanish}{ excepto que no crea la variable global o local, sino que devuelve el módulo. Esta es
la única manera de cargar un módulo con un nombre dinámico, }\textstyleSourceText{\foreignlanguage{spanish}{import
nombre}}\foreignlanguage{spanish}{ solo toma un nombre estático.}

\textstyleSourceText{\foreignlanguage{spanish}{introspect.toptr(addr:int) -{\textgreater}
comptr}}\foreignlanguage{spanish}{ convierte un número entero en un puntero comptr.
}\textstyleSourceText{\foreignlanguage{spanish}{introspect.fromptr(addr:comptr) -{\textgreater}
int}}\foreignlanguage{spanish}{ hace lo contrario y convierte un puntero en un int. Advertencia: usar con cuidado. En
plataformas donde }\textstyleSourceText{\foreignlanguage{spanish}{int}}\foreignlanguage{spanish}{ y
}\textstyleSourceText{\foreignlanguage{spanish}{void*}}\foreignlanguage{spanish}{ no tienen el mismo tamaño, estas
funciones seguramente darán resultados inutilizables.}

\textstyleSourceText{\foreignlanguage{spanish}{introspect.ismethod(f:function) -{\textgreater}
bool}}\foreignlanguage{spanish}{ comprueba si la función proporcionada es un método de una instancia (tomando a sí
mismo como primer argumento) o una función simple. Esto se usa principalmente para evitar un error común de pasar un
método de instancia como callback, donde debe usar un cierre que capture la instancia como
}\textstyleSourceText{\foreignlanguage{spanish}{/ -{\textgreater} self.do()}}\foreignlanguage{spanish}{.}

\subsubsection[7.2.8 Módulo solidify]{\foreignlanguage{spanish}{7.2.8 }\foreignlanguage{spanish}{Módulo
}\textstyleSourceText{\foreignlanguage{spanish}{solidify}}}
\hypertarget{RefHeadingToc359213639824055}{}{\selectlanguage{spanish}
Este módulo permite solidificar el bytecode de Berry en flash. Esto permite ahorrar RAM ya que el código está en ROM.
Esto lo convierte en una buena alternativa a las funciones nativas de C.}

{\selectlanguage{spanish}
Ver 8.4 Solidificación.}

\clearpage\section{Capítulo 8: Características avanzadas}
\hypertarget{RefHeadingToc359233639824055}{}
\bigskip

\subsection[8.1 Modo estricto]{\foreignlanguage{spanish}{8.1 Modo
}\textstyleSourceText{\foreignlanguage{spanish}{estricto}}}
\hypertarget{RefHeadingToc359253639824055}{}\foreignlanguage{spanish}{Berry permite total libertad del desarrollador.
Pero después de un poco de experiencia en la codificación con Berry, encontrará que hay errores comunes que son
difíciles de encontrar y que el compilador podría ayudarlo a detectar. El modo
}\textstyleSourceText{\foreignlanguage{spanish}{estricto}}\foreignlanguage{spanish}{ realiza verificaciones adicionales
}\foreignlanguage{spanish}{\textbf{en tiempo de compilación}}\foreignlanguage{spanish}{ sobre algunos errores comunes.}

\foreignlanguage{spanish}{Este modo está habilitado con }\textstyleSourceText{\foreignlanguage{spanish}{import
strict}}\foreignlanguage{spanish}{ o cuando se ejecuta Berry con la opción
}\textstyleSourceText{\foreignlanguage{spanish}{{}-s}}\foreignlanguage{spanish}{:}

\foreignlanguage{spanish}{\ }\textstyleSourceText{\foreignlanguage{spanish}{berry -s}}

\subsubsection[var obligatorio para variables
locales]{\textstyleSourceText{\foreignlanguage{spanish}{var}}\foreignlanguage{spanish}{ obligatorio para variables
locales}}
\hypertarget{RefHeadingToc359273639824055}{}\foreignlanguage{spanish}{Este es el error más común, una variable asignada
sin }\textstyleSourceText{\foreignlanguage{spanish}{var}}\foreignlanguage{spanish}{ es global si ya existe una variable
global o local en caso contrario. El modo estricto rechaza la asignación si no hay un global con el mismo nombre.}

{\selectlanguage{spanish}
No más permitido:}


\bigskip

{\selectlanguage{spanish}\ttfamily
def f()}

{\selectlanguage{spanish}\ttfamily
\ \ i = 0 \ \ \ \# this is a local variable}

{\selectlanguage{spanish}\ttfamily
\ \ var j = 0}

{\selectlanguage{spanish}\ttfamily
end}

{\selectlanguage{spanish}\ttfamily
syntax\_error: stdin:2: strict: no global 'i', ¿quiso decir 'var i'?}

{\selectlanguage{spanish}
Pero todavía funciona para globales:}

{\selectlanguage{spanish}\ttfamily
g\_i = 0}

{\selectlanguage{spanish}\ttfamily
def f()}

{\selectlanguage{spanish}\ttfamily
\ \ g\_i = 1}

{\selectlanguage{spanish}\ttfamily
end}

\subsubsection[Sin anulación de elementos integrados]{\selectlanguage{spanish} Sin anulación de elementos integrados}
\hypertarget{RefHeadingToc359293639824055}{}{\selectlanguage{spanish}
Berry permite anular una función incorporada. Sin embargo, esto generalmente no es deseable y es una fuente de errores
difíciles de encontrar.}


\bigskip

{\selectlanguage{spanish}\ttfamily
map = 1}

{\selectlanguage{spanish}\ttfamily
syntax\_error: stdin:1: estricto: redefinición de 'map' incorporado}

\subsubsection[Múltiples var con el mismo nombre no permitidos en el mismo ámbito]{\foreignlanguage{spanish}{Múltiples
}\textstyleSourceText{\foreignlanguage{spanish}{var}}\foreignlanguage{spanish}{ con el mismo nombre no permitidos en el
mismo ámbito}}
\hypertarget{RefHeadingToc359313639824055}{}{\selectlanguage{spanish}
Berry toleraba la declaración múltiple de una variable local con el mismo nombre. Esto ahora se considera como un error
(incluso sin modo estricto).}


\bigskip

{\selectlanguage{spanish}\ttfamily
def f()}

{\selectlanguage{spanish}\ttfamily
\ \ var a}

{\selectlanguage{spanish}\ttfamily
\ \ var a \ \ \# redefinición de a}

{\selectlanguage{spanish}\ttfamily
end}

{\selectlanguage{spanish}\ttfamily
syntax\_error: stdin:3: redefinición de 'a'}

\subsubsection[No ocultar la variable local del alcance externo]{\selectlanguage{spanish} No ocultar la variable local
del alcance externo}
\hypertarget{RefHeadingToc359333639824055}{}{\selectlanguage{spanish}
En Berry puedes declarar variables locales con el mismo nombre en el ámbito interno. La variable en el ámbito interno
oculta la variable del ámbito externo durante la duración del ámbito.}

\foreignlanguage{spanish}{La única excepción son las variables que comienzan con el punto '.' que se pueden enmascarar
desde el alcance externo. Este es el caso de la variable local oculta
}\textstyleSourceText{\foreignlanguage{spanish}{.it}}\foreignlanguage{spanish}{ cuando se incrustan múltiples
}\textstyleSourceText{\foreignlanguage{spanish}{for}}\foreignlanguage{spanish}{.}


\bigskip

{\selectlanguage{spanish}\ttfamily
def f()}

{\selectlanguage{spanish}\ttfamily
\ \ var a \ \ \ \# variable en el ámbito externo}

{\selectlanguage{spanish}\ttfamily
\ \ if a}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ var a \ \# redefinición de a en ámbito interno}

{\selectlanguage{spanish}\ttfamily
\ \ end}

{\selectlanguage{spanish}\ttfamily
end}

{\selectlanguage{spanish}\ttfamily
syntax\_error: stdin:4: estricto: \ redefinición de 'a' desde el ámbito externo}

\subsection[8.2 Miembros virtuales]{\selectlanguage{spanish} 8.2 Miembros virtuales}
\hypertarget{RefHeadingToc359353639824055}{}{\selectlanguage{spanish}
Los miembros virtuales le permiten agregar de forma dinámica y programática miembros y métodos a clases y módulos. Ya no
está limitado a los miembros declarados en el momento de la creación.}

\foreignlanguage{spanish}{Esta función está inspirada en
}\textstyleSourceText{\foreignlanguage{spanish}{\_\_getattr\_\_()}}\foreignlanguage{spanish}{ /
}\textstyleSourceText{\foreignlanguage{spanish}{\_\_setattr\_\_()}}\foreignlanguage{spanish}{ de Python. La motivación
proviene de la integración de LVGL a Berry en Tasmota. La integración necesita cientos de constantes en un módulo y
miles de métodos asignados a funciones C. La creación estática de atributos y métodos funciona, pero consume una
cantidad significativa de espacio de código.}

{\selectlanguage{spanish}
Esta característica permite crear dos métodos:}


\bigskip

\begin{center}
\tablefirsthead{\centering{\selectlanguage{spanish}\bfseries Método Berry} &
\centering\arraybslash{\selectlanguage{spanish}\bfseries Descripción}\\}
\tablehead{\centering{\selectlanguage{spanish}\bfseries Método Berry} &
\centering\arraybslash{\selectlanguage{spanish}\bfseries Descripción}\\}
\tabletail{}
\tablelasttail{}
\begin{supertabular}{m{7.76cm}m{7.76cm}}
\centering \textstyleSourceText{\foreignlanguage{spanish}{member}} &
\centering\arraybslash \textstyleSourceText{\foreignlanguage{spanish}{(nombre:cadena) -{\textgreater}
any}}\foreignlanguage{spanish}{ Debería devolver el valor del
}\textstyleSourceText{\foreignlanguage{spanish}{nombre}}\\
\centering \textstyleSourceText{\foreignlanguage{spanish}{setmember}} &
\centering\arraybslash \textstyleSourceText{\foreignlanguage{spanish}{(nombre:cadena, valor:any) especificado
-{\textgreater} nil}}\foreignlanguage{spanish}{ Debería almacenar el 'valor' en el miembro virtual con el 'nombre'
especificado}\\
\end{supertabular}
\end{center}
\subsubsection[Módulo undefined]{\foreignlanguage{spanish}{Módulo
}\textstyleSourceText{\foreignlanguage{spanish}{undefined}}}
\hypertarget{RefHeadingToc359373639824055}{}\foreignlanguage{spanish}{La función
}\textstyleSourceText{\foreignlanguage{spanish}{member()}}\foreignlanguage{spanish}{ debe ser capaz de distinguir entre
un miembro con un valor }\textstyleSourceText{\foreignlanguage{spanish}{nil}}\foreignlanguage{spanish}{ y el miembro
que no existe. Para evitar cualquier ambigüedad, la función
}\textstyleSourceText{\foreignlanguage{spanish}{member()}}\foreignlanguage{spanish}{ puede indicar que el miembro no
existe de dos maneras:}

\liststyleLviii
\begin{itemize}
\item \foreignlanguage{spanish}{generar una excepción - o }\textstyleSourceText{\foreignlanguage{spanish}{import
undefined}}\foreignlanguage{spanish}{ y devolver el módulo
}\textstyleSourceText{\foreignlanguage{spanish}{undefined}}\foreignlanguage{spanish}{. Esto se usa como un marcador
para que la VM sepa que el atributo no existe, mientras se }\foreignlanguage{spanish}{beneficia de excepciones
consistentes.}
\end{itemize}
{\selectlanguage{spanish}
Ejemplo de un objeto dinámico al que puede agregar miembros, pero devolvería un error si el miembro no se agregó
previamente.}


\bigskip

{\selectlanguage{spanish}\ttfamily
class dyn}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ var \_attr}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ def init()}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ self.\_attr = \{\}}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ end}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ def setmember(nombre, valor)}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ self.\_attr[nombre] = valor}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ end}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ def member(nombre)}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ if self.\_attr.contains(nombre)}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ \ \ \ \ return self.\_attr[nombre]}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ else}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ \ \ \ \ import undefined}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ \ \ \ \ return undefined}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ end}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ end}

{\selectlanguage{spanish}\ttfamily
end}


\bigskip

{\selectlanguage{spanish}
Ejemplo de uso:}


\bigskip

{\selectlanguage{spanish}\ttfamily
{\textgreater} a = dyn()}

{\selectlanguage{spanish}\ttfamily
{\textgreater} a.a}

{\selectlanguage{spanish}\ttfamily
attribute\_error: el objeto 'dyn' no tiene el atributo 'a'}

{\selectlanguage{spanish}\ttfamily
stack traceback:}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ stdin:1: en función {\textasciigrave}main{\textasciigrave}}

{\selectlanguage{spanish}\ttfamily
{\textgreater} a.a = 1}

{\selectlanguage{spanish}\ttfamily
{\textgreater} a.a}

{\selectlanguage{spanish}\ttfamily
1}

{\selectlanguage{spanish}\ttfamily
{\textgreater} a.a = nil}

{\selectlanguage{spanish}\ttfamily
{\textgreater} a.a}

{\selectlanguage{spanish}\ttfamily
{\textgreater}}

\subsubsection[Llamada implícita de member()]{\foreignlanguage{spanish}{Llamada implícita de
}\textstyleSourceText{\foreignlanguage{spanish}{member()}}}
\hypertarget{RefHeadingToc359393639824055}{}\foreignlanguage{spanish}{Cuando se ejecuta el siguiente código
}\textstyleSourceText{\foreignlanguage{spanish}{a.b}}\foreignlanguage{spanish}{, Berry VM hace lo siguiente:}

\liststyleLix
\begin{itemize}
\item \foreignlanguage{spanish}{Obtiene el objeto llamado
}\textstyleSourceText{\foreignlanguage{spanish}{a}}\foreignlanguage{spanish}{ (local o global), genera una excepción si
no existe}
\item \foreignlanguage{spanish}{Comprueba si el objeto
}\textstyleSourceText{\foreignlanguage{spanish}{a}}\foreignlanguage{spanish}{ es de tipo
}\textstyleSourceText{\foreignlanguage{spanish}{módulo}}\foreignlanguage{spanish}{,
}\textstyleSourceText{\foreignlanguage{spanish}{instancia}}\foreignlanguage{spanish}{ o
}\textstyleSourceText{\foreignlanguage{spanish}{clase}}\foreignlanguage{spanish}{. Genera una excepción de lo
contrario}
\item \foreignlanguage{spanish}{Comprueba si el objeto
}\textstyleSourceText{\foreignlanguage{spanish}{a}}\foreignlanguage{spanish}{ tiene un miembro llamado
}\textstyleSourceText{\foreignlanguage{spanish}{b}}\foreignlanguage{spanish}{. En caso afirmativo, devuelve su valor,
en caso negativo, procede a continuación}
\item \foreignlanguage{spanish}{Si el objeto
}\textstyleSourceText{\foreignlanguage{spanish}{a}}\foreignlanguage{spanish}{ es del tipo
}\textstyleSourceText{\foreignlanguage{spanish}{clase}}\foreignlanguage{spanish}{, genera una excepción porque los
miembros virtuales no funcionan para métodos estáticos (clase)}
\item \foreignlanguage{spanish}{Comprueba si el objeto
}\textstyleSourceText{\foreignlanguage{spanish}{a}}\foreignlanguage{spanish}{ tiene un miembro llamado
}\textstyleSourceText{\foreignlanguage{spanish}{member}}\foreignlanguage{spanish}{ y es una
}\textstyleSourceText{\foreignlanguage{spanish}{función}}\foreignlanguage{spanish}{. En caso afirmativo, lo llama con
el parámetro
}\textstyleSourceText{\foreignlanguage{spanish}{{\textquotedbl}b{\textquotedbl}}}\foreignlanguage{spanish}{ como
cadena. Si no, genera una excepción}
\item \foreignlanguage{spanish}{Comprueba el valor de retorno. Si es el módulo
}\textstyleSourceText{\foreignlanguage{spanish}{undefined}}\foreignlanguage{spanish}{ genera una excepción que indica
que el miembro no existe}
\end{itemize}
\subsubsection[Llamada implícita de setmember()]{\foreignlanguage{spanish}{Llamada implícita de
}\textstyleSourceText{\foreignlanguage{spanish}{setmember()}}}
\hypertarget{RefHeadingToc359413639824055}{}\foreignlanguage{spanish}{Cuando se ejecuta el siguiente código
}\textstyleSourceText{\foreignlanguage{spanish}{ab = 0}}\foreignlanguage{spanish}{ (mutador), Berry VM hace lo
siguiente:}

\liststyleLx
\begin{itemize}
\item \foreignlanguage{spanish}{Obtiene el objeto llamado
}\textstyleSourceText{\foreignlanguage{spanish}{a}}\foreignlanguage{spanish}{ (local o global), genera una excepción si
no existe}
\item \foreignlanguage{spanish}{Comprueba si el objeto
}\textstyleSourceText{\foreignlanguage{spanish}{a}}\foreignlanguage{spanish}{ es de tipo
}\textstyleSourceText{\foreignlanguage{spanish}{módulo}}\foreignlanguage{spanish}{,
}\textstyleSourceText{\foreignlanguage{spanish}{instancia}}\foreignlanguage{spanish}{ o
}\textstyleSourceText{\foreignlanguage{spanish}{clase}}\foreignlanguage{spanish}{. Genera una excepción de lo
contrario}

\begin{itemize}
\item \foreignlanguage{spanish}{Si }\textstyleSourceText{\foreignlanguage{spanish}{a}}\foreignlanguage{spanish}{ es del
tipo }\textstyleSourceText{\foreignlanguage{spanish}{clase}}\foreignlanguage{spanish}{, comprueba si existe el miembro
}\textstyleSourceText{\foreignlanguage{spanish}{b}}\foreignlanguage{spanish}{. En caso afirmativo, cambia su valor. Si
no, genera una excepción. (los miembros virtuales no funcionan para clases o métodos estáticos)}
\item \foreignlanguage{spanish}{Si }\textstyleSourceText{\foreignlanguage{spanish}{a}}\foreignlanguage{spanish}{ es del
tipo }\textstyleSourceText{\foreignlanguage{spanish}{instancia}}\foreignlanguage{spanish}{, comprueba si existe el
miembro }\textstyleSourceText{\foreignlanguage{spanish}{b}}\foreignlanguage{spanish}{. En caso afirmativo, cambia su
valor. Si no, procede a continuación}

\begin{itemize}
\item \foreignlanguage{spanish}{Comprueba si
}\textstyleSourceText{\foreignlanguage{spanish}{a}}\foreignlanguage{spanish}{ tiene un miembro llamado
}\textstyleSourceText{\foreignlanguage{spanish}{setmember}}\foreignlanguage{spanish}{. Si es así, lo llama, si no,
genera una excepción.}
\end{itemize}
\item \foreignlanguage{spanish}{Si }\textstyleSourceText{\foreignlanguage{spanish}{a}}\foreignlanguage{spanish}{ es de
tipo }\textstyleSourceText{\foreignlanguage{spanish}{módulo}}\foreignlanguage{spanish}{. Si el módulo no es de solo
lectura, crea o cambia el valor (}\textstyleSourceText{\foreignlanguage{spanish}{setmember}}\foreignlanguage{spanish}{
nunca se llama para un módulo de escritura). Si el módulo es de solo lectura, entonces se llama a
}\textstyleSourceText{\foreignlanguage{spanish}{setmember}}\foreignlanguage{spanish}{ si existe.}
\end{itemize}
\end{itemize}
\subsubsection[Manejo de excepciones]{\selectlanguage{spanish} Manejo de excepciones}
\hypertarget{RefHeadingToc359433639824055}{}\foreignlanguage{spanish}{Para indicar que un miembro no existe,
}\textstyleSourceText{\foreignlanguage{spanish}{member()}}\foreignlanguage{spanish}{ devolverá
}\textstyleSourceText{\foreignlanguage{spanish}{undefined}}\foreignlanguage{spanish}{ después de
}\textstyleSourceText{\foreignlanguage{spanish}{import undefined}}\foreignlanguage{spanish}{. También puede generar una
excepción en }\textstyleSourceText{\foreignlanguage{spanish}{member()}}\foreignlanguage{spanish}{, pero tenga en cuenta
que Berry podría intentar llamar a métodos como
}\textstyleSourceText{\foreignlanguage{spanish}{tostring()}}\foreignlanguage{spanish}{ que aterrizarán en su método
}\textstyleSourceText{\foreignlanguage{spanish}{member()}}\foreignlanguage{spanish}{ si no existen como métodos
estáticos. Para indicar que un miembro no es válido,
}\textstyleSourceText{\foreignlanguage{spanish}{setmember()}}\foreignlanguage{spanish}{ debe generar una excepción o
devolver }\textstyleSourceText{\foreignlanguage{spanish}{undefined}}\foreignlanguage{spanish}{. Devolver cualquier otra
cosa como }\textstyleSourceText{\foreignlanguage{spanish}{nil}}\foreignlanguage{spanish}{ indica que la asignación fue
exitosa. Tenga en cuenta que puede recibir nombres de miembros que no sean identificadores válidos de Berry. La
sintaxis
}\textstyleSourceText{\foreignlanguage{spanish}{a.({\textquotedbl}{\textless}-{\textgreater}{\textquotedbl})}}\foreignlanguage{spanish}{
llamará a
}\textstyleSourceText{\foreignlanguage{spanish}{a.member({\textquotedbl}{\textless}-{\textgreater}{\textquotedbl})}}\foreignlanguage{spanish}{
con un nombre de miembro virtual que no es léxicamente válido, es decir, no se puede llamar en código normal, excepto
mediante el uso indirecto formas como
}\textstyleSourceText{\foreignlanguage{spanish}{introspect}}\foreignlanguage{spanish}{ o
}\textstyleSourceText{\foreignlanguage{spanish}{member()}}\foreignlanguage{spanish}{.}

\subsubsection[Especificidades para las clases]{\selectlanguage{spanish} Especificidades para las clases}
\hypertarget{RefHeadingToc359453639824055}{}{\selectlanguage{spanish}
El acceso a los miembros del objeto de clase no desencadena miembros virtuales. Por lo tanto, no es posible tener
métodos estáticos virtuales.}

\subsubsection[Especificidades de los módulos]{\selectlanguage{spanish} Especificidades de los módulos}
\hypertarget{RefHeadingToc359473639824055}{}\foreignlanguage{spanish}{Los módulos admiten la lectura de miembros
estáticos con }\textstyleSourceText{\foreignlanguage{spanish}{member()}}\foreignlanguage{spanish}{. Al escribir en un
miembro, el comportamiento depende de si el módulo es de escritura (en la memoria) o de solo lectura (en el firmware).
Si se puede escribir en el módulo, los nuevos miembros se agregan directamente al módulo y nunca se llama a
}\textstyleSourceText{\foreignlanguage{spanish}{setmember()}}\foreignlanguage{spanish}{. Si el módulo es de solo
lectura, se llama a }\textstyleSourceText{\foreignlanguage{spanish}{setmember()}}\foreignlanguage{spanish}{ cada vez
que intenta cambiar o crear un miembro. Entonces es su responsabilidad almacenar los valores en un objeto separado como
un global.}

\subsubsection[Ejemplo]{\selectlanguage{spanish} Ejemplo}
\hypertarget{RefHeadingToc359493639824055}{}
\bigskip

{\selectlanguage{spanish}\ttfamily
class T}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ var a}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ def init()}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ self.a = 'a'}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ end}


\bigskip

{\selectlanguage{spanish}\ttfamily
\ \ \ \ def member(nombre)}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ return {\textquotedbl}miembro {\textquotedbl}+nombre}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ end}


\bigskip

{\selectlanguage{spanish}\ttfamily
\ \ \ \ def setmember(nombre, valor)}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ print({\textquotedbl}Almacenar '{\textquotedbl}+nombre+{\textquotedbl}': {\textquotedbl}+str(valor))}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ end}

{\selectlanguage{spanish}\ttfamily
end}

{\selectlanguage{spanish}\ttfamily
t=T()}


\bigskip

{\selectlanguage{spanish}
Ahora intentémoslo:}


\bigskip

{\selectlanguage{spanish}\ttfamily
{\textgreater} t.a}

{\selectlanguage{spanish}\ttfamily
{}'a'}

{\selectlanguage{spanish}\ttfamily
{\textgreater} t.b}

{\selectlanguage{spanish}\ttfamily
{}'miembro b'}

{\selectlanguage{spanish}\ttfamily
{\textgreater} t.foo}

{\selectlanguage{spanish}\ttfamily
{}'miembro foo'}

{\selectlanguage{spanish}\ttfamily
{\textgreater} t.bar = 2}

{\selectlanguage{spanish}\ttfamily
Almacenar 'bar': 2}


\bigskip

{\selectlanguage{spanish}
Esto también funciona para los módulos:}


\bigskip

{\selectlanguage{spanish}\ttfamily
m = module()}

{\selectlanguage{spanish}\ttfamily
m.a = 1}

{\selectlanguage{spanish}\ttfamily
m.member = def (nombre)}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ return {\textquotedbl}miembro {\textquotedbl}+nombre}

{\selectlanguage{spanish}\ttfamily
end}

{\selectlanguage{spanish}\ttfamily
m.setmember(nombre, valor)}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ print({\textquotedbl}Almacenar '{\textquotedbl}+nombre+{\textquotedbl}': {\textquotedbl}+str(valor))}

{\selectlanguage{spanish}\ttfamily
end}


\bigskip

{\selectlanguage{spanish}
Intentemoslo:}


\bigskip

{\selectlanguage{spanish}\ttfamily
{\textgreater} m.a}

{\selectlanguage{spanish}\ttfamily
1}

{\selectlanguage{spanish}\ttfamily
{\textgreater} m.b}

{\selectlanguage{spanish}\ttfamily
{}'miembro b'}

{\selectlanguage{spanish}\ttfamily
{\textgreater} m.c = 3 \ \ \# la asignación es válida por lo que no se llama a {\textasciigrave}setmember()}

{\selectlanguage{spanish}\ttfamily
{\textgreater} m.c}

{\selectlanguage{spanish}\ttfamily
3}


\bigskip

{\selectlanguage{spanish}
Ejemplo más avanzado:}


\bigskip

{\selectlanguage{spanish}\ttfamily
{\textgreater} class A}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ var i}


\bigskip

{\selectlanguage{spanish}\ttfamily
\ \ \ \ def member(n)}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ if n == 'ii' return self.i end}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ return nil \ \ \ \ \# lo hacemos explícito aquí, pero esta línea es opcional}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ end}


\bigskip

{\selectlanguage{spanish}\ttfamily
\ \ \ \ def setmember(n, v)}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ if n == 'ii' self.i = v end}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ end}

{\selectlanguage{spanish}\ttfamily
\ \ end}

{\selectlanguage{spanish}\ttfamily
{\textgreater} a=A()}


\bigskip

{\selectlanguage{spanish}\ttfamily
{\textgreater} a.i \ \ \ \ \ \# devuelve nil}

{\selectlanguage{spanish}\ttfamily
{\textgreater} a.ii \ \ \ \ \# i llama implícitamente
{\textasciigrave}a.member({\textquotedbl}ii{\textquotedbl}){\textasciigrave}}

{\selectlanguage{spanish}\ttfamily
attribute\_error: el objeto 'A' no tiene atributo 'ii'}

{\selectlanguage{spanish}\ttfamily
stack traceback:}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ stdin:1: en función {\textasciigrave}main{\textasciigrave}}

{\selectlanguage{spanish}\ttfamily
\# devuelve un excepción ya que el miembro es nulo (considerado inexistente)}


\bigskip

{\selectlanguage{spanish}\ttfamily
{\textgreater} a.ii = 42 \ \ \ \# llama implícitamente {\textasciigrave}a.setmember({\textquotedbl}ii{\textquotedbl},
42){\textasciigrave}}

{\selectlanguage{spanish}\ttfamily
{\textgreater} a.ii \ \ \ \ \ \ \ \ \# llama implícitamente
{\textasciigrave}a.member({\textquotedbl}ii{\textquotedbl}){\textasciigrave} and returns
{\textasciigrave}42{\textasciigrave}}

{\selectlanguage{spanish}\ttfamily
42}

{\selectlanguage{spanish}\ttfamily
{\textgreater} a.i \ \ \ \ \ \ \ \ \ \# \ la variable concreta también fue cambiada}

{\selectlanguage{spanish}\ttfamily
42}

\subsection[8.3 Cómo empaquetar un módulo]{\selectlanguage{spanish} 8.3 Cómo empaquetar un módulo}
\hypertarget{RefHeadingToc359513639824055}{}{\selectlanguage{spanish}
Esta guía lo lleva a través de las diferentes opciones de empaquetado de código para su reutilización utilizando la
directiva de {\textquotedbl}import{\textquotedbl} de Berry.}

\subsubsection[Comportamiento de import]{\foreignlanguage{spanish}{Comportamiento de
}\textstyleSourceText{\foreignlanguage{spanish}{import}}}
\hypertarget{RefHeadingToc359533639824055}{}\foreignlanguage{spanish}{Cuando se utiliza
}\textstyleSourceText{\foreignlanguage{spanish}{import {\textless}modulo{\textgreater} [as
{\textless}nombre{\textgreater} ]}}\foreignlanguage{spanish}{, suceden los siguientes pasos:}

\liststyleLxiii
\begin{itemize}
\item \foreignlanguage{spanish}{Hay una caché global de todos los módulos ya importados. Si
}\textstyleSourceText{\foreignlanguage{spanish}{{\textless}modulo{\textgreater} }}\foreignlanguage{spanish}{ya fue
importado, }\textstyleSourceText{\foreignlanguage{spanish}{import}}\foreignlanguage{spanish}{ devuelve el valor en
caché ya devuelto por la primera llamada a
}\textstyleSourceText{\foreignlanguage{spanish}{import}}\foreignlanguage{spanish}{. No se realizan otras acciones.}
\item \textstyleSourceText{\foreignlanguage{spanish}{import}}\foreignlanguage{spanish}{ busca un módulo de nombre
}\textstyleSourceText{\foreignlanguage{spanish}{{\textless}modulo{\textgreater} }}\foreignlanguage{spanish}{en el
siguiente orden:}
\end{itemize}
\liststyleLxiv
\begin{enumerate}
\item {\selectlanguage{spanish}
en módulos nativos incrustados en el firmware en tiempo de compilación}
\item \foreignlanguage{spanish}{en el sistema de archivos, comenzando con el directorio actual, luego iterando en todos
los directorios desde }\textstyleSourceText{\foreignlanguage{spanish}{sys.path}}\foreignlanguage{spanish}{: busque el
archivo }\textstyleSourceText{\foreignlanguage{spanish}{{\textless}nombre{\textgreater} }}\foreignlanguage{spanish}{,
entonces
}\textstyleSourceText{\foreignlanguage{spanish}{{\textless}nombre{\textgreater}.bec}}\foreignlanguage{spanish}{ (código
de bytes compilado), luego
}\textstyleSourceText{\foreignlanguage{spanish}{{\textless}nombre{\textgreater}.be}}\foreignlanguage{spanish}{. Si
}\textstyleSourceText{\foreignlanguage{spanish}{BE\_USE\_SHARED\_LIB}}\foreignlanguage{spanish}{ está habilitado,
también busca bibliotecas compartidas como
}\textstyleSourceText{\foreignlanguage{spanish}{{\textless}nombre{\textgreater}.so que}}\foreignlanguage{spanish}{ o
}\textstyleSourceText{\foreignlanguage{spanish}{{\textless}nombre{\textgreater}.dll}}\foreignlanguage{spanish}{ aunque
esta opción generalmente no está disponible en MCU.}
\end{enumerate}
\liststyleLxv
\begin{itemize}
\item \foreignlanguage{spanish}{Se ejecuta el código cargado. El código debe terminar con una declaración
}\textstyleSourceText{\foreignlanguage{spanish}{return}}\foreignlanguage{spanish}{. El objeto devuelto se almacena en
la memoria caché global y se pone a disposición de la persona que llama (en el ámbito local o global).}
\item \foreignlanguage{spanish}{Si el objeto devuelto es un
}\textstyleSourceText{\foreignlanguage{spanish}{módulo}}\foreignlanguage{spanish}{ y si el módulo posee un miembro
}\textstyleSourceText{\foreignlanguage{spanish}{init}}\foreignlanguage{spanish}{, entonces se toma un paso adicional.
La función
}\textstyleSourceText{\foreignlanguage{spanish}{{\textless}modulo{\textgreater}.init(m)}}\foreignlanguage{spanish}{ se
llama pasando como argumento el propio objeto del módulo. El valor devuelto por
}\textstyleSourceText{\foreignlanguage{spanish}{init()}}\foreignlanguage{spanish}{ reemplaza el valor en el caché
global. Tenga en cuenta que }\textstyleSourceText{\foreignlanguage{spanish}{init()}}\foreignlanguage{spanish}{ se llama
como máximo una vez durante la primera
}\textstyleSourceText{\foreignlanguage{spanish}{importación}}\foreignlanguage{spanish}{.}
\end{itemize}
\foreignlanguage{spanish}{Nota: una función
}\textstyleSourceText{\foreignlanguage{spanish}{init(m)}}\foreignlanguage{spanish}{ implícita siempre está presente en
todos los módulos, incluso si no se declaró ninguno. Esta función implícita no tiene ningún efecto.}

\subsubsection[Empaquetado de un módulo]{\selectlanguage{spanish} Empaquetado de un módulo}
\hypertarget{RefHeadingToc359553639824055}{}{\selectlanguage{spanish}
Aquí hay un ejemplo simple de un módulo:}

\foreignlanguage{spanish}{Archivo
}\textstyleSourceText{\foreignlanguage{spanish}{demo\_modulo.be}}\foreignlanguage{spanish}{:}


\bigskip

{\selectlanguage{spanish}\ttfamily
\# modulo simple}

{\selectlanguage{spanish}\ttfamily
\# use {\textasciigrave}import demo\_modulo{\textasciigrave}}


\bigskip

{\selectlanguage{spanish}\ttfamily
demo\_module = module({\textquotedbl}demo\_module{\textquotedbl})}


\bigskip

{\selectlanguage{spanish}\ttfamily
demo\_modulo.foo = {\textquotedbl}bar{\textquotedbl}}


\bigskip

{\selectlanguage{spanish}\ttfamily
demo\_modulo.decir\_hola = def ()}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ print({\textquotedbl}Hola Berry!{\textquotedbl})}

{\selectlanguage{spanish}\ttfamily
end}


\bigskip

{\selectlanguage{spanish}\ttfamily
return demo\_modulo \ \ \ \ \ \# devuelve el módulo como salida de import}


\bigskip

{\selectlanguage{spanish}
Ejemplo de uso:}


\bigskip

{\selectlanguage{spanish}\ttfamily
{\textgreater} import demo\_modulo}


\bigskip

{\selectlanguage{spanish}\ttfamily
{\textgreater} demo\_modulo}

{\selectlanguage{spanish}\ttfamily
{\textless}module: demo\_modulo{\textgreater}}


\bigskip

{\selectlanguage{spanish}\ttfamily
{\textgreater} demo\_module.decir\_hola()}

{\selectlanguage{spanish}\ttfamily
Hola Berry!}


\bigskip

{\selectlanguage{spanish}\ttfamily
{\textgreater} demo\_modulo.foo}

{\selectlanguage{spanish}\ttfamily
{}'bar'}

{\selectlanguage{spanish}\ttfamily
{\textgreater} demo\_modulo.foo = {\textquotedbl}baz{\textquotedbl} \ \ \# el módulo se puede escribir, aunque esto es
muy desaconsejado}

{\selectlanguage{spanish}\ttfamily
{\textgreater} demo\_modulo.foo}

{\selectlanguage{spanish}\ttfamily
{}'baz'}

\subsubsection[Empaquetar un singleton (mónada)]{\selectlanguage{spanish} Empaquetar un singleton (mónada)}
\hypertarget{RefHeadingToc359573639824055}{}{\selectlanguage{spanish}
El problema de usar módulos es que no tienen variables de instancia para realizar un seguimiento de los datos. Están
diseñados esencialmente para bibliotecas sin estado.}

{\selectlanguage{spanish}
A continuación, encontrará una forma elegante de empaquetar una clase única devuelta como una {\textquotedbl}declaración
de importación{\textquotedbl}.}

{\selectlanguage{spanish}
Para ello, utilizamos diferentes trucos. Primero, declaramos la clase para el singleton como una clase interna de una
función, esto evita que se contamine el espacio de nombres global con esta clase. Es decir, la clase no será accesible
por otro código.}

\foreignlanguage{spanish}{En segundo lugar, declaramos una función
}\textstyleSourceText{\foreignlanguage{spanish}{init()}}\foreignlanguage{spanish}{ del módulo que crea la clase, crea
la instancia y la devuelve.}

\foreignlanguage{spanish}{Según este esquema, }\textstyleSourceText{\foreignlanguage{spanish}{import
{\textless}modulo{\textgreater} }}\foreignlanguage{spanish}{en realidad devuelve una instancia de una clase oculta.}

\foreignlanguage{spanish}{Ejemplo de
}\textstyleSourceText{\foreignlanguage{spanish}{demo\_monad.be}}\foreignlanguage{spanish}{:}


\bigskip

{\selectlanguage{spanish}\ttfamily
\# monada simple}

{\selectlanguage{spanish}\ttfamily
\# use {\textasciigrave}import demo\_monad{\textasciigrave}}


\bigskip

{\selectlanguage{spanish}\ttfamily
demo\_monad = module({\textquotedbl}demo\_monad{\textquotedbl})}


\bigskip

{\selectlanguage{spanish}\ttfamily
\# \ el módulo tiene un solo miembro {\textasciigrave}init(){\textasciigrave} y delega todo a la clase interna}

{\selectlanguage{spanish}\ttfamily
demo\_monad.init = def (m)}


\bigskip

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \# inncer class}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ class my\_monad}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ var i}


\bigskip

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ def init()}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ \ \ \ \ self.i = 0}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ end}


\bigskip

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ def say\_hello()}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ \ \ \ \ print({\textquotedbl}Hola Berry!{\textquotedbl})}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ end}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ end}


\bigskip

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \# rdevolver una sola instancia para esta clase}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ return my\_monad()}

{\selectlanguage{spanish}\ttfamily
end}


\bigskip

{\selectlanguage{spanish}\ttfamily
return demo\_monad \ \ \ \ \ \# evuelve el módulo como la salida de importación, que eventualmente se reemplaza por el
valor de retorno de 'init()'}


\bigskip

{\selectlanguage{spanish}
Ejemplo:}


\bigskip

{\selectlanguage{spanish}\ttfamily
{\textgreater} import demo\_monad}

{\selectlanguage{spanish}\ttfamily
{\textgreater} demo\_monad}

{\selectlanguage{spanish}\ttfamily
{\textless}instance: my\_monad(){\textgreater} \ \ \ \ \# es una instancia no un modulo}


\bigskip

{\selectlanguage{spanish}\ttfamily
{\textgreater} demo\_monad.say\_hello()}

{\selectlanguage{spanish}\ttfamily
Hola Berry!}


\bigskip

{\selectlanguage{spanish}\ttfamily
{\textgreater} demo\_monad.i = 42 \ \ \ \ \ \ \ \# \ puedes usarlo como cualquier instancia}

{\selectlanguage{spanish}\ttfamily
{\textgreater} demo\_monad.i}

{\selectlanguage{spanish}\ttfamily
42}


\bigskip

{\selectlanguage{spanish}\ttfamily
{\textgreater} demo\_monad.j = 0 \ \ \ \ \ \ \ \ \# hay una fuerte verificación de miembros en comparación con los
módulos }

{\selectlanguage{spanish}\ttfamily
Attribute\_error: la clase 'my\_monad' no puede asignarse al atributo 'j'}

{\selectlanguage{spanish}\ttfamily
stack traceback:}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ stdin:1: en función {\textasciigrave}main{\textasciigrave}}

\subsection[8.4 Solidificación]{\selectlanguage{spanish} 8.4 Solidificación}
\hypertarget{RefHeadingToc359593639824055}{}{\selectlanguage{spanish}
La solidificación es el proceso de capturar estructuras y códigos Berry compilados (clases, módulos, mapas, listas...) y
almacenarlos en el firmware. Reduce drásticamente el uso de la memoria, pero tiene algunas limitaciones.}

\subsubsection[Módulo solidify]{\foreignlanguage{spanish}{Módulo
}\textstyleSourceText{\foreignlanguage{spanish}{solidify}}}
\hypertarget{RefHeadingToc359613639824055}{}\foreignlanguage{spanish}{La solidificación es manejada por el módulo
}\textstyleSourceText{\foreignlanguage{spanish}{solidify}}\foreignlanguage{spanish}{. Este módulo no está compilado por
defecto debido a su tamaño (\~{}10kB). Debe compilar con la directiva
}\textstyleSourceText{\foreignlanguage{spanish}{\#define BE\_USE\_SOLIDIFY\_MODULE 1}}\foreignlanguage{spanish}{.}

\foreignlanguage{spanish}{El módulo tiene un solo miembro
}\textstyleSourceText{\foreignlanguage{spanish}{dump(x)}}\foreignlanguage{spanish}{ que toma un solo argumento (el
objeto a solidificar) y envía a }\textstyleSourceText{\foreignlanguage{spanish}{stdout}}\foreignlanguage{spanish}{ el
código solidificado.}

{\selectlanguage{spanish}
De forma predeterminada, solidify agrega todas las constantes de cadena al grupo global. En su lugar, puede generar
cadenas débiles (elegibles para la poda por parte del enlazador) estableciendo el segundo argumento en
{\textquotedbl}verdadero{\textquotedbl}.}

\foreignlanguage{spanish}{Por defecto,
}\textstyleSourceText{\foreignlanguage{spanish}{solidify.dump}}\foreignlanguage{spanish}{ genera el código solidificado
en la salida estándar. Puede especificar un archivo como tercer argumento. El archivo debe estar abierto en modo de
escritura y no está cerrado para que pueda concatenar varios objetos.}

\textstyleSourceText{\foreignlanguage{spanish}{solidify.dump(object:any, [, strings\_weak:bool, file\_out:file])
-{\textgreater} nil}}

\subsubsection[Solidificación de funciones]{\selectlanguage{spanish} Solidificación de funciones}
\hypertarget{RefHeadingToc359633639824055}{}{\selectlanguage{spanish}
Puede solidificar una sola función.}

{\selectlanguage{spanish}
Ejemplo:}


\bigskip

{\selectlanguage{spanish}\ttfamily
{\textgreater} def f() return {\textquotedbl}hello{\textquotedbl} end}

{\selectlanguage{spanish}\ttfamily
{\textgreater} import solidify}

{\selectlanguage{spanish}\ttfamily
{\textgreater} solidify.dump(f)}

{\selectlanguage{spanish}\ttfamily
/********************************************************************}

{\selectlanguage{spanish}\ttfamily
** Solidified function: f}

{\selectlanguage{spanish}\ttfamily
********************************************************************/}

{\selectlanguage{spanish}\ttfamily
be\_local\_closure(f, \ \ /* name */}

{\selectlanguage{spanish}\ttfamily
\ \ be\_nested\_proto(}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ 0, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ /* nstack */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ 0, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ /* argc */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ 0, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ /* varg */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ 0, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ /* has upvals */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ NULL, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ /* no upvals */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ 0, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ /* has sup protos */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ NULL, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ /* no sub protos */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ 1, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ /* has constants */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ ( \&(const bvalue[ 1]) \{ \ \ \ \ /* constants */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ /* K0 \ \ */ \ be\_nested\_str(hello),}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \}),}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \&be\_const\_str\_f,}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \&be\_const\_str\_solidified,}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ ( \&(const binstruction[ 1]) \{ \ /* code */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ 0x80060000, \ // \ 0000 \ RET \ \ \ 1 \ \ K0}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \})}

{\selectlanguage{spanish}\ttfamily
\ \ )}

{\selectlanguage{spanish}\ttfamily
);}

{\selectlanguage{spanish}\ttfamily
/*******************************************************************/}


\bigskip

\foreignlanguage{spanish}{Para compilar utilizando cadenas débiles (es decir, cadenas que el enlazador puede eliminar si
el objeto no está incluido en el ejecutable de destino), use
}\textstyleSourceText{\foreignlanguage{spanish}{solidify.dump(f, true)}}\foreignlanguage{spanish}{:}


\bigskip

{\selectlanguage{spanish}\ttfamily
/********************************************************************}

{\selectlanguage{spanish}\ttfamily
** Solidified function: f}

{\selectlanguage{spanish}\ttfamily
********************************************************************/}

{\selectlanguage{spanish}\ttfamily
be\_local\_closure(f, \ \ /* name */}

{\selectlanguage{spanish}\ttfamily
\ \ be\_nested\_proto(}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ 0, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ /* nstack */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ 0, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ /* argc */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ 0, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ /* varg */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ 0, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ /* has upvals */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ NULL, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ /* no upvals */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ 0, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ /* has sup protos */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ NULL, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ /* no sub protos */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ 1, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ /* has constants */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ ( \&(const bvalue[ 1]) \{ \ \ \ \ /* constants */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ /* K0 \ \ */ \ be\_nested\_str\_weak(hello),}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \}),}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ be\_str\_weak(f),}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \&be\_const\_str\_solidified,}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ ( \&(const binstruction[ 1]) \{ \ /* code */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ 0x80060000, \ // \ 0000 \ RET \ \ \ 1 \ \ K0}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \})}

{\selectlanguage{spanish}\ttfamily
\ \ )}

{\selectlanguage{spanish}\ttfamily
);}

{\selectlanguage{spanish}\ttfamily
/*******************************************************************/}

\subsubsection[Solidificación de clases]{\selectlanguage{spanish} Solidificación de clases}
\hypertarget{RefHeadingToc359653639824055}{}\foreignlanguage{spanish}{Cuando solidifica una clase, incrusta todos los
subelementos. También se agrega un código auxiliar
}\textstyleSourceText{\foreignlanguage{spanish}{C}}\foreignlanguage{spanish}{ para crear la clase y agregarla al ámbito
global.}


\bigskip

{\selectlanguage{spanish}\ttfamily
{\textgreater} \ class demo}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ var i}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ static foo = {\textquotedbl}bar{\textquotedbl}}


\bigskip

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ def init()}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ \ \ self.i = 0}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ end}


\bigskip

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ def say\_hello()}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ \ \ print({\textquotedbl}Hello Berry!{\textquotedbl})}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ end}

{\selectlanguage{spanish}\ttfamily
\ \ end}

{\selectlanguage{spanish}\ttfamily
{\textgreater} import solidify}

{\selectlanguage{spanish}\ttfamily
{\textgreater} solidify.dump(demo)}


\bigskip

{\selectlanguage{spanish}\ttfamily
/********************************************************************}

{\selectlanguage{spanish}\ttfamily
** Solidified function: init}

{\selectlanguage{spanish}\ttfamily
********************************************************************/}

{\selectlanguage{spanish}\ttfamily
be\_local\_closure(demo\_init, \ \ /* name */}

{\selectlanguage{spanish}\ttfamily
\ \ be\_nested\_proto(}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ 1, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ /* nstack */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ 1, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ /* argc */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ 2, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ /* varg */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ 0, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ /* has upvals */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ NULL, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ /* no upvals */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ 0, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ /* has sup protos */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ NULL, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ /* no sub protos */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ 1, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ /* has constants */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ ( \&(const bvalue[ 2]) \{ \ \ \ \ /* constants */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ /* K0 \ \ */ \ be\_nested\_str(i),}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ /* K1 \ \ */ \ be\_const\_int(0),}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \}),}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \&be\_const\_str\_init,}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \&be\_const\_str\_solidified,}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ ( \&(const binstruction[ 2]) \{ \ /* code */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ 0x90020101, \ // \ 0000 \ SETMBR R0 \ K0 \ K1}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ 0x80000000, \ // \ 0001 \ RET \ \ \ 0}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \})}

{\selectlanguage{spanish}\ttfamily
\ \ )}

{\selectlanguage{spanish}\ttfamily
);}

{\selectlanguage{spanish}\ttfamily
/*******************************************************************/}


\bigskip

{\selectlanguage{spanish}\ttfamily
/********************************************************************}

{\selectlanguage{spanish}\ttfamily
** Solidified function: say\_hello}

{\selectlanguage{spanish}\ttfamily
********************************************************************/}

{\selectlanguage{spanish}\ttfamily
be\_local\_closure(demo\_say\_hello, \ \ /* name */}

{\selectlanguage{spanish}\ttfamily
\ \ be\_nested\_proto(}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ 3, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ /* nstack */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ 1, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ /* argc */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ 2, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ /* varg */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ 0, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ /* has upvals */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ NULL, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ /* no upvals */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ 0, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ /* has sup protos */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ NULL, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ /* no sub protos */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ 1, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ /* has constants */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ ( \&(const bvalue[ 1]) \{ \ \ \ \ /* constants */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ /* K0 \ \ */ \ be\_nested\_str(Hello\_X20Berry\_X21),}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \}),}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \&be\_const\_str\_say\_hello,}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \&be\_const\_str\_solidified,}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ ( \&(const binstruction[ 4]) \{ \ /* code */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ 0x60040001, \ // \ 0000 \ GETGBL R1 \ G1}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ 0x58080000, \ // \ 0001 \ LDCONST \ \ \ R2 \ K0}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ 0x7C040200, \ // \ 0002 \ CALL \ \ R1 \ 1}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ 0x80000000, \ // \ 0003 \ RET \ \ \ 0}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \})}

{\selectlanguage{spanish}\ttfamily
\ \ )}

{\selectlanguage{spanish}\ttfamily
);}

{\selectlanguage{spanish}\ttfamily
/*******************************************************************/}


\bigskip

{\selectlanguage{spanish}\ttfamily
/********************************************************************}

{\selectlanguage{spanish}\ttfamily
** Solidified class: demo}

{\selectlanguage{spanish}\ttfamily
********************************************************************/}

{\selectlanguage{spanish}\ttfamily
be\_local\_class(demo,}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ 1,}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ NULL,}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ be\_nested\_map(4,}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ ( (struct bmapnode*) \&(const bmapnode[]) \{}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ \{ be\_const\_key(i, -1), be\_const\_var(0) \},}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ \{ be\_const\_key(say\_hello, 2), be\_const\_closure(demo\_say\_hello\_closure) \},}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ \{ be\_const\_key(init, -1), be\_const\_closure(demo\_init\_closure) \},}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ \{ be\_const\_key(foo, 1), be\_nested\_str(bar) \},}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \})),}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ (bstring*) \&be\_const\_str\_demo}

{\selectlanguage{spanish}\ttfamily
);}

{\selectlanguage{spanish}\ttfamily
/*******************************************************************/}


\bigskip

{\selectlanguage{spanish}\ttfamily
void be\_load\_demo\_class(bvm *vm) \{}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ be\_pushntvclass(vm, \&be\_class\_demo);}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ be\_setglobal(vm, {\textquotedbl}demo{\textquotedbl});}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ be\_pop(vm, 1);}

{\selectlanguage{spanish}\ttfamily
\}}


\bigskip

{\selectlanguage{spanish}
Las subclases también son compatibles.}


\bigskip

{\selectlanguage{spanish}\ttfamily
{\textgreater} class demo\_sub : demo}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ var j}


\bigskip

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ def init()}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ \ \ super(self).init()}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ \ \ self.j = 1}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ end}

{\selectlanguage{spanish}\ttfamily
\ \ end}

{\selectlanguage{spanish}\ttfamily
{\textgreater} solidify.dump(demo\_sub)}


\bigskip

{\selectlanguage{spanish}\ttfamily
/********************************************************************}

{\selectlanguage{spanish}\ttfamily
** Solidified function: init}

{\selectlanguage{spanish}\ttfamily
********************************************************************/}

{\selectlanguage{spanish}\ttfamily
be\_local\_closure(demo\_sub\_init, \ \ /* name */}

{\selectlanguage{spanish}\ttfamily
\ \ be\_nested\_proto(}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ 3, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ /* nstack */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ 1, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ /* argc */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ 0, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ /* varg */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ 0, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ /* has upvals */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ NULL, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ /* no upvals */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ 0, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ /* has sup protos */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ NULL, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ /* no sub protos */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ 1, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ /* has constants */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ ( \&(const bvalue[ 3]) \{ \ \ \ \ /* constants */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ /* K0 \ \ */ \ be\_nested\_str(init),}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ /* K1 \ \ */ \ be\_nested\_str(j),}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ /* K2 \ \ */ \ be\_const\_int(1),}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \}),}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \&be\_const\_str\_init,}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \&be\_const\_str\_solidified,}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ ( \&(const binstruction[ 7]) \{ \ /* code */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ 0x60040003, \ // \ 0000 \ GETGBL R1 \ G3}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ 0x5C080000, \ // \ 0001 \ MOVE \ \ R2 \ R0}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ 0x7C040200, \ // \ 0002 \ CALL \ \ R1 \ 1}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ 0x8C040300, \ // \ 0003 \ GETMET R1 \ R1 \ K0}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ 0x7C040200, \ // \ 0004 \ CALL \ \ R1 \ 1}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ 0x90020302, \ // \ 0005 \ SETMBR R0 \ K1 \ K2}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ 0x80000000, \ // \ 0006 \ RET \ \ \ 0}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \})}

{\selectlanguage{spanish}\ttfamily
\ \ )}

{\selectlanguage{spanish}\ttfamily
);}

{\selectlanguage{spanish}\ttfamily
/*******************************************************************/}


\bigskip

{\selectlanguage{spanish}\ttfamily
/********************************************************************}

{\selectlanguage{spanish}\ttfamily
** Solidified class: demo\_sub}

{\selectlanguage{spanish}\ttfamily
********************************************************************/}

{\selectlanguage{spanish}\ttfamily
extern const bclass be\_class\_demo;}

{\selectlanguage{spanish}\ttfamily
be\_local\_class(demo\_sub,}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ 1,}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \&be\_class\_demo,}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ be\_nested\_map(2,}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ ( (struct bmapnode*) \&(const bmapnode[]) \{}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ \{ be\_const\_key(init, -1), be\_const\_closure(demo\_sub\_init\_closure) \},}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ \{ be\_const\_key(j, 0), be\_const\_var(0) \},}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \})),}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ be\_str\_literal({\textquotedbl}demo\_sub{\textquotedbl})}

{\selectlanguage{spanish}\ttfamily
);}

{\selectlanguage{spanish}\ttfamily
/*******************************************************************/}


\bigskip

{\selectlanguage{spanish}\ttfamily
void be\_load\_demo\_sub\_class(bvm *vm) \{}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ be\_pushntvclass(vm, \&be\_class\_demo\_sub);}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ be\_setglobal(vm, {\textquotedbl}demo\_sub{\textquotedbl});}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ be\_pop(vm, 1);}

{\selectlanguage{spanish}\ttfamily
\}}

\subsubsection[Solidificación de módulos]{\selectlanguage{spanish} Solidificación de módulos}
\hypertarget{RefHeadingToc359673639824055}{}{\selectlanguage{spanish}
Cuando solidifica un módulo, incrusta todos los subelementos. También funciona con listas o mapas incrustados.}


\bigskip

{\selectlanguage{spanish}\ttfamily
{\textgreater} def say\_hello() print({\textquotedbl}Hello Berry!{\textquotedbl}) end}

{\selectlanguage{spanish}\ttfamily
{\textgreater} m = module({\textquotedbl}demo\_module{\textquotedbl})}

{\selectlanguage{spanish}\ttfamily
{\textgreater} m.i = 0}

{\selectlanguage{spanish}\ttfamily
{\textgreater} m.s = {\textquotedbl}foo{\textquotedbl}}

{\selectlanguage{spanish}\ttfamily
{\textgreater} m.f = say\_hello}

{\selectlanguage{spanish}\ttfamily
{\textgreater} m.l = [0,1,{\textquotedbl}a{\textquotedbl}]}

{\selectlanguage{spanish}\ttfamily
{\textgreater} m.m = \{{\textquotedbl}a{\textquotedbl}:{\textquotedbl}b{\textquotedbl},
{\textquotedbl}2{\textquotedbl}:3\}}

{\selectlanguage{spanish}\ttfamily
{\textgreater} import solidify}

{\selectlanguage{spanish}\ttfamily
{\textgreater} solidify.dump(m)}


\bigskip

{\selectlanguage{spanish}\ttfamily
/********************************************************************}

{\selectlanguage{spanish}\ttfamily
** Solidified function: say\_hello}

{\selectlanguage{spanish}\ttfamily
********************************************************************/}

{\selectlanguage{spanish}\ttfamily
be\_local\_closure(demo\_module\_say\_hello, \ \ /* name */}

{\selectlanguage{spanish}\ttfamily
\ \ be\_nested\_proto(}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ 2, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ /* nstack */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ 0, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ /* argc */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ 0, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ /* varg */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ 0, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ /* has upvals */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ NULL, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ /* no upvals */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ 0, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ /* has sup protos */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ NULL, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ /* no sub protos */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ 1, \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ /* has constants */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ ( \&(const bvalue[ 1]) \{ \ \ \ \ /* constants */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ /* K0 \ \ */ \ be\_nested\_str(Hello\_X20Berry\_X21),}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \}),}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \&be\_const\_str\_say\_hello,}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \&be\_const\_str\_solidified,}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ ( \&(const binstruction[ 4]) \{ \ /* code */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ 0x60000001, \ // \ 0000 \ GETGBL R0 \ G1}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ 0x58040000, \ // \ 0001 \ LDCONST \ \ \ R1 \ K0}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ 0x7C000200, \ // \ 0002 \ CALL \ \ R0 \ 1}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ 0x80000000, \ // \ 0003 \ RET \ \ \ 0}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \})}

{\selectlanguage{spanish}\ttfamily
\ \ )}

{\selectlanguage{spanish}\ttfamily
);}

{\selectlanguage{spanish}\ttfamily
/*******************************************************************/}


\bigskip

{\selectlanguage{spanish}\ttfamily
/********************************************************************}

{\selectlanguage{spanish}\ttfamily
** Solidified module: demo\_module}

{\selectlanguage{spanish}\ttfamily
********************************************************************/}

{\selectlanguage{spanish}\ttfamily
be\_local\_module(demo\_module,}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ {\textquotedbl}demo\_module{\textquotedbl},}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ be\_nested\_map(5,}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ ( (struct bmapnode*) \&(const bmapnode[]) \{}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ \{ be\_const\_key(l, -1), be\_const\_simple\_instance(be\_nested\_simple\_instance(\&be\_class\_list,
\{}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ be\_const\_list( * \ \ \ \ be\_nested\_list(3,}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ ( (struct bvalue*) \&(const bvalue[]) \{}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ be\_const\_int(0),}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ be\_const\_int(1),}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ be\_nested\_str(a),}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \})) \ \ \ ) \} )) \},}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ \{ be\_const\_key(m, 3), be\_const\_simple\_instance(be\_nested\_simple\_instance(\&be\_class\_map, \{}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ be\_const\_map( * \ \ \ \ be\_nested\_map(2,}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ ( (struct bmapnode*) \&(const bmapnode[]) \{}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ \{ be\_const\_key(a, -1), be\_nested\_str(b) \},}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ \{ be\_const\_key(2, -1), be\_const\_int(3) \},}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \})) \ \ \ ) \} )) \},}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ \{ be\_const\_key(i, 4), be\_const\_int(0) \},}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ \{ be\_const\_key(f, -1), be\_const\_closure(demo\_module\_say\_hello\_closure) \},}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ \{ be\_const\_key(s, -1), be\_nested\_str(foo) \},}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \}))}

{\selectlanguage{spanish}\ttfamily
);}

{\selectlanguage{spanish}\ttfamily
BE\_EXPORT\_VARIABLE be\_define\_const\_native\_module(demo\_module);}

{\selectlanguage{spanish}\ttfamily
/********************************************************************/}

\subsubsection[limitaciones de la solidificación]{\selectlanguage{spanish} limitaciones de la solidificación}
\hypertarget{RefHeadingToc359693639824055}{}\foreignlanguage{spanish}{La solidificación funciona para muchos objetos:
}\textstyleSourceText{\foreignlanguage{spanish}{clase}}\foreignlanguage{spanish}{,
}\textstyleSourceText{\foreignlanguage{spanish}{módulo}}\foreignlanguage{spanish}{,
}\textstyleSourceText{\foreignlanguage{spanish}{funciones}}\foreignlanguage{spanish}{ y constantes incrustadas u
objetos como }\textstyleSourceText{\foreignlanguage{spanish}{int}}\foreignlanguage{spanish}{,
}\textstyleSourceText{\foreignlanguage{spanish}{real}}\foreignlanguage{spanish}{,
}\textstyleSourceText{\foreignlanguage{spanish}{string}}\foreignlanguage{spanish}{,
}\textstyleSourceText{\foreignlanguage{spanish}{list}}\foreignlanguage{spanish}{ y
}\textstyleSourceText{\foreignlanguage{spanish}{map}}\foreignlanguage{spanish}{.}

{\selectlanguage{spanish}
Limitaciones:}

\liststyleLxvi
\begin{itemize}
\item {\selectlanguage{spanish}
Los upvals no son compatibles. No puede solidificar un cierre que captura upvals del alcance externo}
\item \foreignlanguage{spanish}{La captura de variables globales requiere compilar con la opción
}\textstyleSourceText{\foreignlanguage{spanish}{{}-g}}\foreignlanguage{spanish}{ {\textquotedbl}globales con
nombre{\textquotedbl} (habilitada de forma predeterminada en Tasmota)}
\item {\selectlanguage{spanish}
Las constantes de cadena están limitadas a 255 bytes, cadenas largas (más de 255 caracteres no son compatibles, porque
nadie nunca los necesitó)}
\item {\selectlanguage{spanish}
Los objetos solidificados son de solo lectura, esto tiene algunas consecuencias en las clases. Puede solidificar una
clase con sus miembros estáticos cuando se crea, pero no puede solidificar una función que crea una clase derivada de
otra clase o con miembros estáticos. La razón principal es que la configuración de la superclase o la asignación de
miembros estáticos se implementa mediante el código mutante en la nueva clase, que no puede funcionar en una clase no
mutante de solo lectura.}
\item {\selectlanguage{spanish}
El código solidificado puede depender del tamaño de {\textquotedbl}int{\textquotedbl} y
{\textquotedbl}real{\textquotedbl} y es posible que no se transfiera a través de MCU con tipos de diferentes tamaños.
Es posible que deba volver a solidificar para cada objetivo.}
\end{itemize}
\clearpage\section[Capítulo 9: Interfaz de Función
Externa]{\foreignlanguage{spanish}{C}\foreignlanguage{spanish}{apítulo 9: }Interfaz de Función Externa}
\hypertarget{RefHeadingToc359713639824055}{}
\bigskip

{\selectlanguage{spanish}
La \textbf{Interfaz de Función Externa} (FFI) es una interfaz para la interacción entre diferentes lenguajes. Berry
proporciona un conjunto de FFI para realizar la interacción con el lenguaje C, este conjunto de interfaces también es
muy fácil de usar en C++. La mayoría de las interfaces FFI son funciones y sus declaraciones se colocan en el archivo
\textit{berry.h}. Para reducir la cantidad de RAM utilizada, FFI también proporciona un mecanismo para generar una
tabla hash fija durante la compilación de C. Este mecanismo debe utilizar herramientas externas para generar código C.}

\subsection[9.1 Conceptos básicos]{\selectlanguage{spanish} 9.1 Conceptos básicos}
\hypertarget{RefHeadingToc359733639824055}{}{\selectlanguage{spanish}
La función interactiva más importante en FFI debería ser la función de llamar al código Berry y la función C mutuamente.
Para darnos cuenta de cómo dos lenguajes llaman a las funciones del otro, primero debemos entender el mecanismo de paso
de parámetros de la función de Berry.}

\subsubsection[9.1.1 Máquina virtual]{\selectlanguage{spanish} 9.1.1 Máquina virtual}
\hypertarget{RefHeadingToc359753639824055}{}\foreignlanguage{spanish}{A diferencia de los lenguajes compilados, el
lenguaje Berry no puede ejecutarse directamente en una máquina física, sino en un entorno de software específico, que
es }\foreignlanguage{spanish}{\textbf{Máquina virtual}}\foreignlanguage{spanish}{ (VM). Similar a una computadora real,
el código fuente en forma de texto no se puede ejecutar en una máquina virtual, sino que un compilador debe convertirlo
en {\textquotedbl}código de bytes{\textquotedbl}. La máquina virtual Berry se define como una estructura C
}\textstyleSourceText{\foreignlanguage{spanish}{bvm}}\foreignlanguage{spanish}{, el contenido de esta estructura es
invisible para FFI. A través de algunas funciones de FFI, podemos crear e inicializar una máquina virtual.
Introduciremos el uso de máquinas virtuales a través de un ejemplo sencillo:}


\bigskip

{\selectlanguage{spanish}\ttfamily
void berry\_test(void)}

{\selectlanguage{spanish}\ttfamily
\{}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ bvm *vm = be\_vm\_new(); // Construir una VM}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ be\_loadstring(vm, {\textquotedbl}print('Hola Berry'){\textquotedbl}); // Compilar código de prueba}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ be\_pcall(vm, 0); // Función de llamada}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ be\_vm\_delete(vm); // Destruir la VM}

{\selectlanguage{spanish}\ttfamily
\}}


\bigskip

\foreignlanguage{spanish}{Este código da un ejemplo completo del uso de una máquina virtual. Primero, se llama a la
función }\textstyleSourceText{\foreignlanguage{spanish}{be\_vm\_new}}\foreignlanguage{spanish}{ para construir una
nueva máquina virtual, y luego todas las operaciones se completan en este objeto de máquina virtual. La función
}\textstyleSourceText{\foreignlanguage{spanish}{be\_vm\_new}}\foreignlanguage{spanish}{ vinculará automáticamente la
biblioteca estándar al crear una máquina virtual. La función de las líneas 4 a 5 es compilar el código fuente de una
cadena en una función Berry y luego llamarla. Finalmente, se llama a la función
}\textstyleSourceText{\foreignlanguage{spanish}{be\_vm\_delete}}\foreignlanguage{spanish}{ en la línea 6 para destruir
la máquina virtual. Al ejecutar esta función obtendrá una línea de salida en la terminal:}

\textstyleSourceText{\foreignlanguage{spanish}{Hola Berry}}

\foreignlanguage{spanish}{En todos los escenarios, la construcción de la máquina virtual, la carga de la biblioteca y el
proceso de destrucción son los mismos que en las líneas 3, 4 y 6 del ejemplo anterior. Si es necesario, la forma de
compilar o cargar el código fuente puede ser diferente. Por ejemplo, }\foreignlanguage{spanish}{para el código fuente
en forma de archivo, se puede compilar a través de la función
}\textstyleSourceText{\foreignlanguage{spanish}{be\_loadfile}}\foreignlanguage{spanish}{. El código fuente se compilará
en una función Berry y la función se almacenará en la parte superior de la pila. La función Berry se puede ejecutar
llamando a la función FFI }\textstyleSourceText{\foreignlanguage{spanish}{be\_pcall}}\foreignlanguage{spanish}{ o
}\textstyleSourceText{\foreignlanguage{spanish}{be\_call}}\foreignlanguage{spanish}{. También puede usar REPL a través
de la función }\textstyleSourceText{\foreignlanguage{spanish}{be\_repl}}\foreignlanguage{spanish}{. La interfaz del
REPL se describirá en los capítulos correspondientes.}

\subsubsection[9.1.2 Pila virtual]{\selectlanguage{spanish} 9.1.2 Pila virtual}
\hypertarget{RefHeadingToc359773639824055}{}{\selectlanguage{spanish}
Berry usa una pila virtual y funciones nativas escritas en C para pasar valores. Cada elemento de la pila es un valor
Berry. Cuando el código Berry llama a una función nativa, siempre crea una nueva pila y empuja todos los parámetros a
la pila. Esta pila virtual también se puede usar en código C para almacenar datos, y el recolector de elementos no
utilizados no reclamará el valor almacenado en la pila.}


\bigskip

 \includegraphics[width=19.967cm,height=6.456cm]{berryrmeses-img001.png} 


\bigskip

{\selectlanguage{spanish}
La pila virtual utilizada por Berry se muestra en la figura anterior.}

\foreignlanguage{spanish}{La pila virtual crece de izquierda a derecha. Cuando el código Berry llama a una función
nativa, obtendrá una pila inicial. La posición del primer valor de la pila se llama
}\foreignlanguage{spanish}{\textbf{base}}\foreignlanguage{spanish}{, y la última posición se llama
}\foreignlanguage{spanish}{\textbf{superior}}\foreignlanguage{spanish}{ (top), en la función nativa solo el valor desde
la parte inferior de la pila hasta la posición anterior a la parte superior de la pila puede ser accesible. La posición
de la parte inferior de la pila es fija, mientras que la posición de la parte superior de la pila se puede mover y la
parte superior de la pila siempre está vacía. El motivo de esta propiedad es que después de insertar el nuevo valor en
la pila virtual, en la posición original de la parte superior de la pila se escribirá el nuevo valor, el puntero
superior de la pila avanzará a la siguiente posición; por el contrario, si se extrae el valor en la parte superior de
la pila virtual, el puntero superior de la pila disminuirá de 1. En este momento, aunque la posición del puntero
superior de la pila es objetivamente un valor, este no es válido y se puede borrar en cualquier momento, por lo que la
posición del puntero en la parte superior de la pila aún está vacía. Cuando la pila virtual está vacía, el puntero
inferior }\textstyleSourceText{\foreignlanguage{spanish}{base}}\foreignlanguage{spanish}{ es igual al puntero superior
}\textstyleSourceText{\foreignlanguage{spanish}{top}}\foreignlanguage{spanish}{. La pila virtual no sigue estrictamente
las reglas de funcionamiento de la pila: además de empujar y sacar, también se puede acceder a la pila virtual por
índice, e incluso insertar o eliminar valores en cualquier posición. Hay dos formas de indexar
}\foreignlanguage{spanish}{elementos en la pila: una se basa en la parte inferior de la pila
}\foreignlanguage{spanish}{\textbf{Índice absoluto}}\foreignlanguage{spanish}{, el valor del índice absoluto es un
número entero positivo a partir de 1; el otro se basa en la parte superior de la pila
}\foreignlanguage{spanish}{\textbf{Índice relativo}}\foreignlanguage{spanish}{, el valor del índice relativo es un
número entero negativo a partir de $-$ 1. Tome la Figura anterior como ejemplo, el valor de índice 1, 2{\dots}8 es un
índice absoluto, y el índice absoluto de un elemento es la distancia desde el elemento hasta el final de la pila. El
valor de índice $-$ 1, $-$ 2{\dots} $-$ 8 es un índice relativo, y el valor de índice relativo de un elemento es el
número negativo de la distancia desde el elemento hasta la parte superior de la pila. Si un valor de índice
}\foreignlanguage{spanish}{\textit{index}}\foreignlanguage{spanish}{ es válido, entonces el elemento al que se refiere
debe estar entre la parte inferior de la pila y la parte superior de la pila, lo que significa se cumple que la
expresión:}

\textstyleSourceText{\foreignlanguage{spanish}{1 ${\leq}$ abs(*index*) ${\leq}$ *top* $-$ *base* +
1}}\foreignlanguage{spanish}{.}

\foreignlanguage{spanish}{Por conveniencia, estipulamos que el puntero inferior de la pila 'base' se usa como
referencia, y su índice absoluto 1, y el valor anterior de 'base' no se considera (por lo general, 'base' no es la
posición inferior de todo el pila). Por ejemplo, cuando regresa una función nativa, la ubicación donde se almacena el
valor de retorno está justo antes de }\textstyleSourceText{\foreignlanguage{spanish}{base}}\foreignlanguage{spanish}{,
y la función nativa no suele acceder a estas ubicaciones.}

\subsubsection[9.1.3 Operar con pila virtual]{\selectlanguage{spanish} 9.1.3 Operar con pila virtual}
\hypertarget{RefHeadingToc359793639824055}{}\paragraph[Índice y tamaño de pila]{\selectlanguage{spanish} Índice y tamaño
de pila}
\hypertarget{RefHeadingToc359813639824055}{}\foreignlanguage{spanish}{Como se mencionó anteriormente, se pueden usar dos
métodos de indexación para acceder a la pila virtual y el valor del índice debe ser válido. Al mismo tiempo, en muchos
casos también es necesario introducir nuevos valores en la pila. En este caso, el programador debe asegurarse de que la
pila no se desborde. Por defecto, Berry garantiza el espacio
}\textstyleSourceText{\foreignlanguage{spanish}{BE\_STACK\_FREE\_MIN}}\foreignlanguage{spanish}{ para que lo usen las
funciones nativas. Este valor se puede modificar en el archivo
}\foreignlanguage{spanish}{\textit{berry.h}}\foreignlanguage{spanish}{. Su valor por defecto suele ser 10, que debería
ser suficiente en la mayoría de los casos. Si realmente necesita expandir la pila, puede llamar a la función FFI
}\textstyleSourceText{\foreignlanguage{spanish}{be\_stack\_require}}\foreignlanguage{spanish}{. El prototipo de esta
función es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
void be\_stack\_require(bvm *vm, int count);}


\bigskip

\foreignlanguage{spanish}{El parámetro }\textstyleSourceText{\foreignlanguage{spanish}{count}}\foreignlanguage{spanish}{
es la cantidad de espacio necesario. Cuando el espacio restante en la pila virtual sea insuficiente, la capacidad de la
pila se expandirá; de lo contrario, esta función no hará nada.}

\foreignlanguage{spanish}{\textbf{Advertencia}}\foreignlanguage{spanish}{: si se produce un desbordamiento de la pila, o
si se utiliza un índice no válido para acceder a la pila, el programa fallará. Puede activar el interruptor de
depuración }\textstyleSourceText{\foreignlanguage{spanish}{BE\_DEBUG}}\foreignlanguage{spanish}{ (sección
[sección::BE\_DEBUG] ), que activará la función de aserción, y puede obtener información de depuración en tiempo de
ejecución para detectar errores como desbordamiento de pila o índice no válido.}

\paragraph[Obtener valor de la pila]{\selectlanguage{spanish} Obtener valor de la pila}
\hypertarget{RefHeadingToc359833639824055}{}{\selectlanguage{spanish}
Hay un conjunto de funciones en FFI para obtener valores de la pila virtual. Estas funciones generalmente convierten los
valores en la pila en valores simples compatibles con el lenguaje C y luego regresan. Los siguientes son FFI de uso
común para obtener valores de la pila:}


\bigskip

{\selectlanguage{spanish}\ttfamily
bint be\_toint(bvm *vm, int index);}

{\selectlanguage{spanish}\ttfamily
breal be\_toreal(bvm *vm, int index);}

{\selectlanguage{spanish}\ttfamily
int be\_tobool(bvm *vm, int index);}

{\selectlanguage{spanish}\ttfamily
const char* be\_tostring(bvm *vm, int index);}

{\selectlanguage{spanish}\ttfamily
void* be\_tocomptr(bvm *vm, int index);}


\bigskip

\foreignlanguage{spanish}{La forma de parámetro de estas funciones es la misma, pero el valor de retorno es diferente.
Las primeras cuatro funciones son fáciles de entender. Al igual que sus nombres, la función de
}\textstyleSourceText{\foreignlanguage{spanish}{be\_toint}}\foreignlanguage{spanish}{ es convertir los valores en la
pila virtual a valores enteros de C (}\textstyleSourceText{\foreignlanguage{spanish}{bint}}\foreignlanguage{spanish}{
suele ser un alias de tipo }\textstyleSourceText{\foreignlanguage{spanish}{int}}\foreignlanguage{spanish}{) y
devolverlos. La función de la última función
}\textstyleSourceText{\foreignlanguage{spanish}{be\_tocomptr}}\foreignlanguage{spanish}{ es sacar un valor de puntero
de tipo general de la pila virtual. El significado específico de este puntero se explica por el propio programa C.}

\foreignlanguage{spanish}{Estas funciones utilizan la misma forma de interpretar los parámetros: el parámetro
}\textstyleSourceText{\foreignlanguage{spanish}{vm}}\foreignlanguage{spanish}{ es el puntero de la instancia de la
máquina virtual; }\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ es el índice del
elemento a recuperar, que puede ser un índice relativo o un índice absoluto. No puede usar FFI para eliminar los tipos
de datos complejos de Berry de la pila virtual, por lo que no puede eliminar un tipo de
{\textquotedbl}map{\textquotedbl} o un tipo de {\textquotedbl}class{\textquotedbl} de la pila. Uno de los beneficios de
este diseño es que no es necesario considerar la recolección de elementos no utilizados en las funciones nativas.}

\subsubsection[9.1.4 Función nativa]{\selectlanguage{spanish} 9.1.4 Función nativa}
\hypertarget{RefHeadingToc359853639824055}{}{\selectlanguage{spanish}
Una \textbf{Función nativa} está implementada por lenguaje C y puede ser llamada por código Berry. La función nativa
puede ser una función ordinaria. En este caso, llamar a la función nativa no generará ningún espacio asignado
dinámicamente, al igual que una llamada de función C normal. Las funciones nativas también pueden ser cierres, y se
debe asignar espacio para variables libres al crear cierres nativos. En circunstancias normales, las funciones nativas
simples son suficientes para satisfacer las necesidades. Ahorran más recursos que los cierres nativos y son más fáciles
de usar.}

\paragraph[Definir una función nativa]{\selectlanguage{spanish} Definir una función nativa}
\hypertarget{RefHeadingToc359873639824055}{}{\selectlanguage{spanish}
La función nativa en sí es una función C, pero todas tienen una forma específica. La definición de la función nativa
es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
int a\_native\_function(bvm *vm)}

{\selectlanguage{spanish}\ttfamily
\{}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ // hacer algo ...}

{\selectlanguage{spanish}\ttfamily
\}}


\bigskip

\foreignlanguage{spanish}{La función nativa debe ser una función C cuyo parámetro sea un puntero a
}\textstyleSourceText{\foreignlanguage{spanish}{bvm}}\foreignlanguage{spanish}{ y el valor de retorno sea
}\textstyleSourceText{\foreignlanguage{spanish}{int}}\foreignlanguage{spanish}{. Las funciones de Berry deben devolver
un valor y las funciones nativas no son una excepción. A diferencia del valor de retorno del lenguaje C, el valor de
retorno de la función nativa no es el valor transportado por la instrucción C
}\textstyleSourceText{\foreignlanguage{spanish}{return}}\foreignlanguage{spanish}{. Puede usar estos FFI para devolver
el valor de la función nativa, y también hacen que la función C devuelva:}


\bigskip

{\selectlanguage{spanish}\ttfamily
be\_return(bvm *vm);}

{\selectlanguage{spanish}\ttfamily
be\_return\_nil(bvm *vm);}


\bigskip

\foreignlanguage{spanish}{Estos FFI son en realidad dos macros, y no es necesario usar la instrucción C
}\textstyleSourceText{\foreignlanguage{spanish}{return}}\foreignlanguage{spanish}{ al usarlos.
}\textstyleSourceText{\foreignlanguage{spanish}{be\_return}}\foreignlanguage{spanish}{ pondrá la parte superior de la
pila virtual}

\paragraph[Usar una función nativa]{\selectlanguage{spanish} Usar una función nativa}
\hypertarget{RefHeadingToc359893639824055}{}{\selectlanguage{spanish}
Después de definir la función nativa, debe agregarse al intérprete de alguna manera antes de que pueda llamarse en
código Berry. Una de las formas más sencillas es agregar funciones nativas a la tabla de objetos integrada de Berry. El
proceso de configuración de objetos nativos como objetos incorporados de Berry se denomina \textbf{registración}. El
FFI de la función nativa registrada es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
void be\_regfunc(bvm *vm, const char *nombre, bntvfunc f);}


\bigskip

\textstyleSourceText{\foreignlanguage{spanish}{vm}}\foreignlanguage{spanish}{ es la instancia actual de la máquina
virtual, }\textstyleSourceText{\foreignlanguage{spanish}{nombre}}\foreignlanguage{spanish}{ es el nombre de la función
nativa y }\textstyleSourceText{\foreignlanguage{spanish}{f}}\foreignlanguage{spanish}{ es el puntero de la función
nativa. El comportamiento específico de esta función está relacionado con el valor de la macro
}\textstyleSourceText{\foreignlanguage{spanish}{BE\_USE\_PRECOMPILED\_OBJECT}}\foreignlanguage{spanish}{ (aunque el FFI
todavía está disponible cuando se utiliza la técnica de construcción en tiempo de compilación, no puede registrar
dinámicamente las variables integradas. En este caso, consulte el método de registro de los objetos integrados. 1.3 ).
La definición del tipo de función nativa
}\textstyleSourceText{\foreignlanguage{spanish}{bntvfunc}}\foreignlanguage{spanish}{ es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
typedef int (*bntvfunc)(bvm*);}


\bigskip

\foreignlanguage{spanish}{De hecho, el tipo
}\textstyleSourceText{\foreignlanguage{spanish}{bntvfunc}}\foreignlanguage{spanish}{ es el tipo de puntero de función
con el parámetro }\textstyleSourceText{\foreignlanguage{spanish}{bvm}}\foreignlanguage{spanish}{ y el tipo de valor
devuelto }\textstyleSourceText{\foreignlanguage{spanish}{int}}\foreignlanguage{spanish}{. La función
}\textstyleSourceText{\foreignlanguage{spanish}{be\_regfunc}}\foreignlanguage{spanish}{ debe llamarse antes de analizar
el código fuente de Berry.}

\foreignlanguage{spanish}{También puede insertar la función nativa en la pila virtual y luego usar una función FFI
}\textstyleSourceText{\foreignlanguage{spanish}{be\_call}}\foreignlanguage{spanish}{ para llamarla. Un uso más común es
usar el objeto de función nativa en la pila virtual como valor de retorno.}

\paragraph[Ejemplo completo]{\selectlanguage{spanish} Ejemplo completo}
\hypertarget{RefHeadingToc359913639824055}{}\foreignlanguage{spanish}{Finalizamos esta sección con un ejemplo sencillo.
Aquí, vamos a implementar una función }\textstyleSourceText{\foreignlanguage{spanish}{add}}\foreignlanguage{spanish}{
que suma dos números y devuelve el resultado del cálculo. Primero, definimos una función nativa para implementar esta
función:}


\bigskip

{\selectlanguage{spanish}\ttfamily
static int l\_add(bvm *vm)}

{\selectlanguage{spanish}\ttfamily
\{}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ int top = be\_top(vm); // Obtener el número de argumentos}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ /* Verificar el número y tipo de argumentos */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ if (top == 2 \&\& be\_isnumber(vm, 1) \&\& be\_isnumber(vm, 2)) \{}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ breal x = be\_toreal(vm, 1); // Obtener el primer argumento}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ breal y = be\_toreal(vm, 2); // Obtener el segundo argumento}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ be\_pushreal(vm, x + y); // Empuje el resultado a la pila}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ be\_return(vm); // Devuelve el valor en la parte superior de la pila}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \}}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ be\_return\_nil(vm); // Devuelve nil cuando algo sale mal}

{\selectlanguage{spanish}\ttfamily
\}}


\bigskip

\foreignlanguage{spanish}{Por lo general, las funciones nativas no necesitan usarse fuera del archivo C, por lo que
generalmente se declaran como tipos
}\textstyleSourceText{\foreignlanguage{spanish}{estáticos}}\foreignlanguage{spanish}{. Utilice la función
}\textstyleSourceText{\foreignlanguage{spanish}{be\_top}}\foreignlanguage{spanish}{ para obtener el
}\foreignlanguage{spanish}{índice absoluto de la parte superior de la pila virtual (valor
}\textstyleSourceText{\foreignlanguage{spanish}{top}}\foreignlanguage{spanish}{), que es la capacidad de la pila.
Podemos llamar a }\textstyleSourceText{\foreignlanguage{spanish}{be\_top}}\foreignlanguage{spanish}{ antes de que la
función nativa realice la operación de pila virtual, en este momento la capacidad de la pila virtual es igual a la
cantidad de parámetros reales. Para la función
}\textstyleSourceText{\foreignlanguage{spanish}{add}}\foreignlanguage{spanish}{, necesitamos dos parámetros para
participar en la operación, así que verifica si el número de parámetros es 2 en la cuarta línea
(}\textstyleSourceText{\foreignlanguage{spanish}{top == 2}}\foreignlanguage{spanish}{). Y necesitamos verificar si los
dos parámetros son de tipo numérico, por lo que debemos llamar a la función
}\textstyleSourceText{\foreignlanguage{spanish}{be\_isnumber}}\foreignlanguage{spanish}{ para verificar. Si todo es
correcto, los parámetros se sacarán de la pila virtual, luego el resultado del cálculo se colocará en la pila y
finalmente se devolverá usando }\textstyleSourceText{\foreignlanguage{spanish}{be\_return}}\foreignlanguage{spanish}{.
Si la verificación del parámetro falla, se llamará a
}\textstyleSourceText{\foreignlanguage{spanish}{be\_return\_nil}}\foreignlanguage{spanish}{ para devolver el valor de
}\textstyleSourceText{\foreignlanguage{spanish}{nil}}\foreignlanguage{spanish}{.}

{\selectlanguage{spanish}
A continuación, registre esta función nativa en la tabla de objetos integrada. Para simplificar, lo registramos después
de cargar la biblioteca:}


\bigskip

{\selectlanguage{spanish}\ttfamily
bvm *vm = be\_vm\_new(); // Construir una VM}

{\selectlanguage{spanish}\ttfamily
be\_regfunc(vm, {\textquotedbl}myadd{\textquotedbl}, l\_add); // Registrar la función nativa
{\textquotedbl}myadd{\textquotedbl}}


\bigskip

\foreignlanguage{spanish}{La segunda línea es donde se registra la función nativa y la llamamos
}\textstyleSourceText{\foreignlanguage{spanish}{myadd}}\foreignlanguage{spanish}{. En este punto, la definición y el
registro de la función nativa están completos. Como verificación, puede compilar el intérprete, luego ingresar el REPL
y ejecutar algunas pruebas. Debería obtener resultados como este:}


\bigskip

{\selectlanguage{spanish}\ttfamily
{\textgreater} myadd}

{\selectlanguage{spanish}\ttfamily
{\textless}function: 0x562a210f0f90{\textgreater}}

{\selectlanguage{spanish}\ttfamily
{\textgreater} myadd(1.0, 2.5)}

{\selectlanguage{spanish}\ttfamily
3.5}

{\selectlanguage{spanish}\ttfamily
{\textgreater} myadd(2.5, 2)}

{\selectlanguage{spanish}\ttfamily
4.5}

{\selectlanguage{spanish}\ttfamily
{\textgreater} myadd(1, 2)}

{\selectlanguage{spanish}\ttfamily
3}

\subsection[9.2 Tipos y Funciones]{\selectlanguage{spanish} 9.2 Tipos y Funciones}
\hypertarget{RefHeadingToc359933639824055}{}\subsubsection[9.2.1 Tipos]{\selectlanguage{spanish} 9.2.1 Tipos}
\hypertarget{RefHeadingToc359953639824055}{}{\selectlanguage{spanish}
Esta sección presentará algunos tipos que deben usarse en FFI y son generalmente utilizados por funciones FFI.
Generalmente, los tipos y declaraciones en FFI se pueden encontrar en el archivo \textit{berry.h}. A menos que se
especifique lo contrario en esta sección, la definición o declaración se proporciona en \textit{berry.h} de forma
predeterminada.}

\foreignlanguage{spanish}{El tipo }\textstyleSourceText{\foreignlanguage{spanish}{bvm}}\foreignlanguage{spanish}{ se
utiliza para almacenar la información de estado de la máquina virtual Berry. Los detalles de este tipo no son visibles
para los programas externos. Por lo tanto, esta definición solo se puede encontrar en el archivo
}\foreignlanguage{spanish}{\textit{berry.h}}\foreignlanguage{spanish}{:}

{\selectlanguage{spanish}\ttfamily
typedef struct bvm bvm;}

\foreignlanguage{spanish}{La mayoría de las funciones de FFI usan el tipo
}\textstyleSourceText{\foreignlanguage{spanish}{bvm}}\foreignlanguage{spanish}{ como primer parámetro, porque todas
operan en la máquina virtual internamente. Ocultar la implementación interna de
}\textstyleSourceText{\foreignlanguage{spanish}{bvm}}\foreignlanguage{spanish}{ ayuda a reducir el acoplamiento entre
el estándar FFI y la VM. Fuera del intérprete, normalmente solo se utilizan punteros
}\textstyleSourceText{\foreignlanguage{spanish}{bvm}}\foreignlanguage{spanish}{. Para crear un nuevo objeto
}\textstyleSourceText{\foreignlanguage{spanish}{bvm}}\foreignlanguage{spanish}{, use la función
}\textstyleSourceText{\foreignlanguage{spanish}{be\_vm\_new}}\foreignlanguage{spanish}{ y destruya el objeto
}\textstyleSourceText{\foreignlanguage{spanish}{bvm}}\foreignlanguage{spanish}{ usando la función
}\textstyleSourceText{\foreignlanguage{spanish}{be\_vm\_delete}}\foreignlanguage{spanish}{.}

{\selectlanguage{spanish}
La definición del tipo de función nativa es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
typedef int (*bntvfunc)(bvm*);}


\bigskip

\foreignlanguage{spanish}{Este tipo es un puntero de función nativo y algunas FFI que registran o agregan funciones
nativas a la máquina virtual usan parámetros de este tipo. Las variables o parámetros de este tipo deben inicializarse
con un nombre de función cuyo parámetro sea del tipo
}\textstyleSourceText{\foreignlanguage{spanish}{bvm}}\foreignlanguage{spanish}{ y cuyo valor de retorno sea del tipo
}\textstyleSourceText{\foreignlanguage{spanish}{int}}\foreignlanguage{spanish}{.}

{\selectlanguage{spanish}
Este tipo se usa cuando se registran funciones nativas en lotes o se construyen clases nativas. Se define como:}


\bigskip

{\selectlanguage{spanish}\ttfamily
typedef struct \{}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ const char *nombre; // El nombre de la función u objeto}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ bntvfunc funcion; // El puntero de función}

{\selectlanguage{spanish}\ttfamily
\} bnfuncinfo;}


\bigskip

\foreignlanguage{spanish}{El miembro }\textstyleSourceText{\foreignlanguage{spanish}{nombre}}\foreignlanguage{spanish}{
de }\textstyleSourceText{\foreignlanguage{spanish}{bnfuncinfo}}\foreignlanguage{spanish}{ representa el nombre de una
función u objeto, y el miembro }\textstyleSourceText{\foreignlanguage{spanish}{funcion}}\foreignlanguage{spanish}{ es
un puntero de función nativo.}

\foreignlanguage{spanish}{Este tipo es un tipo entero integrado de Berry. Se define en el documento
}\foreignlanguage{spanish}{\textit{berry.h}}\foreignlanguage{spanish}{. Por defecto,
}\textstyleSourceText{\foreignlanguage{spanish}{bint}}\foreignlanguage{spanish}{ se implementa usando el tipo
}\textstyleSourceText{\foreignlanguage{spanish}{long long}}\foreignlanguage{spanish}{, y la implementación de
}\textstyleSourceText{\foreignlanguage{spanish}{bint}}\foreignlanguage{spanish}{ se puede modificar cambiando el
archivo de configuración.}

\foreignlanguage{spanish}{Este es el tipo de número real incorporado de Berry, que en realidad es el tipo de punto
flotante en lenguaje C. }\textstyleSourceText{\foreignlanguage{spanish}{breal}}\foreignlanguage{spanish}{ se define
como:}


\bigskip

{\selectlanguage{spanish}\ttfamily
\#if BE\_SINGLE\_FLOAT != 0}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ typedef float breal;}

{\selectlanguage{spanish}\ttfamily
\#else}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ typedef double breal;}

{\selectlanguage{spanish}\ttfamily
\#endif}


\bigskip

\foreignlanguage{spanish}{Puede usar la macro
}\textstyleSourceText{\foreignlanguage{spanish}{BE\_SINGLE\_FLOAT}}\foreignlanguage{spanish}{ para controlar la
implementación específica de }\textstyleSourceText{\foreignlanguage{spanish}{breal}}\foreignlanguage{spanish}{: cuando
el valor de }\textstyleSourceText{\foreignlanguage{spanish}{BE\_SINGLE\_FLOAT}}\foreignlanguage{spanish}{ es
}\textstyleSourceText{\foreignlanguage{spanish}{0}}\foreignlanguage{spanish}{, se usará la implementación de tipo
}\textstyleSourceText{\foreignlanguage{spanish}{doble}}\foreignlanguage{spanish}{
}\textstyleSourceText{\foreignlanguage{spanish}{breal}}\foreignlanguage{spanish}{, de lo contrario, la implementación
de tipo }\textstyleSourceText{\foreignlanguage{spanish}{float}}\foreignlanguage{spanish}{ se utilizará para
}\textstyleSourceText{\foreignlanguage{spanish}{breal}}\foreignlanguage{spanish}{.}

{\selectlanguage{spanish}
[sección::código de error]}

{\selectlanguage{spanish}
Este tipo de enumeración se utiliza en algunos valores de retorno de FFI. La definición de este tipo es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
enum berrorcode \{}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ BE\_OK = 0,}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ BE\_IO\_ERROR,}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ BE\_SYNTAX\_ERROR,}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ BE\_EXEC\_ERROR,}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ BE\_MALLOC\_FAIL,}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ BE\_EXIT}

{\selectlanguage{spanish}\ttfamily
\};}


\bigskip

{\selectlanguage{spanish}
El significado de estos valores de enumeración son:}

\liststyleLxvii
\begin{itemize}
\item \textstyleSourceText{\foreignlanguage{spanish}{BE\_OK}}\foreignlanguage{spanish}{: No hay ningún error, la función
se ejecuta con éxito.}
\item \textstyleSourceText{\foreignlanguage{spanish}{BE\_IO\_ERROR}}\foreignlanguage{spanish}{: Ocurrió un error de
lectura de archivo cuando el intérprete estaba leyendo el archivo fuente. El error generalmente es causado por el
ausencia del expediente.}
\item \textstyleSourceText{\foreignlanguage{spanish}{BE\_SYNTAX\_ERROR}}\foreignlanguage{spanish}{: Ocurrió un error de
sintaxis cuando el intérprete estaba compilando el código fuente. Después de que ocurre este error, el intérprete no
generará bytecode, por lo que no puede continuar ejecutándose el código de bytes.}
\item \textstyleSourceText{\foreignlanguage{spanish}{BE\_EXEC\_ERROR}}\foreignlanguage{spanish}{: Error de tiempo de
ejecución. Cuando se produce este error, la ejecución de El código Berry se detiene y el entorno se restaura al máximo
punto de recuperación reciente.}
\item \textstyleSourceText{\foreignlanguage{spanish}{BE\_MALLOC\_FAIL}}\foreignlanguage{spanish}{: Falló la asignación
de memoria. Este error es causado por espacio de pila insuficiente.}
\item \textstyleSourceText{\foreignlanguage{spanish}{BE\_EXIT}}\foreignlanguage{spanish}{: Indica que el programa sale y
el valor no es un error. Ejecutar la función
}\textstyleSourceText{\foreignlanguage{spanish}{exit}}\foreignlanguage{spanish}{ de Berry hace que el intérprete
devuelva este valor.}
\end{itemize}
\foreignlanguage{spanish}{Cabe señalar que cuando se produce un error
}\textstyleSourceText{\foreignlanguage{spanish}{BE\_MALLOC\_FAIL}}\foreignlanguage{spanish}{, ya no se puede realizar
la asignación de memoria dinámica, lo que significa que ya no se pueden asignar objetos de cadena, por lo que la
función que devuelve este error generalmente no brinda información más detallada sobre el error.}

\subsubsection[9.2.2 Funciones y Macros]{\selectlanguage{spanish} 9.2.2 Funciones y Macros}
\hypertarget{RefHeadingToc359973639824055}{}{\selectlanguage{spanish}
Esta función se utiliza para crear una nueva instancia de máquina virtual. El prototipo de función es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
bvm* be\_vm\_new(void);}


\bigskip

\foreignlanguage{spanish}{El valor de retorno de la función es un puntero a la instancia de la máquina virtual.
}\textstyleSourceText{\foreignlanguage{spanish}{be\_vm\_new}}\foreignlanguage{spanish}{ es la primera función llamada
cuando se crea el intérprete de Berry. Esta función hará mucho trabajo: solicitar memoria para la máquina virtual,
inicializar el estado y los atributos de la máquina virtual, inicializar el GC (recolector de basura), la biblioteca
estándar se carga en la instancia de la máquina virtual, etc.}

\foreignlanguage{spanish}{La función
}\textstyleSourceText{\foreignlanguage{spanish}{be\_vm\_delete}}\foreignlanguage{spanish}{ se usa para destruir una
instancia de máquina virtual. El prototipo de la función es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
void be\_vm\_delete(bvm *vm);}


\bigskip

\foreignlanguage{spanish}{El parámetro }\textstyleSourceText{\foreignlanguage{spanish}{vm}}\foreignlanguage{spanish}{ es
el puntero del objeto de la máquina virtual que se va a destruir. La destrucción de la máquina virtual liberará todos
los objetos de la máquina virtual, incluidos los valores de la pila y los objetos administrados por el GC. El puntero
de la máquina virtual después de la destrucción será un valor no válido y ya no se podrá hacer referencia a él.}

{\selectlanguage{spanish}
Esta función se utiliza para cargar un fragmento de código fuente del búfer y compilarlo en un código de bytes. El
prototipo de la función es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
int be\_loadbuffer(bvm *vm, const char *name, const char *buffer, size\_t length);}


\bigskip

\foreignlanguage{spanish}{El parámetro }\textstyleSourceText{\foreignlanguage{spanish}{vm}}\foreignlanguage{spanish}{ es
el puntero de la máquina virtual. }\textstyleSourceText{\foreignlanguage{spanish}{name}}\foreignlanguage{spanish}{ es
una cadena, que generalmente se usa para marcar la fuente del código fuente. Por ejemplo, la entrada del código fuente
del dispositivo de entrada estándar puede pasar la cadena
}\textstyleSourceText{\foreignlanguage{spanish}{{\textquotedbl}stdin{\textquotedbl}}}\foreignlanguage{spanish}{ a este
parámetro, y la entrada del código fuente del archivo puede ser el nombre del archivo y se pasa a este parámetro. El
parámetro }\textstyleSourceText{\foreignlanguage{spanish}{buffer}}\foreignlanguage{spanish}{ es el búfer para almacenar
el código fuente. La organización de este búfer es muy similar a la cadena de C. Es una secuencia continua de
caracteres, pero el búfer al que apunta
}\textstyleSourceText{\foreignlanguage{spanish}{buffer}}\foreignlanguage{spanish}{ no requiere caracteres
}\textstyleSourceText{\foreignlanguage{spanish}{{}'{\textbackslash}0'}}\foreignlanguage{spanish}{ como terminador. El
parámetro }\textstyleSourceText{\foreignlanguage{spanish}{longitud}}\foreignlanguage{spanish}{ indica la longitud del
búfer. Esta longitud se refiere al número de bytes de texto de código fuente en el búfer.}

\foreignlanguage{spanish}{Para dar un ejemplo simple, si queremos usar la función
}\textstyleSourceText{\foreignlanguage{spanish}{be\_loadbuffer}}\foreignlanguage{spanish}{ para compilar una cadena, el
uso general es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
const char *str = {\textquotedbl}print('Hola Berry'){\textquotedbl};}

{\selectlanguage{spanish}\ttfamily
be\_loadbuffer(vm, {\textquotedbl}cadena{\textquotedbl}, str, strlen(str));}


\bigskip

\foreignlanguage{spanish}{Aquí usamos la cadena
}\textstyleSourceText{\foreignlanguage{spanish}{{\textquotedbl}cadena{\textquotedbl}}}\foreignlanguage{spanish}{ para
representar el código fuente, también puede modificarla a cualquier valor. Tenga en cuenta que la función
}\textstyleSourceText{\foreignlanguage{spanish}{strlen}}\foreignlanguage{spanish}{ de la función de biblioteca estándar
de C se usa aquí para obtener la longitud del búfer de cadena (en realidad, el número de bytes en la cadena).}

\foreignlanguage{spanish}{Si la compilación es exitosa,
}\textstyleSourceText{\foreignlanguage{spanish}{be\_loadbuffer}}\foreignlanguage{spanish}{ compilará el código fuente
en una función Berry y lo colocará en la parte superior de la pila virtual. Si la compilación encuentra un error,
}\textstyleSourceText{\foreignlanguage{spanish}{be\_loadbuffer}}\foreignlanguage{spanish}{ devolverá un valor de error
de tipo }\textstyleSourceText{\foreignlanguage{spanish}{berrorcode}}\foreignlanguage{spanish}{ [ver Sección código de
error] y, si es posible, almacenará la cadena de mensaje de error específica en la parte superior de la pila virtual.}

\textstyleSourceText{\foreignlanguage{spanish}{be\_loadstring}}\foreignlanguage{spanish}{ es una macro definida como:}


\bigskip

{\selectlanguage{spanish}\ttfamily
\#define be\_loadstring(vm, str) be\_loadbuffer((vm), {\textquotedbl}string{\textquotedbl}, (str), strlen(str))}


\bigskip

\foreignlanguage{spanish}{Esta macro es solo un contenedor simple para la función
}\textstyleSourceText{\foreignlanguage{spanish}{be\_loadbuffer}}\foreignlanguage{spanish}{. El parámetro
}\textstyleSourceText{\foreignlanguage{spanish}{vm}}\foreignlanguage{spanish}{ es un puntero a la instancia de la
máquina virtual, y el parámetro }\textstyleSourceText{\foreignlanguage{spanish}{str}}\foreignlanguage{spanish}{ es un
puntero a la cadena de código fuente. Es muy conveniente usar
}\textstyleSourceText{\foreignlanguage{spanish}{be\_loadstring}}\foreignlanguage{spanish}{ para compilar cadenas, por
ejemplo:}


\bigskip

{\selectlanguage{spanish}\ttfamily
be\_loadstring(vm, {\textquotedbl}print('Hola Berry'){\textquotedbl});}


\bigskip

\foreignlanguage{spanish}{Esta forma de escribir es más concisa que usar
}\textstyleSourceText{\foreignlanguage{spanish}{be\_loadbuffer}}\foreignlanguage{spanish}{, pero debe asegurarse de que
la cadena termine con un carácter
}\textstyleSourceText{\foreignlanguage{spanish}{{}'{\textbackslash}0'}}\foreignlanguage{spanish}{.}

{\selectlanguage{spanish}
Esta función se utiliza para compilar un archivo de código fuente. El prototipo de función es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
int be\_loadfile(bvm *vm, const char *nombre);}


\bigskip

\foreignlanguage{spanish}{La funcionalidad de esta función es similar a la función
}\textstyleSourceText{\foreignlanguage{spanish}{be\_loadbuffer}}\foreignlanguage{spanish}{, excepto que la función se
compilará leyendo el archivo de código fuente. El parámetro
}\textstyleSourceText{\foreignlanguage{spanish}{vm}}\foreignlanguage{spanish}{ es el puntero de la instancia de la
máquina virtual y el parámetro }\textstyleSourceText{\foreignlanguage{spanish}{nombre}}\foreignlanguage{spanish}{ es el
nombre del archivo de origen. Esta función llamará a la interfaz de archivo y, de forma predeterminada, utilizará
funciones como }\textstyleSourceText{\foreignlanguage{spanish}{fopen}}\foreignlanguage{spanish}{ en la biblioteca
estándar de C para manipular archivos.}

\foreignlanguage{spanish}{Si usa la interfaz de archivo de la biblioteca estándar de C, puede usar nombres de archivo de
ruta relativa o ruta absoluta. Si el archivo no existe,
}\textstyleSourceText{\foreignlanguage{spanish}{be\_loadfile}}\foreignlanguage{spanish}{ devolverá un error
}\textstyleSourceText{\foreignlanguage{spanish}{BE\_IO\_ERROR}}\foreignlanguage{spanish}{ (Ve Seccion de código de
error) y colocará el mensaje de error en la parte superior de la pila. Otros mensajes de error son los mismos que los
de la función }\textstyleSourceText{\foreignlanguage{spanish}{be\_loadbuffer}}\foreignlanguage{spanish}{. Se recomienda
usar la función }\textstyleSourceText{\foreignlanguage{spanish}{be\_loadfile}}\foreignlanguage{spanish}{ para compilar
el archivo fuente, en lugar de leer todos los archivos fuente en un búfer, y luego llamar a la función
}\textstyleSourceText{\foreignlanguage{spanish}{be\_loadbuffer}}\foreignlanguage{spanish}{ para compilar el código
fuente. El primero leerá el archivo fuente en segmentos y solo creará un pequeño búfer de lectura en la memoria,
ahorrando así más memoria.}

\foreignlanguage{spanish}{La función }\textstyleSourceText{\foreignlanguage{spanish}{be\_top}}\foreignlanguage{spanish}{
devuelve el valor de índice absoluto del elemento superior en la pila virtual. Este valor es también el número de
elementos en la pila virtual (la capacidad de la pila virtual). Llame a esta función antes de agregar o quitar
elementos en la pila virtual para obtener la cantidad de parámetros de la función nativa. El prototipo de esta función
es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
int be\_top(bvm *vm);}


\bigskip

\foreignlanguage{spanish}{Esta función se suele utilizar para obtener el número de parámetros de una función nativa.
Cuando se usa para este propósito, se recomienda llamar a
}\textstyleSourceText{\foreignlanguage{spanish}{be\_top}}\foreignlanguage{spanish}{ en la parte superior del cuerpo de
la función nativa. P.ej:}


\bigskip

{\selectlanguage{spanish}\ttfamily
static int native\_function\_example(bvm *vm)}

{\selectlanguage{spanish}\ttfamily
\{}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ int argc = be\_top(vm); // Obtener el número de argumentos}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ // ...}

{\selectlanguage{spanish}\ttfamily
\}}


\bigskip

\foreignlanguage{spanish}{La función
}\textstyleSourceText{\foreignlanguage{spanish}{be\_typename}}\foreignlanguage{spanish}{ convierte el tipo del objeto
Berry en una cadena y lo devuelve. Por ejemplo, devuelve
}\textstyleSourceText{\foreignlanguage{spanish}{{\textquotedbl}int{\textquotedbl}}}\foreignlanguage{spanish}{ para un
objeto entero y
}\textstyleSourceText{\foreignlanguage{spanish}{{\textquotedbl}function{\textquotedbl}}}\foreignlanguage{spanish}{ para
un objeto función. El prototipo de esta función es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
const char* be\_typename(bvm *vm, int index);}


\bigskip

\foreignlanguage{spanish}{El parámetro }\textstyleSourceText{\foreignlanguage{spanish}{vm}}\foreignlanguage{spanish}{ es
el puntero de la instancia de la máquina virtual, e
}\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ es el índice del objeto a operar. La
función }\textstyleSourceText{\foreignlanguage{spanish}{type}}\foreignlanguage{spanish}{ en la biblioteca estándar de
Berry se implementa llamando a
}\textstyleSourceText{\foreignlanguage{spanish}{be\_typename}}\foreignlanguage{spanish}{. Consulte la sección
}\textstyleSourceText{\foreignlanguage{spanish}{baselib\_type}}\foreignlanguage{spanish}{ para conocer la cadena de
retorno correspondiente al tipo de parámetro.}

\foreignlanguage{spanish}{La función
}\textstyleSourceText{\foreignlanguage{spanish}{be\_classname}}\foreignlanguage{spanish}{ se utiliza para obtener el
nombre de clase de un objeto o clase. El prototipo de función es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
const char* be\_classname(bvm *vm, int index);}


\bigskip

\foreignlanguage{spanish}{El parámetro }\textstyleSourceText{\foreignlanguage{spanish}{vm}}\foreignlanguage{spanish}{ es
el puntero de la instancia de la máquina virtual, e
}\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ es el índice del objeto a operar. Si
el valor en }\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ es una instancia, la
función }\textstyleSourceText{\foreignlanguage{spanish}{be\_classname}}\foreignlanguage{spanish}{ devolverá la cadena
del nombre de la clase a la que pertenece la instancia, y si el valor en
}\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ es una clase, devolverá directamente
la cadena del nombre de la clase. En otros casos
}\textstyleSourceText{\foreignlanguage{spanish}{be\_classname}}\foreignlanguage{spanish}{ devolverá
}\textstyleSourceText{\foreignlanguage{spanish}{NULL}}\foreignlanguage{spanish}{.}

\foreignlanguage{spanish}{La función
}\textstyleSourceText{\foreignlanguage{spanish}{be\_strlen}}\foreignlanguage{spanish}{ devuelve la longitud de la
cadena Berry especificada. El prototipo de función es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
int be\_strlen(bvm *vm, int index);}


\bigskip

\foreignlanguage{spanish}{El parámetro }\textstyleSourceText{\foreignlanguage{spanish}{vm}}\foreignlanguage{spanish}{ es
el puntero de la instancia de la máquina virtual, e
}\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ es el índice del objeto a operar.
Esta función devuelve el número de bytes en la cadena en
}\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ (los caracteres
}\textstyleSourceText{\foreignlanguage{spanish}{{}'{\textbackslash}0'}}\foreignlanguage{spanish}{ al final de la cadena
Berry no se cuentan). Si el valor de la posición
}\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ no es una cadena, la función
}\textstyleSourceText{\foreignlanguage{spanish}{be\_strlen}}\foreignlanguage{spanish}{ devolverá
}\textstyleSourceText{\foreignlanguage{spanish}{0}}\foreignlanguage{spanish}{.}

\foreignlanguage{spanish}{Aunque la cadena
}\textstyleSourceText{\foreignlanguage{spanish}{Berry}}\foreignlanguage{spanish}{ es compatible con el formato de
cadena C, no se recomienda utilizar la función
}\textstyleSourceText{\foreignlanguage{spanish}{strlen}}\foreignlanguage{spanish}{ de la biblioteca estándar de C para
medir la longitud de la cadena Berry. Para cadenas Berry,
}\textstyleSourceText{\foreignlanguage{spanish}{be\_strlen}}\foreignlanguage{spanish}{ es más rápido que
}\textstyleSourceText{\foreignlanguage{spanish}{strlen}}\foreignlanguage{spanish}{ y tiene mejor compatibilidad.}

\foreignlanguage{spanish}{La función
}\textstyleSourceText{\foreignlanguage{spanish}{be\_strconcat}}\foreignlanguage{spanish}{ se utiliza para empalmar dos
cadenas Berry. El prototipo de función es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
void be\_strconcat(bvm *vm, int index);}


\bigskip

\foreignlanguage{spanish}{El parámetro }\textstyleSourceText{\foreignlanguage{spanish}{vm}}\foreignlanguage{spanish}{ es
el puntero de la instancia de la máquina virtual. Esta función concatenará la cadena en la posición del parámetro de
}\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ con la cadena en la posición superior
de la pila, y luego colocará la cadena resultante en la posición indexada por
}\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{.}

\foreignlanguage{spanish}{La función }\textstyleSourceText{\foreignlanguage{spanish}{be\_pop}}\foreignlanguage{spanish}{
extrae el valor en la parte superior de la pila. El prototipo de función es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
void be\_pop(bvm *vm, int n);}


\bigskip

\foreignlanguage{spanish}{El parámetro }\textstyleSourceText{\foreignlanguage{spanish}{vm}}\foreignlanguage{spanish}{ es
el puntero de la instancia de la máquina virtual, y el parámetro
}\textstyleSourceText{\foreignlanguage{spanish}{n}}\foreignlanguage{spanish}{ es la cantidad de valores que se
extraerán de la pila. Tenga en cuenta que el valor de
}\textstyleSourceText{\foreignlanguage{spanish}{n}}\foreignlanguage{spanish}{ no puede exceder la capacidad de la
pila.}

\foreignlanguage{spanish}{La función
}\textstyleSourceText{\foreignlanguage{spanish}{be\_remove}}\foreignlanguage{spanish}{ elimina un valor de la pila.
Esta función eliminará un valor de la pila.}


\bigskip

{\selectlanguage{spanish}\ttfamily
void be\_remove(bvm *vm, int index);}


\bigskip

\foreignlanguage{spanish}{El parámetro }\textstyleSourceText{\foreignlanguage{spanish}{vm}}\foreignlanguage{spanish}{ es
el puntero de la instancia de la máquina virtual y el parámetro
}\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ es el índice del objeto que se
eliminará. Después de que el valor en }\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{
se mueva, los siguientes valores se completarán y la capacidad de la pila se reducirá en uno. El valor de
}\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ no puede exceder la capacidad de la
pila.}

\foreignlanguage{spanish}{La función
}\textstyleSourceText{\foreignlanguage{spanish}{be\_absindex}}\foreignlanguage{spanish}{ devuelve el valor de índice
absoluto de un valor de índice dado, y }\foreignlanguage{spanish}{su prototipo de función es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
int be\_absindex(bvm *vm, int index);}


\bigskip

\foreignlanguage{spanish}{El parámetro }\textstyleSourceText{\foreignlanguage{spanish}{vm}}\foreignlanguage{spanish}{ es
el puntero de la instancia de la máquina virtual y el parámetro
}\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ es el valor del índice de entrada. Si
}\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ es positivo, el valor de retorno de
}\textstyleSourceText{\foreignlanguage{spanish}{be\_absindex}}\foreignlanguage{spanish}{ es el valor de
}\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{. Si
}\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ es negativo, el valor de retorno de
be\_absindex es el valor de índice absoluto correspondiente a
}\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{. Cuando
}\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ es un valor negativo (índice
relativo), su posición de índice no puede ser inferior a la parte inferior de la pila.}

\foreignlanguage{spanish}{La función
}\textstyleSourceText{\foreignlanguage{spanish}{be\_newlist}}\foreignlanguage{spanish}{ crea un nuevo valor de
}\textstyleSourceText{\foreignlanguage{spanish}{list}}\foreignlanguage{spanish}{, y su prototipo de función es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
void be\_newlist(bvm *vm);}


\bigskip

\foreignlanguage{spanish}{El parámetro }\textstyleSourceText{\foreignlanguage{spanish}{vm}}\foreignlanguage{spanish}{ es
el puntero de la instancia de la máquina virtual. Después de llamar con éxito a esta función, el nuevo valor de
}\textstyleSourceText{\foreignlanguage{spanish}{list}}\foreignlanguage{spanish}{ se colocará en la parte superior de la
pila. El valor }\textstyleSourceText{\foreignlanguage{spanish}{list}}\foreignlanguage{spanish}{ es una representación
interna de una lista, que no debe confundirse con una instancia de la clase
}\textstyleSourceText{\foreignlanguage{spanish}{list}}\foreignlanguage{spanish}{.}

\foreignlanguage{spanish}{La función
}\textstyleSourceText{\foreignlanguage{spanish}{be\_newmap}}\foreignlanguage{spanish}{ crea un nuevo valor
}\textstyleSourceText{\foreignlanguage{spanish}{map}}\foreignlanguage{spanish}{, y su prototipo de función es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
void be\_newmap(bvm *vm);}


\bigskip

\foreignlanguage{spanish}{El parámetro }\textstyleSourceText{\foreignlanguage{spanish}{vm}}\foreignlanguage{spanish}{ es
el puntero de la instancia de la máquina virtual. Después de llamar con éxito a esta función, el nuevo valor del
}\textstyleSourceText{\foreignlanguage{spanish}{map}}\foreignlanguage{spanish}{ se colocará en la parte superior de la
pila. El valor }\textstyleSourceText{\foreignlanguage{spanish}{map}}\foreignlanguage{spanish}{ es una representación
interna de una lista, que no debe confundirse con una instancia de la clase
}\textstyleSourceText{\foreignlanguage{spanish}{map}}\foreignlanguage{spanish}{.}

\foreignlanguage{spanish}{La función
}\textstyleSourceText{\foreignlanguage{spanish}{be\_getglobal}}\foreignlanguage{spanish}{ empuja la variable global con
el nombre especificado a la pila. Su prototipo de función es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
void be\_getglobal(bvm *vm, const char *name);}


\bigskip

\foreignlanguage{spanish}{El parámetro }\textstyleSourceText{\foreignlanguage{spanish}{vm}}\foreignlanguage{spanish}{ es
el puntero de la instancia de la máquina virtual y el parámetro
}\textstyleSourceText{\foreignlanguage{spanish}{name}}\foreignlanguage{spanish}{ es el nombre de la variable global.
Después de llamar a esta función, la variable global llamada
}\textstyleSourceText{\foreignlanguage{spanish}{name}}\foreignlanguage{spanish}{ se colocará en la parte superior de la
pila virtual.}

\foreignlanguage{spanish}{La función
}\textstyleSourceText{\foreignlanguage{spanish}{be\_setmember}}\foreignlanguage{spanish}{ se utiliza para establecer el
valor de la variable miembro de la clase de objeto de instancia. El prototipo de función es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
void be\_setmember(bvm *vm, int index, const char *k);}


\bigskip

\foreignlanguage{spanish}{El parámetro }\textstyleSourceText{\foreignlanguage{spanish}{vm}}\foreignlanguage{spanish}{ es
el puntero de la instancia de la máquina virtual, el parámetro
}\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ es el índice del objeto de la
instancia y el parámetro }\textstyleSourceText{\foreignlanguage{spanish}{k}}\foreignlanguage{spanish}{ es el nombre del
miembro. Esta función copiará el valor en la parte superior de la pila al miembro
}\textstyleSourceText{\foreignlanguage{spanish}{k}}\foreignlanguage{spanish}{ de la instancia de posición de índice.
Tenga en cuenta que el elemento superior de la pila no aparecerá automáticamente.}

\foreignlanguage{spanish}{La función
}\textstyleSourceText{\foreignlanguage{spanish}{be\_getmember}}\foreignlanguage{spanish}{ se utiliza para obtener el
valor de la variable miembro de la clase }\foreignlanguage{spanish}{de objeto de instancia. El prototipo de función
es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
void be\_getmember(bvm *vm, int index, const char *k);}


\bigskip

\foreignlanguage{spanish}{El parámetro }\textstyleSourceText{\foreignlanguage{spanish}{vm}}\foreignlanguage{spanish}{ es
el puntero de la instancia de la máquina virtual, el parámetro
}\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ es el índice del objeto de la
instancia y el parámetro }\textstyleSourceText{\foreignlanguage{spanish}{k}}\foreignlanguage{spanish}{ es el nombre del
miembro. Esta función coloca el valor del miembro de la instancia de posición de índice
}\textstyleSourceText{\foreignlanguage{spanish}{k}}\foreignlanguage{spanish}{ en la parte superior de la pila virtual.}

\foreignlanguage{spanish}{La función
}\textstyleSourceText{\foreignlanguage{spanish}{be\_getindex}}\foreignlanguage{spanish}{ se utiliza para obtener el
valor de }\textstyleSourceText{\foreignlanguage{spanish}{list}}\foreignlanguage{spanish}{ o
}\textstyleSourceText{\foreignlanguage{spanish}{map}}\foreignlanguage{spanish}{. El prototipo de función es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
void be\_getindex(bvm *vm, int index);}


\bigskip

\foreignlanguage{spanish}{El parámetro }\textstyleSourceText{\foreignlanguage{spanish}{vm}}\foreignlanguage{spanish}{ es
el puntero de la instancia de la máquina virtual, y el parámetro
}\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ es el índice del objeto a operar.
Esta función se usa para obtener un elemento del contenedor
}\textstyleSourceText{\foreignlanguage{spanish}{map}}\foreignlanguage{spanish}{ o
}\textstyleSourceText{\foreignlanguage{spanish}{list}}\foreignlanguage{spanish}{ (valores internos, no instancias de
las clases }\textstyleSourceText{\foreignlanguage{spanish}{map}}\foreignlanguage{spanish}{ o
}\textstyleSourceText{\foreignlanguage{spanish}{list}}\foreignlanguage{spanish}{), y el índice del elemento se almacena
en la parte superior de la pila (el índice relativo es -1). Después de llamar a esta función, el valor obtenido del
contenedor se colocará en la parte superior de la pila. Si no hay ningún subíndice señalado por el contenedor, el valor
}\textstyleSourceText{\foreignlanguage{spanish}{nil}}\foreignlanguage{spanish}{ se colocará en la parte superior de la
pila. Por ejemplo, si el elemento con el índice 1 en la pila virtual es una
}\textstyleSourceText{\foreignlanguage{spanish}{list}}\foreignlanguage{spanish}{ y queremos extraer el elemento con el
índice 0, entonces podemos usar el siguiente código:}


\bigskip

{\selectlanguage{spanish}\ttfamily
be\_pushint(vm, 0); // \ Inserte el valor de índice 0 en la pila virtual}

{\selectlanguage{spanish}\ttfamily
be\_getindex(vm, 1); // \ Obtener un elemento del contenedor de lista}


\bigskip

\foreignlanguage{spanish}{Primero colocamos el valor entero
}\textstyleSourceText{\foreignlanguage{spanish}{0}}\foreignlanguage{spanish}{ en la pila, y este valor se usará como
índice para obtener el elemento del contenedor
}\textstyleSourceText{\foreignlanguage{spanish}{list}}\foreignlanguage{spanish}{. La segunda línea de código implementa
para obtener elementos del contenedor }\textstyleSourceText{\foreignlanguage{spanish}{list}}\foreignlanguage{spanish}{.
El valor de índice del contenedor }\textstyleSourceText{\foreignlanguage{spanish}{list}}\foreignlanguage{spanish}{ en
el ejemplo es 1 en la pila virtual. El elemento recuperado se almacena en la parte superior de la pila y podemos usar
el índice relativo -1 para acceder a él.}

\foreignlanguage{spanish}{La función
}\textstyleSourceText{\foreignlanguage{spanish}{be\_setindex}}\foreignlanguage{spanish}{ se utiliza para establecer un
valor en }\textstyleSourceText{\foreignlanguage{spanish}{list}}\foreignlanguage{spanish}{ o
}\textstyleSourceText{\foreignlanguage{spanish}{map}}\foreignlanguage{spanish}{. El prototipo de función es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
void be\_setindex(bvm *vm, int index);}


\bigskip

\foreignlanguage{spanish}{El parámetro }\textstyleSourceText{\foreignlanguage{spanish}{vm}}\foreignlanguage{spanish}{ es
el puntero de la instancia de la máquina virtual, y el parámetro
}\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ es el subíndice del objeto a operar.
Esta función se utiliza para escribir un elemento del contenedor
}\textstyleSourceText{\foreignlanguage{spanish}{map}}\foreignlanguage{spanish}{ o
}\textstyleSourceText{\foreignlanguage{spanish}{list}}\foreignlanguage{spanish}{. El índice del valor que se va a
escribir en la pila virtual es -1, y el índice del subíndice de la posición de escritura en la pila virtual es -2. Si
el elemento con el subíndice especificado no existe en el contenedor, la operación de escritura fallará.}

\foreignlanguage{spanish}{Suponiendo que la posición con el índice
}\textstyleSourceText{\foreignlanguage{spanish}{1}}\foreignlanguage{spanish}{ en la pila virtual tiene un valor de
}\textstyleSourceText{\foreignlanguage{spanish}{map}}\foreignlanguage{spanish}{, y tiene un elemento con un subíndice
de }\textstyleSourceText{\foreignlanguage{spanish}{{\textquotedbl}prueba{\textquotedbl}}}\foreignlanguage{spanish}{, un
ejemplo de configuración del elemento en el subíndice de
}\textstyleSourceText{\foreignlanguage{spanish}{{\textquotedbl}prueba{\textquotedbl} }}\foreignlanguage{spanish}{a
}\textstyleSourceText{\foreignlanguage{spanish}{100}}\foreignlanguage{spanish}{ es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
be\_pushstring(vm, {\textquotedbl}prueba{\textquotedbl}); // Empuja el índice {\textquotedbl}índice{\textquotedbl}}

{\selectlanguage{spanish}\ttfamily
be\_pushint(vm, 100); \ \ \ \ \ \ \ \ // Empuja el valor 100}

{\selectlanguage{spanish}\ttfamily
be\_setindex(vm, 1); \ \ \ \ \ \ \ \ \ // Establece el par clave-valor a map[{\textquotedbl}prueba{\textquotedbl}] =
100}


\bigskip

\foreignlanguage{spanish}{Primero debemos empujar el subíndice y el valor que se escribirá en la pila en orden. Para
}\textstyleSourceText{\foreignlanguage{spanish}{map}}\foreignlanguage{spanish}{, es un par clave-valor. En el ejemplo,
las dos primeras líneas de código completan estas tareas. La tercera línea llama a la función
}\textstyleSourceText{\foreignlanguage{spanish}{be\_setindex}}\foreignlanguage{spanish}{ para escribir el valor en el
objeto }\textstyleSourceText{\foreignlanguage{spanish}{map}}\foreignlanguage{spanish}{.}

\foreignlanguage{spanish}{La función
}\textstyleSourceText{\foreignlanguage{spanish}{be\_getupval}}\foreignlanguage{spanish}{ se utiliza para leer un valor
ascendente del cierre nativo. El prototipo de función es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
void be\_getupval(bvm *vm, int index, int pos);}


\bigskip

\foreignlanguage{spanish}{El parámetro }\textstyleSourceText{\foreignlanguage{spanish}{vm}}\foreignlanguage{spanish}{ es
el puntero de la instancia de la máquina virtual;
}\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ es el valor de índice de cierre
nativo del valor ascendente que se va a leer;
}\textstyleSourceText{\foreignlanguage{spanish}{pos}}\foreignlanguage{spanish}{ es la posición del upvalue en la tabla
upvalue de cierre nativa (la numeración comienza desde 0). El valor leído se colocará en la parte superior de la pila
virtual.}

\foreignlanguage{spanish}{La función
}\textstyleSourceText{\foreignlanguage{spanish}{be\_setupval}}\foreignlanguage{spanish}{ se utiliza para establecer un
valor superior del cierre nativo. El prototipo de función es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
void be\_setupval(bvm *vm, int index, int pos);}


\bigskip

\foreignlanguage{spanish}{El parámetro }\textstyleSourceText{\foreignlanguage{spanish}{vm}}\foreignlanguage{spanish}{ es
el puntero de la instancia de la máquina virtual;
}\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ es el valor del índice de cierre
nativo que se escribirá en upvalue; }\textstyleSourceText{\foreignlanguage{spanish}{pos}}\foreignlanguage{spanish}{ es
la posición del upvalue en la tabla upvalue de cierre nativa (la numeración comienza desde 0). Esta función obtiene un
valor de la parte superior de la pila virtual y lo escribe en el valor superior de destino. Una vez completada la
operación, el valor superior de la pila no se extraerá de la pila.}

\foreignlanguage{spanish}{La función
}\textstyleSourceText{\foreignlanguage{spanish}{be\_getsuper}}\foreignlanguage{spanish}{ se utiliza para obtener el
objeto principal de la clase base o la instancia de la clase. El prototipo de función es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
void be\_getsuper(bvm *vm, int index);}


\bigskip

\foreignlanguage{spanish}{El parámetro }\textstyleSourceText{\foreignlanguage{spanish}{vm}}\foreignlanguage{spanish}{ es
el puntero de la instancia de la máquina virtual;
}\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ es la clase u objeto a operar. Si el
valor en }\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ es una clase con una clase
base, la función colocará su clase base en la parte superior de la pila; si el valor en
}\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ es un objeto con un objeto padre, la
función tomará su padre. El objeto se coloca en la parte superior de la pila; de lo contrario, se coloca un valor de
}\textstyleSourceText{\foreignlanguage{spanish}{nil}}\foreignlanguage{spanish}{ en la parte superior de la pila.}

\foreignlanguage{spanish}{La función
}\textstyleSourceText{\foreignlanguage{spanish}{be\_data\_size}}\foreignlanguage{spanish}{ se utiliza para obtener el
número de elementos contenidos en el contenedor. El prototipo de función es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
int be\_data\_size(bvm *vm, int index);}


\bigskip

\foreignlanguage{spanish}{El parámetro }\textstyleSourceText{\foreignlanguage{spanish}{vm}}\foreignlanguage{spanish}{ es
el puntero de la instancia de la máquina virtual;
}\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ es el índice del objeto contenedor
que se va a operar. Si el valor en }\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ es
un valor Map o List, la función }\foreignlanguage{spanish}{devuelve el número de elementos contenidos en el contenedor;
de lo contrario, devuelve }\textstyleSourceText{\foreignlanguage{spanish}{{}-1}}\foreignlanguage{spanish}{.}

\foreignlanguage{spanish}{La función
}\textstyleSourceText{\foreignlanguage{spanish}{be\_data\_push}}\foreignlanguage{spanish}{ se usa para agregar un nuevo
elemento al final del contenedor. El prototipo de función es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
void be\_data\_push(bvm *vm, int index);}


\bigskip

\foreignlanguage{spanish}{El parámetro }\textstyleSourceText{\foreignlanguage{spanish}{vm}}\foreignlanguage{spanish}{ es
el puntero de la instancia de la máquina virtual;
}\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ es el índice del objeto contenedor
que se va a operar. El objeto en }\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ debe
ser un valor de Lista. Esta función obtiene un valor de la parte superior de la pila y lo agrega al final del
contenedor. Una vez completada la operación, el valor en la parte superior de la pila no se extraerá de la pila.}

\foreignlanguage{spanish}{La función
}\textstyleSourceText{\foreignlanguage{spanish}{be\_data\_insert}}\foreignlanguage{spanish}{ se utiliza para insertar
un par de elementos en el contenedor. El prototipo de función es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
void be\_data\_insert(bvm *vm, int index);}


\bigskip

\foreignlanguage{spanish}{El parámetro }\textstyleSourceText{\foreignlanguage{spanish}{vm}}\foreignlanguage{spanish}{ es
el puntero de la instancia de la máquina virtual;
}\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ es el índice del objeto contenedor
que se va a operar. El objeto en }\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ debe
ser un valor de lista o un valor de mapa. El elemento insertado forma un par de pares clave-valor. El valor se almacena
en la parte superior de la pila y la clave se almacena en el índice anterior en la parte superior de la pila. Cabe
señalar que la clave insertada en el contenedor Mapa no puede ser un valor {\textquotedbl}nil{\textquotedbl} y la clave
insertada en el contenedor Lista debe ser un valor entero. Si la operación es exitosa, la función devolverá
}\textstyleSourceText{\foreignlanguage{spanish}{bture}}\foreignlanguage{spanish}{, de lo contrario devolverá
}\textstyleSourceText{\foreignlanguage{spanish}{bfalse}}\foreignlanguage{spanish}{.}

\foreignlanguage{spanish}{La función
}\textstyleSourceText{\foreignlanguage{spanish}{be\_data\_remove}}\foreignlanguage{spanish}{ se utiliza para eliminar
un elemento del contenedor. El prototipo de función es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
void be\_data\_remove(bvm *vm, int index);}


\bigskip

\foreignlanguage{spanish}{El parámetro }\textstyleSourceText{\foreignlanguage{spanish}{vm}}\foreignlanguage{spanish}{ es
el puntero de la instancia de la máquina virtual;
}\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ es el índice del objeto contenedor
que se va a operar. El objeto en }\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ debe
ser un valor de lista o un valor de mapa. Para el contenedor de mapas, la llave para eliminar el elemento se almacena
en la parte superior de la pila virtual (debe empujarse antes de llamar a la función); para el contenedor de lista, el
índice del elemento que se va a eliminar se almacena en la parte superior de la pila virtual (debe estar antes de la
llamada a la función). Si la operación es exitosa, la función devolverá
}\textstyleSourceText{\foreignlanguage{spanish}{btrue}}\foreignlanguage{spanish}{, de lo contrario devolverá
}\textstyleSourceText{\foreignlanguage{spanish}{bfalse}}\foreignlanguage{spanish}{.}

\foreignlanguage{spanish}{La función
}\textstyleSourceText{\foreignlanguage{spanish}{be\_data\_resize}}\foreignlanguage{spanish}{ se utiliza para
restablecer la capacidad del contenedor. El prototipo de función es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
void be\_data\_resize(bvm *vm, int index);}


\bigskip

\foreignlanguage{spanish}{El parámetro }\textstyleSourceText{\foreignlanguage{spanish}{vm}}\foreignlanguage{spanish}{ es
el puntero de la instancia de la máquina virtual;
}\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ es el índice del objeto contenedor
que se va a operar. Esta función solo está disponible para contenedores de lista y la nueva capacidad se almacena en la
parte superior de la pila virtual (debe ser un número entero).}

\foreignlanguage{spanish}{La función
}\textstyleSourceText{\foreignlanguage{spanish}{be\_iter\_next}}\foreignlanguage{spanish}{ se utiliza para obtener el
siguiente elemento del iterador. El prototipo de función es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
int be\_iter\_next(bvm *vm, int index);}


\bigskip

\foreignlanguage{spanish}{El parámetro }\textstyleSourceText{\foreignlanguage{spanish}{vm}}\foreignlanguage{spanish}{ es
el puntero de la instancia de la máquina virtual;
}\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ es el índice del iterador a operar.
El objeto iterador puede ser un iterador de un contenedor List o un contenedor Map. Para el iterador List, esta función
empuja el valor del resultado de la iteración a la parte superior de la pila, mientras que para el iterador Map, empuja
el valor clave a la posición anterior y la parte superior de la pila, respectivamente. Llamar a esta función
actualizará el iterador. Si la función devuelve
}\textstyleSourceText{\foreignlanguage{spanish}{0}}\foreignlanguage{spanish}{, la llamada falla, devuelve
}\textstyleSourceText{\foreignlanguage{spanish}{1}}\foreignlanguage{spanish}{ para indicar que el iterador actual es un
iterador de lista y devuelve }\textstyleSourceText{\foreignlanguage{spanish}{2}}\foreignlanguage{spanish}{ para indicar
que el iterador actual es un iterador de mapa.}

\foreignlanguage{spanish}{La función
}\textstyleSourceText{\foreignlanguage{spanish}{map\_hasnext}}\foreignlanguage{spanish}{ se usa para probar si hay otro
elemento en el iterador. El prototipo de función es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
int map\_hasnext(bvm *vm, int index)}


\bigskip

\foreignlanguage{spanish}{El parámetro }\textstyleSourceText{\foreignlanguage{spanish}{vm}}\foreignlanguage{spanish}{ es
el puntero de la instancia de la máquina virtual;
}\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ es el índice del iterador a operar.
El objeto iterador puede ser un iterador de un contenedor List o un contenedor Map. Si hay más elementos iterables en
el iterador, devuelve }\textstyleSourceText{\foreignlanguage{spanish}{1}}\foreignlanguage{spanish}{, de lo contrario,
devuelve }\textstyleSourceText{\foreignlanguage{spanish}{0}}\foreignlanguage{spanish}{.}

\foreignlanguage{spanish}{La función
}\textstyleSourceText{\foreignlanguage{spanish}{be\_refcontains}}\foreignlanguage{spanish}{ se usa para probar si hay
una referencia al objeto especificado en la pila de referencia. Debe usarse junto con
}\textstyleSourceText{\foreignlanguage{spanish}{be\_refpush}}\foreignlanguage{spanish}{ y
}\textstyleSourceText{\foreignlanguage{spanish}{be\_refpop}}\foreignlanguage{spanish}{. Esta API puede evitar la
recursividad al atravesar objetos que tienen sus propias referencias. El prototipo de función es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
int be\_refcontains(bvm *vm, int index);}


\bigskip

\foreignlanguage{spanish}{El parámetro }\textstyleSourceText{\foreignlanguage{spanish}{vm}}\foreignlanguage{spanish}{ es
el puntero de la instancia de la máquina virtual;
}\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ es el índice del objeto a operar.
Esta función se utiliza para el valor de un tipo de instancia. Si hay una referencia al objeto en la pila de
referencia, devuelve }\textstyleSourceText{\foreignlanguage{spanish}{1}}\foreignlanguage{spanish}{, de lo contrario,
devuelve }\textstyleSourceText{\foreignlanguage{spanish}{0}}\foreignlanguage{spanish}{.}

\foreignlanguage{spanish}{La función
}\textstyleSourceText{\foreignlanguage{spanish}{be\_refpush}}\foreignlanguage{spanish}{ inserta la referencia del
objeto especificado en la pila de referencia. El prototipo de función es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
int be\_refpush(bvm *vm, int index);}


\bigskip

\foreignlanguage{spanish}{El parámetro }\textstyleSourceText{\foreignlanguage{spanish}{vm}}\foreignlanguage{spanish}{ es
el puntero de la instancia de la máquina virtual;
}\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ es el índice del objeto a operar.
Esta función se utiliza para el valor de un tipo de instancia.}

\foreignlanguage{spanish}{La función
}\textstyleSourceText{\foreignlanguage{spanish}{be\_refpop}}\foreignlanguage{spanish}{ extrae el objeto en la parte
superior de la pila de referencia. Esta función eliminará un valor de la pila.}


\bigskip

{\selectlanguage{spanish}\ttfamily
int be\_refpop(bvm *vm);}


\bigskip

\foreignlanguage{spanish}{El parámetro }\textstyleSourceText{\foreignlanguage{spanish}{vm}}\foreignlanguage{spanish}{ es
el puntero de la instancia de la máquina virtual. Esta función se usa en pares con
}\textstyleSourceText{\foreignlanguage{spanish}{be\_refpush}}\foreignlanguage{spanish}{. El siguiente es el uso de la
API de la pila de referencia para evitar el problema del recorrido recursivo infinito cuando se hace referencia al
objeto mismo:}


\bigskip

{\selectlanguage{spanish}\ttfamily
int list\_traversal(bvm *vm)}

{\selectlanguage{spanish}\ttfamily
\{}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ // ...}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ if (be\_refcontains(vm, 1)) \{}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ be\_return(vm);}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \}}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ be\_refpush(vm, 1);}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ // Atravesando el contenedor, puede llamar a list\_traversal recursivamente.}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ be\_refpop(vm);}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ be\_return(vm);}

{\selectlanguage{spanish}\ttfamily
\}}


\bigskip

\foreignlanguage{spanish}{Este es un proceso transversal simplificado del contenedor List. Para obtener el código
completo, consulte el código fuente de la función
}\textstyleSourceText{\foreignlanguage{spanish}{m\_tostring}}\foreignlanguage{spanish}{ en
}\foreignlanguage{spanish}{\textit{be\_listlib.c}}\foreignlanguage{spanish}{. Asumimos que el índice del objeto List es
}\textstyleSourceText{\foreignlanguage{spanish}{1}}\foreignlanguage{spanish}{. Primero, verificamos si la Lista ya
existe en la pila de referencia (línea 4), y si la referencia ya existe, regresa directamente, de lo contrario,
continúa con el procesamiento posterior. Para hacer utilizable
}\textstyleSourceText{\foreignlanguage{spanish}{be\_refcontains}}\foreignlanguage{spanish}{, necesitamos usar
}\textstyleSourceText{\foreignlanguage{spanish}{be\_refpush}}\foreignlanguage{spanish}{ y
}\textstyleSourceText{\foreignlanguage{spanish}{be\_refpop}}\foreignlanguage{spanish}{ para procesar la pila de
referencia antes y después de la operación transversal real (líneas 7 y 9).}

\foreignlanguage{spanish}{La función
}\textstyleSourceText{\foreignlanguage{spanish}{be\_stack\_require}}\foreignlanguage{spanish}{ prueba la cantidad de
espacio libre en la pila y expande el espacio de la pila si es insuficiente. El prototipo de función es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
void be\_stack\_require(bvm *vm, int count);}


\bigskip

\foreignlanguage{spanish}{El parámetro }\textstyleSourceText{\foreignlanguage{spanish}{vm}}\foreignlanguage{spanish}{ es
el puntero de la instancia de la máquina virtual;
}\textstyleSourceText{\foreignlanguage{spanish}{count}}\foreignlanguage{spanish}{ es la capacidad de pila libre
requerida. Si la capacidad libre de la pila virtual asignada por la VM a la función nativa es inferior a este valor, se
realizará una operación de expansión.}

\foreignlanguage{spanish}{La función
}\textstyleSourceText{\foreignlanguage{spanish}{be\_isnil}}\foreignlanguage{spanish}{ devuelve si el valor indexado por
el parámetro }\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ en la pila virtual es
}\textstyleSourceText{\foreignlanguage{spanish}{nil}}\foreignlanguage{spanish}{, si lo es, devuelve
}\textstyleSourceText{\foreignlanguage{spanish}{1}}\foreignlanguage{spanish}{, de lo contrario, devuelve
}\textstyleSourceText{\foreignlanguage{spanish}{0}}\foreignlanguage{spanish}{. El prototipo de esta función es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
int be\_isnil(bvm *vm, int index);}


\bigskip

\foreignlanguage{spanish}{El parámetro }\textstyleSourceText{\foreignlanguage{spanish}{vm}}\foreignlanguage{spanish}{ es
el puntero de la instancia de la máquina virtual, e
}\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ es el índice del valor a medir.}

\foreignlanguage{spanish}{La función
}\textstyleSourceText{\foreignlanguage{spanish}{be\_isbool}}\foreignlanguage{spanish}{ devuelve si el valor indexado
por el parámetro }\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ en la pila virtual
es de tipo }\textstyleSourceText{\foreignlanguage{spanish}{bool}}\foreignlanguage{spanish}{, si lo es, la función
devuelve }\textstyleSourceText{\foreignlanguage{spanish}{1}}\foreignlanguage{spanish}{, de lo contrario devuelve
}\textstyleSourceText{\foreignlanguage{spanish}{0}}\foreignlanguage{spanish}{. El prototipo de esta función es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
int be\_isbool(bvm *vm, int index);}


\bigskip

\foreignlanguage{spanish}{El parámetro }\textstyleSourceText{\foreignlanguage{spanish}{vm}}\foreignlanguage{spanish}{ es
el puntero de la instancia de la máquina virtual, e
}\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ es el índice del
}\foreignlanguage{spanish}{valor a medir.}

\foreignlanguage{spanish}{La función
}\textstyleSourceText{\foreignlanguage{spanish}{be\_isint}}\foreignlanguage{spanish}{ devuelve si el valor indexado por
el parámetro }\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ en la pila virtual es de
tipo entero, si lo es, devuelve }\textstyleSourceText{\foreignlanguage{spanish}{1}}\foreignlanguage{spanish}{, de lo
contrario, devuelve }\textstyleSourceText{\foreignlanguage{spanish}{0}}\foreignlanguage{spanish}{. El prototipo de esta
función es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
int be\_isint(bvm *vm, int index);}


\bigskip

\foreignlanguage{spanish}{El parámetro }\textstyleSourceText{\foreignlanguage{spanish}{vm}}\foreignlanguage{spanish}{ es
el puntero de la instancia de la máquina virtual, e
}\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ es el índice del valor a medir.}

\foreignlanguage{spanish}{La función
}\textstyleSourceText{\foreignlanguage{spanish}{be\_isreal}}\foreignlanguage{spanish}{ devuelve si el valor indexado
por el parámetro }\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ en la pila virtual
es un tipo de número real, si lo es, devuelve
}\textstyleSourceText{\foreignlanguage{spanish}{1}}\foreignlanguage{spanish}{, de lo contrario, devuelve
}\textstyleSourceText{\foreignlanguage{spanish}{0}}\foreignlanguage{spanish}{. El prototipo de esta función es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
int be\_isreal(bvm *vm, int index);}


\bigskip

\foreignlanguage{spanish}{El parámetro }\textstyleSourceText{\foreignlanguage{spanish}{vm}}\foreignlanguage{spanish}{ es
el puntero de la instancia de la máquina virtual, e
}\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ es el índice del valor a medir.}

\foreignlanguage{spanish}{La función
}\textstyleSourceText{\foreignlanguage{spanish}{be\_isnumber}}\foreignlanguage{spanish}{ devuelve si el valor indexado
por el parámetro }\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ en la pila virtual
es un número entero o un tipo de número real, si lo es, devuelve
}\textstyleSourceText{\foreignlanguage{spanish}{1}}\foreignlanguage{spanish}{, de lo contrario, devuelve
}\textstyleSourceText{\foreignlanguage{spanish}{0}}\foreignlanguage{spanish}{. El prototipo de esta función es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
int be\_isnumber(bvm *vm, int index);}


\bigskip

\foreignlanguage{spanish}{El parámetro }\textstyleSourceText{\foreignlanguage{spanish}{vm}}\foreignlanguage{spanish}{ es
el puntero de la instancia de la máquina virtual, e
}\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ es el índice del valor a medir.}

\foreignlanguage{spanish}{La función
}\textstyleSourceText{\foreignlanguage{spanish}{be\_isstring}}\foreignlanguage{spanish}{ devuelve si el valor indexado
por el parámetro }\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ en la pila virtual
es un tipo de cadena, si lo es, devuelve }\textstyleSourceText{\foreignlanguage{spanish}{1}}\foreignlanguage{spanish}{,
de lo contrario, devuelve }\textstyleSourceText{\foreignlanguage{spanish}{0}}\foreignlanguage{spanish}{. El prototipo
de esta función es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
int be\_isstring(bvm *vm, int index);}


\bigskip

\foreignlanguage{spanish}{El parámetro }\textstyleSourceText{\foreignlanguage{spanish}{vm}}\foreignlanguage{spanish}{ es
el puntero de la instancia de la máquina virtual, e
}\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ es el índice del valor a medir.}

\foreignlanguage{spanish}{La función
}\textstyleSourceText{\foreignlanguage{spanish}{be\_isclosure}}\foreignlanguage{spanish}{ devuelve si el valor indexado
por el parámetro }\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ en la pila virtual
es un tipo de cierre, si lo es, devuelve }\textstyleSourceText{\foreignlanguage{spanish}{1}}\foreignlanguage{spanish}{,
de lo contrario, devuelve }\textstyleSourceText{\foreignlanguage{spanish}{0}}\foreignlanguage{spanish}{. El prototipo
de esta función es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
int be\_isclosure(bvm *vm, int index);}


\bigskip

\foreignlanguage{spanish}{El parámetro }\textstyleSourceText{\foreignlanguage{spanish}{vm}}\foreignlanguage{spanish}{ es
el puntero de la instancia de la máquina virtual, e
}\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ es el índice del valor a medir.}

\foreignlanguage{spanish}{La función
}\textstyleSourceText{\foreignlanguage{spanish}{be\_isntvclos}}\foreignlanguage{spanish}{ devuelve si el valor indexado
por el parámetro }\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ en la pila virtual
es un tipo de cierre primitivo, si lo es, devuelve
}\textstyleSourceText{\foreignlanguage{spanish}{1}}\foreignlanguage{spanish}{, de lo contrario, devuelve
}\textstyleSourceText{\foreignlanguage{spanish}{0}}\foreignlanguage{spanish}{. El }\foreignlanguage{spanish}{prototipo
de esta función es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
int be\_isntvclos(bvm *vm, int index);}


\bigskip

\foreignlanguage{spanish}{El parámetro }\textstyleSourceText{\foreignlanguage{spanish}{vm}}\foreignlanguage{spanish}{ es
el puntero de la instancia de la máquina virtual, e
}\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ es el índice del valor a medir.}

\foreignlanguage{spanish}{La función
}\textstyleSourceText{\foreignlanguage{spanish}{be\_isfunction}}\foreignlanguage{spanish}{ devuelve si el valor
indexado por el parámetro }\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ en la pila
virtual es un tipo de función, si lo es, devuelve
}\textstyleSourceText{\foreignlanguage{spanish}{1}}\foreignlanguage{spanish}{, de lo contrario, devuelve
}\textstyleSourceText{\foreignlanguage{spanish}{0}}\foreignlanguage{spanish}{. El prototipo de esta función es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
int be\_isfunction(bvm *vm, int index);}


\bigskip

\foreignlanguage{spanish}{El parámetro }\textstyleSourceText{\foreignlanguage{spanish}{vm}}\foreignlanguage{spanish}{ es
el puntero de la instancia de la máquina virtual, e
}\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ es el índice del valor a medir. Hay
tres tipos de funciones: cierre, función nativa y cierre nativo.}

\foreignlanguage{spanish}{La función
}\textstyleSourceText{\foreignlanguage{spanish}{be\_isproto}}\foreignlanguage{spanish}{ devuelve si el valor indexado
por el parámetro }\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ en la pila virtual
es de tipo }\textstyleSourceText{\foreignlanguage{spanish}{proto}}\foreignlanguage{spanish}{, si lo es, devuelve
}\textstyleSourceText{\foreignlanguage{spanish}{1}}\foreignlanguage{spanish}{, de lo contrario, devuelve
}\textstyleSourceText{\foreignlanguage{spanish}{0}}\foreignlanguage{spanish}{. El prototipo de esta función es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
int be\_isproto(bvm *vm, int index);}


\bigskip

\foreignlanguage{spanish}{El parámetro }\textstyleSourceText{\foreignlanguage{spanish}{vm}}\foreignlanguage{spanish}{ es
el puntero de la instancia de la máquina virtual, e
}\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ es el índice del valor a medir. El
tipo }\textstyleSourceText{\foreignlanguage{spanish}{proto}}\foreignlanguage{spanish}{ es el prototipo de función del
cierre de Berry.}

\foreignlanguage{spanish}{La función
}\textstyleSourceText{\foreignlanguage{spanish}{be\_isclass}}\foreignlanguage{spanish}{ devuelve si el valor indexado
por el parámetro }\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ en la pila virtual
es de tipo }\textstyleSourceText{\foreignlanguage{spanish}{class}}\foreignlanguage{spanish}{, si lo es, devuelve
}\textstyleSourceText{\foreignlanguage{spanish}{1}}\foreignlanguage{spanish}{, de lo contrario devuelve
}\textstyleSourceText{\foreignlanguage{spanish}{0}}\foreignlanguage{spanish}{. El prototipo de esta función es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
int be\_isclass(bvm *vm, int index);}


\bigskip

\foreignlanguage{spanish}{El parámetro }\textstyleSourceText{\foreignlanguage{spanish}{vm}}\foreignlanguage{spanish}{ es
el puntero de la instancia de la máquina virtual, e
}\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ es el índice del valor a medir.}

\foreignlanguage{spanish}{La función
}\textstyleSourceText{\foreignlanguage{spanish}{be\_isinstance}}\foreignlanguage{spanish}{ devuelve si el valor
indexado por el parámetro }\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ en la pila
virtual es de tipo }\textstyleSourceText{\foreignlanguage{spanish}{instance}}\foreignlanguage{spanish}{, si lo es,
devuelve }\textstyleSourceText{\foreignlanguage{spanish}{1}}\foreignlanguage{spanish}{, de lo contrario devuelve
}\textstyleSourceText{\foreignlanguage{spanish}{0}}\foreignlanguage{spanish}{. El prototipo de esta función es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
int be\_isinstance(bvm *vm, int index);}


\bigskip

\foreignlanguage{spanish}{El parámetro }\textstyleSourceText{\foreignlanguage{spanish}{vm}}\foreignlanguage{spanish}{ es
el puntero de la instancia de la máquina virtual, e
}\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ es el índice del valor a medir.}

\foreignlanguage{spanish}{La función
}\textstyleSourceText{\foreignlanguage{spanish}{be\_isbytes}}\foreignlanguage{spanish}{ devuelve si el valor indexado
por el parámetro }\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ en la pila virtual
es una instancia o subinstancia de la clase
}\textstyleSourceText{\foreignlanguage{spanish}{bytes}}\foreignlanguage{spanish}{; si lo es, devuelve
}\textstyleSourceText{\foreignlanguage{spanish}{1}}\foreignlanguage{spanish}{; de lo contrario, devuelve
}\textstyleSourceText{\foreignlanguage{spanish}{0}}\foreignlanguage{spanish}{. El prototipo de esta función es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
int be\_isbytes(bvm *vm, int index);}


\bigskip

\foreignlanguage{spanish}{La función
}\textstyleSourceText{\foreignlanguage{spanish}{be\_islist}}\foreignlanguage{spanish}{ devuelve si el valor indexado
por el parámetro }\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ en la pila virtual
es de tipo }\textstyleSourceText{\foreignlanguage{spanish}{list}}\foreignlanguage{spanish}{, si lo es, devuelve
}\textstyleSourceText{\foreignlanguage{spanish}{1}}\foreignlanguage{spanish}{, de lo contrario devuelve
}\textstyleSourceText{\foreignlanguage{spanish}{0}}\foreignlanguage{spanish}{. El prototipo de esta función es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
int be\_islist(bvm *vm, int index);}


\bigskip

\foreignlanguage{spanish}{El parámetro }\textstyleSourceText{\foreignlanguage{spanish}{vm}}\foreignlanguage{spanish}{ es
el puntero de la instancia de la máquina virtual, e
}\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ es el índice del valor a medir.}

\foreignlanguage{spanish}{La función
}\textstyleSourceText{\foreignlanguage{spanish}{be\_ismap}}\foreignlanguage{spanish}{ devuelve si el valor indexado por
el parámetro }\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ en la pila virtual es de
tipo }\textstyleSourceText{\foreignlanguage{spanish}{map}}\foreignlanguage{spanish}{, si lo es, devuelve
}\textstyleSourceText{\foreignlanguage{spanish}{1}}\foreignlanguage{spanish}{, de lo contrario devuelve
}\textstyleSourceText{\foreignlanguage{spanish}{0}}\foreignlanguage{spanish}{. El prototipo de esta función es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
int be\_ismap(bvm *vm, int index);}


\bigskip

\foreignlanguage{spanish}{El parámetro }\textstyleSourceText{\foreignlanguage{spanish}{vm}}\foreignlanguage{spanish}{ es
el puntero de la instancia de la máquina virtual, e
}\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ es el índice del valor a medir.}

\foreignlanguage{spanish}{La función
}\textstyleSourceText{\foreignlanguage{spanish}{be\_iscomptr}}\foreignlanguage{spanish}{ devuelve si el valor indexado
por el parámetro }\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ en la pila virtual
es un tipo de puntero universal, si lo es, devuelve
}\textstyleSourceText{\foreignlanguage{spanish}{1}}\foreignlanguage{spanish}{, de lo contrario, devuelve
}\textstyleSourceText{\foreignlanguage{spanish}{0}}\foreignlanguage{spanish}{. El prototipo de esta función es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
int be\_iscomptr(bvm *vm, int index);}


\bigskip

\foreignlanguage{spanish}{El parámetro }\textstyleSourceText{\foreignlanguage{spanish}{vm}}\foreignlanguage{spanish}{ es
el puntero de la instancia de la máquina virtual, e
}\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ es el índice del valor a medir.}


\bigskip

{\selectlanguage{spanish}\ttfamily
bint be\_toint(bvm *vm, int index);}


\bigskip

\foreignlanguage{spanish}{Obtiene el valor de la posición de índice de
}\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ de la pila virtual y devuelve como un
tipo entero. Esta función no comprueba la corrección del tipo. Si el valor es una instancia, se llama al método
}\textstyleSourceText{\foreignlanguage{spanish}{toint()}}\foreignlanguage{spanish}{ si existe.}


\bigskip

{\selectlanguage{spanish}\ttfamily
breal be\_toreal(bvm *vm, int index);}


\bigskip

\foreignlanguage{spanish}{Obtiene el valor de la posición de índice de
}\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ de la pila virtual y devuelve como un
tipo de número de punto flotante. Esta función no comprueba la exactitud del tipo.}


\bigskip

{\selectlanguage{spanish}\ttfamily
bint be\_toindex(bvm *vm, int index);}


\bigskip

\foreignlanguage{spanish}{Obtiene el valor de la posición de índice de
}\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ de la pila virtual y devuelve como un
tipo entero. Esta función no comprueba la corrección del tipo. A diferencia de
}\textstyleSourceText{\foreignlanguage{spanish}{be\_toint}}\foreignlanguage{spanish}{, el tipo de valor de retorno de
}\textstyleSourceText{\foreignlanguage{spanish}{be\_toindex}}\foreignlanguage{spanish}{ es
}\textstyleSourceText{\foreignlanguage{spanish}{int}}\foreignlanguage{spanish}{, mientras que el valor de retorno del
primero es }\textstyleSourceText{\foreignlanguage{spanish}{bint}}\foreignlanguage{spanish}{.}


\bigskip

{\selectlanguage{spanish}\ttfamily
bbool be\_tobool(bvm *vm, int index);}


\bigskip

\foreignlanguage{spanish}{Obtiene el valor de la posición de índice de
}\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ de la pila virtual y devuelve como un
tipo booleano. Si el valor indexado no es de tipo booleano, se convertirá de acuerdo con las reglas de la sección
type\_bool, y el proceso de conversión no hará que cambie el valor indexado. Si el valor es una instancia, se llama al
método }\textstyleSourceText{\foreignlanguage{spanish}{tobool()}}\foreignlanguage{spanish}{ si existe.}


\bigskip

{\selectlanguage{spanish}\ttfamily
const char* be\_tostring(bvm *vm, int index);}


\bigskip

\foreignlanguage{spanish}{Obtiene el valor de la posición de índice de
}\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ de la pila virtual y devuelve como un
tipo de cadena. Si el valor indexado no es un tipo de cadena, el valor indexado se convertirá en una cadena y el
proceso de conversión reemplazará el valor en la posición indexada en la pila virtual con la cadena convertida. La
cadena devuelta por esta función siempre termina con los caracteres
}\textstyleSourceText{\foreignlanguage{spanish}{{}'{\textbackslash}0'}}\foreignlanguage{spanish}{. Si el valor es una
instancia, se llama al método }\textstyleSourceText{\foreignlanguage{spanish}{tostring()}}\foreignlanguage{spanish}{ si
existe.}


\bigskip

{\selectlanguage{spanish}\ttfamily
void* be\_tocomptr(bvm* vm, int index);}


\bigskip

\foreignlanguage{spanish}{Obtiene el valor de la posición de índice de
}\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ de la pila virtual y devuelve como un
tipo de puntero general. Esta función no comprueba la exactitud del tipo.}


\bigskip

{\selectlanguage{spanish}\ttfamily
const void* be\_tobytes(bvm *vm, int index, size\_t *len);}


\bigskip

\foreignlanguage{spanish}{Obtiene el valor de la posición de índice de
}\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ de la pila virtual y devuelve como un
búfer de bytes. Se devuelve el puntero del búfer y el tamaño se almacena en
}\textstyleSourceText{\foreignlanguage{spanish}{*len}}\foreignlanguage{spanish}{ (a menos que
}\textstyleSourceText{\foreignlanguage{spanish}{len}}\foreignlanguage{spanish}{ sea NULL). Esta función funciona solo
para instancias de la clase }\textstyleSourceText{\foreignlanguage{spanish}{bytes}}\foreignlanguage{spanish}{, o
devuelve }\textstyleSourceText{\foreignlanguage{spanish}{NULL}}\foreignlanguage{spanish}{.}


\bigskip

{\selectlanguage{spanish}\ttfamily
void be\_pushnil(bvm *vm);}

\foreignlanguage{spanish}{Inserta un valor
}\textstyleSourceText{\foreignlanguage{spanish}{nil}}\foreignlanguage{spanish}{ en la pila virtual.}


\bigskip

{\selectlanguage{spanish}\ttfamily
void be\_pushbool(bvm *vm, int b);}

\foreignlanguage{spanish}{Inserta un valor booleano en la pila virtual. El parámetro
}\textstyleSourceText{\foreignlanguage{spanish}{b}}\foreignlanguage{spanish}{ es el valor booleano que se insertará en
la pila. Cuando el valor es }\textstyleSourceText{\foreignlanguage{spanish}{0}}\foreignlanguage{spanish}{, significa
falso, de lo contrario es verdadero.}


\bigskip

{\selectlanguage{spanish}\ttfamily
void be\_pushint(bvm *vm, bint i);}

\foreignlanguage{spanish}{Inserta un valor entero
}\textstyleSourceText{\foreignlanguage{spanish}{i}}\foreignlanguage{spanish}{ en la pila virtual.}


\bigskip

{\selectlanguage{spanish}\ttfamily
void be\_pushreal(bvm *vm, breal r);}

\foreignlanguage{spanish}{Inserta un valor de punto flotante
}\textstyleSourceText{\foreignlanguage{spanish}{r}}\foreignlanguage{spanish}{ en la pila virtual.}


\bigskip

{\selectlanguage{spanish}\ttfamily
void be\_pushstring(bvm *vm, const char *str)}

\foreignlanguage{spanish}{Empuja la cadena
}\textstyleSourceText{\foreignlanguage{spanish}{str}}\foreignlanguage{spanish}{ en la pila virtual. El parámetro
}\textstyleSourceText{\foreignlanguage{spanish}{str}}\foreignlanguage{spanish}{ debe apuntar a una cadena C que termina
con un carácter nulo }\textstyleSourceText{\foreignlanguage{spanish}{{}'{\textbackslash}0'}}\foreignlanguage{spanish}{,
y no se puede pasar un puntero nulo.}


\bigskip

{\selectlanguage{spanish}\ttfamily
void be\_pushnstring(bvm *vm, const char *str, size\_t n);}

\foreignlanguage{spanish}{Inserta la cadena
}\textstyleSourceText{\foreignlanguage{spanish}{str}}\foreignlanguage{spanish}{ de longitud
}\textstyleSourceText{\foreignlanguage{spanish}{n}}\foreignlanguage{spanish}{ en la pila virtual. La longitud de la
cadena está sujeta al parámetro }\textstyleSourceText{\foreignlanguage{spanish}{n}}\foreignlanguage{spanish}{ y el
carácter nulo no se usa como marca final de la cadena.}


\bigskip

{\selectlanguage{spanish}\ttfamily
const char* be\_pushfstring(bvm *vm, const char *formato, ...);}

\foreignlanguage{spanish}{Empuja la cadena formateada en la pila virtual. El parámetro
}\textstyleSourceText{\foreignlanguage{spanish}{formato}}\foreignlanguage{spanish}{ es una cadena formateada que
contiene el texto que se insertará en la pila, y el parámetro
}\textstyleSourceText{\foreignlanguage{spanish}{formato}}\foreignlanguage{spanish}{ contiene una etiqueta, que puede
ser reemplazada por el valor especificado por el parámetro adicional subsiguiente y formateada según sea necesario. De
acuerdo con la etiqueta de la cadena
}\textstyleSourceText{\foreignlanguage{spanish}{formato}}\foreignlanguage{spanish}{, se pueden requerir una serie de
parámetros adicionales, y cada parámetro adicional reemplazará la etiqueta
}\textstyleSourceText{\foreignlanguage{spanish}{\%}}\foreignlanguage{spanish}{ correspondiente en el parámetro
}\textstyleSourceText{\foreignlanguage{spanish}{formato}}\foreignlanguage{spanish}{.}


\bigskip

\begin{center}
\tablefirsthead{\centering{\selectlanguage{spanish}\bfseries especificador} &
{\selectlanguage{spanish}\bfseries Descripción} &
~
\\}
\tablehead{\centering{\selectlanguage{spanish}\bfseries especificador} &
{\selectlanguage{spanish}\bfseries Descripción} &
~
\\}
\tabletail{}
\tablelasttail{}
\begin{supertabular}{m{5.1080003cm}m{5.1080003cm}m{5.1080003cm}}
\centering \textstyleSourceText{\foreignlanguage{spanish}{d}} &
{\selectlanguage{spanish} Formato como entero con signo decimal (los números positivos no generan signo)} &
~
\\
\centering \textstyleSourceText{\foreignlanguage{spanish}{f}} &
{\selectlanguage{spanish} Número de punto flotante de precisión simple o doble con formato decimal} &
~
\\
\centering \textstyleSourceText{\foreignlanguage{spanish}{g}} &
{\selectlanguage{spanish} Número de punto flotante de precisión simple o doble con formato exponencial} &
~
\\
\centering \textstyleSourceText{\foreignlanguage{spanish}{s}} &
{\selectlanguage{spanish} Formatear como cadena} &
~
\\
\centering \textstyleSourceText{\foreignlanguage{spanish}{c}} &
{\selectlanguage{spanish} Formatear como un solo carácter} &
~
\\
\centering \textstyleSourceText{\foreignlanguage{spanish}{p}} &
{\selectlanguage{spanish} Formatear como dirección de puntero} &
~
\\
\centering \textstyleSourceText{\foreignlanguage{spanish}{\%}} &
\foreignlanguage{spanish}{Escapado como carácter
}\textstyleSourceText{\foreignlanguage{spanish}{\%}}\foreignlanguage{spanish}{ (sin parámetro)} &
~
\\
\end{supertabular}
\end{center}
\foreignlanguage{spanish}{\textit{Tabla 12: Descripción del parámetro de la etiqueta
}}\textstyleSourceText{\foreignlanguage{spanish}{formato}}


\bigskip

\foreignlanguage{spanish}{La función
}\textstyleSourceText{\foreignlanguage{spanish}{be\_pushfstring}}\foreignlanguage{spanish}{ es similar a la función
estándar de C }\textstyleSourceText{\foreignlanguage{spanish}{printf}}\foreignlanguage{spanish}{, pero la función de
formato de cadenas es relativamente básica y no admite operaciones como personalizar el ancho y los lugares decimales.
Un ejemplo típico es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
be\_pushfstring(vm, {\textquotedbl}\%s: \%d{\textquotedbl}, {\textquotedbl}hola{\textquotedbl}, 12); // ¡Bien,
funciona!}

{\selectlanguage{spanish}\ttfamily
be\_pushfstring(vm, {\textquotedbl}\%s: \%.5d{\textquotedbl}, {\textquotedbl}hola{\textquotedbl}, 12); // Error, el
ancho especificado no es compatible.}


\bigskip

\foreignlanguage{spanish}{Esto significa que
}\textstyleSourceText{\foreignlanguage{spanish}{be\_pushfstring}}\foreignlanguage{spanish}{ solo puede realizar
operaciones de formateo simples. Si no se pueden cumplir los requisitos, se recomienda utilizar cadenas con formato
}\textstyleSourceText{\foreignlanguage{spanish}{sprintf}}\foreignlanguage{spanish}{ para las operaciones.}


\bigskip

{\selectlanguage{spanish}\ttfamily
void be\_pushvalue(bvm *vm, int index);}

\foreignlanguage{spanish}{Empuja el valor con el índice
}\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ en la parte superior de la pila
virtual.}


\bigskip

{\selectlanguage{spanish}\ttfamily
void be\_pushntvclosure(bvm *vm, bntvfunc f, int nupvals);}

\foreignlanguage{spanish}{Empuja un cierre nativo en la parte superior de la pila virtual. El parámetro
}\textstyleSourceText{\foreignlanguage{spanish}{f}}\foreignlanguage{spanish}{ es el puntero de función C del cierre
nativo, y }\textstyleSourceText{\foreignlanguage{spanish}{nupvals}}\foreignlanguage{spanish}{ es el número de valor
superior del cierre.}


\bigskip

{\selectlanguage{spanish}\ttfamily
void be\_pushntvfunction(bvm *vm, bntvfunc f);}

\foreignlanguage{spanish}{Empuja una función nativa en la parte superior de la pila virtual y el parámetro
}\textstyleSourceText{\foreignlanguage{spanish}{f}}\foreignlanguage{spanish}{ es el puntero de la función nativa.}


\bigskip

{\selectlanguage{spanish}\ttfamily
void be\_pushclass(bvm *vm, const char *name, const bnfuncinfo *lib);}

\foreignlanguage{spanish}{Empuja una clase nativa en la parte superior de la pila virtual. El parámetro
}\textstyleSourceText{\foreignlanguage{spanish}{name}}\foreignlanguage{spanish}{ es el nombre de la clase nativa y el
parámetro }\textstyleSourceText{\foreignlanguage{spanish}{lib}}\foreignlanguage{spanish}{ es la descripción del
atributo de la clase nativa.}


\bigskip

{\selectlanguage{spanish}\ttfamily
void be\_pushcomptr(bvm *vm, void *ptr);}

\foreignlanguage{spanish}{Empuja un puntero general en la parte superior de la pila virtual. El puntero general
}\textstyleSourceText{\foreignlanguage{spanish}{ptr}}\foreignlanguage{spanish}{ apunta a una determinada área de datos
de C. Dado que el recolector de elementos no utilizados de Berry no mantiene el contenido señalado por este puntero,
los usuarios deben mantener el ciclo de vida de los datos ellos mismos.}


\bigskip

{\selectlanguage{spanish}\ttfamily
void* be\_pushbytes(bvm *vm, const void *buf, size\_t len);}

\foreignlanguage{spanish}{Empuja un búfer }\textstyleSourceText{\foreignlanguage{spanish}{bytes
()}}\foreignlanguage{spanish}{ que comience en la posición
}\textstyleSourceText{\foreignlanguage{spanish}{buf}}\foreignlanguage{spanish}{ y de tamaño
}\textstyleSourceText{\foreignlanguage{spanish}{len}}\foreignlanguage{spanish}{. El búfer se copia en la memoria
asignada de Berry, no necesita mantener el búfer válido después de esta llamada.}


\bigskip

{\selectlanguage{spanish}\ttfamily
bbool be\_pushiter(bvm *vm, int index);}

{\selectlanguage{spanish}
Empuja un iterador en la parte superior de la pila virtual.}


\bigskip

\foreignlanguage{spanish}{La función
}\textstyleSourceText{\foreignlanguage{spanish}{be\_pusherror}}\foreignlanguage{spanish}{ inserta un mensaje de error
en la parte superior de la pila. Después de ejecutar el FFI, el intérprete volverá directamente a la posición que puede
manejar el error, y el código inmediatamente siguiente no se ejecutará. El prototipo de función es:}

{\selectlanguage{spanish}\ttfamily
void be\_pusherror(bvm *vm, const char *msg);}


\bigskip

\foreignlanguage{spanish}{El parámetro }\textstyleSourceText{\foreignlanguage{spanish}{vm}}\foreignlanguage{spanish}{ es
el puntero de la instancia de la máquina virtual;
}\textstyleSourceText{\foreignlanguage{spanish}{msg}}\foreignlanguage{spanish}{ es la cadena que contiene la
información del error.}

\foreignlanguage{spanish}{Mueve el valor en el índice
}\textstyleSourceText{\foreignlanguage{spanish}{desde}}\foreignlanguage{spanish}{ a la posición del índice
}\textstyleSourceText{\foreignlanguage{spanish}{hasta}}\foreignlanguage{spanish}{. Esta función no elimina el valor de
la posición del índice }\textstyleSourceText{\foreignlanguage{spanish}{desde}}\foreignlanguage{spanish}{, solo modifica
el valor de la posición del índice }\textstyleSourceText{\foreignlanguage{spanish}{hasta}}\foreignlanguage{spanish}{.}

\subsection[9.3 Tecnología de construcción en tiempo de compilación]{\selectlanguage{spanish} 9.3 Tecnología de
construcción en tiempo de compilación}
\hypertarget{RefHeadingToc359993639824055}{}{\selectlanguage{spanish}
La tecnología de construcción en tiempo de compilación se implementa principalmente mediante \textit{coc}, que se
encuentra en la ruta \textit{coc/coc} del directorio del código fuente del intérprete. La herramienta \textit{coc} se
usa para generar cadenas constantes y objetos constantes como código C, y se compilará en constantes cuando se compile
el intérprete. En principio, la herramienta \textit{coc} generará código a partir de la información de declaración del
objeto constante (de acuerdo con un formato específico). El proceso calculará automáticamente el valor Hash y generará
la tabla Hash.}

\foreignlanguage{spanish}{El archivo }\foreignlanguage{spanish}{\textit{Makefile}}\foreignlanguage{spanish}{ en el
directorio raíz del proyecto del intérprete compilará automáticamente esta herramienta y la ejecutará antes de compilar
el código fuente del intérprete. El contenido de
}\foreignlanguage{spanish}{\textit{Makefile}}\foreignlanguage{spanish}{ asegura que cuando se usa el comando
}\textstyleSourceText{\foreignlanguage{spanish}{make}}\foreignlanguage{spanish}{, el código para construir el objeto en
tiempo de compilación siempre se actualizará a través de la herramienta (si necesita actualizarse). El código para
construir objetos en tiempo de compilación se puede generar manualmente a través del comando
}\textstyleSourceText{\foreignlanguage{spanish}{make prebuild}}\foreignlanguage{spanish}{, que se almacena en la
carpeta }\foreignlanguage{spanish}{\textit{generate}}\foreignlanguage{spanish}{.}

\foreignlanguage{spanish}{La construcción en tiempo de compilación se puede activar o desactivar modificando la macro
}\textstyleSourceText{\foreignlanguage{spanish}{BE\_USE\_PRECOMPILED\_OBJECT}}\foreignlanguage{spanish}{. En cualquier
caso, se llama a la herramienta }\foreignlanguage{spanish}{\textit{coc}}\foreignlanguage{spanish}{ para generar códigos
de objetos constantes (los códigos no se usan cuando la construcción en tiempo de compilación está desactivada).}

\paragraph[Usar el comando coc]{\foreignlanguage{spanish}{Usar el comando
}\textstyleSourceText{\foreignlanguage{spanish}{coc}}}
\hypertarget{RefHeadingToc360013639824055}{}\foreignlanguage{spanish}{La herramienta
}\textstyleSourceText{\foreignlanguage{spanish}{coc}}\foreignlanguage{spanish}{ se utiliza para generar código para
objetos constantes. El formato del comando es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
tools/coc/coc -o {\textless}dst\_path{\textgreater} {\textless}src\_path(s){\textgreater} -c
{\textless}include\_path{\textgreater}}


\bigskip

\foreignlanguage{spanish}{La ruta de salida }\foreignlanguage{spanish}{\textit{dst\_path}}\foreignlanguage{spanish}{ se
utiliza para almacenar el código generado, y la ruta de origen
}\foreignlanguage{spanish}{\textit{src\_path}}\foreignlanguage{spanish}{ es una lista de rutas que deben escanearse en
busca del código fuente (utilice espacios para separar varias rutas).
}\textstyleSourceText{\foreignlanguage{spanish}{include\_path}}\foreignlanguage{spanish}{ contiene un archivo de
encabezado C escaneado para detectar directivas de compilación.
}\textstyleSourceText{\foreignlanguage{spanish}{coc}}\foreignlanguage{spanish}{ intenta compilar solo las constantes
necesarias. Dado que }\foreignlanguage{spanish}{\textit{generate}}\foreignlanguage{spanish}{ se usa como la ruta del
código generado en el código fuente del intérprete,
}\foreignlanguage{spanish}{\textit{dst\_path}}\foreignlanguage{spanish}{ debe ser
}\foreignlanguage{spanish}{\textit{generate}}\foreignlanguage{spanish}{. Tomando el proyecto de intérprete estándar
como ejemplo, el comando para usar la herramienta en
}\textstyleSourceText{\foreignlanguage{spanish}{map\_build}}\foreignlanguage{spanish}{ debe ser:}


\bigskip

{\selectlanguage{spanish}\ttfamily
tools/coc/coc -o generate default src -c default/berry\_conf.h}


\bigskip

{\selectlanguage{spanish}
El significado de este comando es: la ruta de salida es \textit{generate}, y la ruta de origen es \textit{src} y
\textit{default}.}

\paragraph[Ruta de salida]{\selectlanguage{spanish} Ruta de salida}
\hypertarget{RefHeadingToc360033639824055}{}{\selectlanguage{spanish}
Estrictamente hablando, la carpeta \textit{generate} utilizada como ruta de salida no se puede colocar en ningún lado,
debe almacenarse en un directorio principal que contenga la ruta. La ruta de inclusión se refiere a la ruta donde se
buscará el archivo de encabezado en el proyecto. Tomando el código fuente del intérprete estándar como ejemplo, la ruta
de inclusión es \textit{src} y \textit{default}. Por lo tanto, en el proyecto de intérprete estándar, la carpeta
\textit{generate} se almacena en el directorio raíz del código fuente del intérprete (el directorio principal de
\textit{src} y \textit{default}).}

{\selectlanguage{spanish}
El motivo de las reglas anteriores es que los siguientes códigos se utilizan en el código fuente del intérprete para
hacer referencia a objetos constantes:}


\bigskip

{\selectlanguage{spanish}\ttfamily
\#include {\textquotedbl}../generate/be\_fixed\_xxx.h{\textquotedbl}}


\bigskip

{\selectlanguage{spanish}
Si los lectores quieren definir objetos constantes por sí mismos, también necesitan usar dicho código para incluir los
archivos de encabezado correspondientes. Esta sección presentará cómo usar estas herramientas para definir y usar
objetos constantes.}

\subsubsection[9.4 Tabla de cadenas en tiempo de compilación]{\selectlanguage{spanish} 9.4 Tabla de cadenas en tiempo de
compilación}
\hypertarget{RefHeadingToc360053639824055}{}\foreignlanguage{spanish}{La tabla de cadenas en tiempo de compilación se
utiliza para almacenar cadenas constantes. Las cadenas constantes son objetos que son transparentes para el script. No
se crean ni destruyen cuando el intérprete se está ejecutando, pero siempre se almacenan como constantes en el segmento
de datos del programa del intérprete. Si necesita usar una cadena como cadena constante, puede agregar el prefijo
}\textstyleSourceText{\foreignlanguage{spanish}{be\_const\_str\_}}\foreignlanguage{spanish}{ delante de la cadena en el
código fuente del intérprete, y la declaración se puede colocar en cualquier parte del archivo fuente (incluidos los
comentarios). Por ejemplo, para crear una cadena constante con el contenido
}\textstyleSourceText{\foreignlanguage{spanish}{{\textquotedbl}cadena{\textquotedbl}}}\foreignlanguage{spanish}{, debe
declarar el símbolo }\textstyleSourceText{\foreignlanguage{spanish}{be\_const\_str\_cadena}}\foreignlanguage{spanish}{
en el archivo fuente, y este símbolo también es el nombre de la variable que hace referencia a la cadena constante en
el código C.}

{\selectlanguage{spanish}
Todas las palabras clave crearán cadenas constantes. Si modifica el código relacionado con la palabra clave en el
intérprete de Berry, también se debe modificar el código correspondiente en \textit{coc}.}

\foreignlanguage{spanish}{Si la cadena contiene símbolos especiales, se {\textquotedbl}escapean{\textquotedbl}
automáticamente como }\textstyleSourceText{\foreignlanguage{spanish}{\_XHH}}\foreignlanguage{spanish}{, donde
}\textstyleSourceText{\foreignlanguage{spanish}{HH}}\foreignlanguage{spanish}{ es la representación hexadecimal (en
mayúsculas) del carácter. Por ejemplo
}\textstyleSourceText{\foreignlanguage{spanish}{{\textquotedbl}}}\foreignlanguage{spanish}{ está representado por
}\textstyleSourceText{\foreignlanguage{spanish}{\_X3A}}\foreignlanguage{spanish}{. Esta representación es biactiva, por
lo que es fácil convertirla a la cadena original y desde ella.}

\paragraph[Usar cadena constante]{\selectlanguage{spanish} Usar cadena constante}
\hypertarget{RefHeadingToc360073639824055}{}{\selectlanguage{spanish}
Normalmente, no hay necesidad de declarar cadenas constantes manualmente, ni de usarlas manualmente. Si realmente
necesita llamar a la cadena constante manualmente, incluya el archivo de encabezado \textit{be\_constobj.h} para usar
todas las variables de cadena constante (este archivo de encabezado tiene declaraciones para todas las cadenas
constantes). El uso típico de cadenas constantes es construir objetos en tiempo de compilación. La declaración y
definición de cadenas constantes en este proceso son manejadas automáticamente por la herramienta.}

\foreignlanguage{spanish}{En cualquier caso, la función FFI
}\textstyleSourceText{\foreignlanguage{spanish}{be\_pushstring}}\foreignlanguage{spanish}{ debe usarse directamente
para crear una cadena. Cuando una cadena tiene una cadena constante, no creará repetidamente un nuevo objeto de cadena,
sino que usará directamente la cadena constante correspondiente.}

\foreignlanguage{spanish}{De forma predeterminada, todas las cadenas utilizadas se referencian en una tabla hash global
}\textstyleSourceText{\foreignlanguage{spanish}{m\_const\_string\_table}}\foreignlanguage{spanish}{. Sin embargo,
algunos proyectos pueden tener muchas variantes de compilación para las que no se necesitan algunos conjuntos de
cadenas. Si todas las constantes de cadena se almacenan en todas las variantes, esto crea una pérdida de tamaño de
flash. Por esta razón, algunas cadenas pueden declararse como cadenas {\textquotedbl}débiles{\textquotedbl} en el
sentido de tener una referencia {\textquotedbl}débil{\textquotedbl}. En tal caso, la constante de cadena se declara en
código C, pero no se incluye en el objeto de mapa global. Esto significa que el enlazador puede optar por no incluir
las constantes de cadena si ningún código hace referencia a ellas. La desventaja es que si crea dinámicamente un objeto
de cadena con el mismo valor, se crea un nuevo objeto en la memoria (mientras que no lo haría para una constante de
cadena normal). Para indicar cadenas débiles, use el modificador
}\textstyleSourceText{\foreignlanguage{spanish}{strings: weak}}\foreignlanguage{spanish}{ (ver más abajo).}

\subsubsection[9.5 Construir objeto en tiempo de compilación]{\selectlanguage{spanish} 9.5 Construir objeto en tiempo de
compilación}
\hypertarget{RefHeadingToc360093639824055}{}\foreignlanguage{spanish}{Los objetos construidos en tiempo de compilación
también se denominan objetos constantes. La estructura de datos de estos objetos se construye cuando se compila el
intérprete y no se puede modificar en tiempo de ejecución.
}\textstyleSourceText{\foreignlanguage{spanish}{map\_build}}\foreignlanguage{spanish}{ define un conjunto de reglas de
declaración en la herramienta para generar código C para objetos constantes. La información de declaración del objeto
constante se almacena directamente en el archivo fuente
(}\foreignlanguage{spanish}{\textit{*.c}}\foreignlanguage{spanish}{). Para distinguirlo de otro contenido, se debe
incluir una información de declaración completa en el siguiente código de arranque:}


\bigskip

{\selectlanguage{spanish}\ttfamily
@const\_object\_info\_begin}

{\selectlanguage{spanish}\ttfamily
@const\_object\_info\_end}


\bigskip

\foreignlanguage{spanish}{La información de declaración de objeto constante no se ajusta a la sintaxis del lenguaje C,
por lo que debe colocarse en un comentario de varias líneas (incluido con
}\textstyleSourceText{\foreignlanguage{spanish}{/* */}}\foreignlanguage{spanish}{). Todos los objetos constantes tienen
la misma forma de declaración. La estructura de declaración de un objeto constante se denomina {\textquotedbl}bloque de
declaración de objeto{\textquotedbl}, que se compone de:}


\bigskip

{\selectlanguage{spanish}\ttfamily
type object\_name (attributes) \{}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ member\_fields}

{\selectlanguage{spanish}\ttfamily
\}}


\bigskip

\textstyleSourceText{\foreignlanguage{spanish}{type}}\foreignlanguage{spanish}{ es el tipo de objeto constante, puede
ser }\textstyleSourceText{\foreignlanguage{spanish}{map}}\foreignlanguage{spanish}{,
}\textstyleSourceText{\foreignlanguage{spanish}{class}}\foreignlanguage{spanish}{,
}\textstyleSourceText{\foreignlanguage{spanish}{module}}\foreignlanguage{spanish}{ o
}\textstyleSourceText{\foreignlanguage{spanish}{vartab}}\foreignlanguage{spanish}{.
}\textstyleSourceText{\foreignlanguage{spanish}{object\_name}}\foreignlanguage{spanish}{ es el nombre de la variable
del objeto constante en lenguaje C.
}\textstyleSourceText{\foreignlanguage{spanish}{attributes}}\foreignlanguage{spanish}{ es la lista de atributos de los
objetos constantes. Un atributo se compone de nombre de atributo y valor de atributo. El nombre del atributo y el valor
del atributo están separados por punto y coma, y varios atributos están separados por comas. Por ejemplo, la lista de
atributos }\textstyleSourceText{\foreignlanguage{spanish}{scope: global, name: map}}\foreignlanguage{spanish}{
significa que el atributo }\textstyleSourceText{\foreignlanguage{spanish}{scope}}\foreignlanguage{spanish}{ de un
objeto constante es }\textstyleSourceText{\foreignlanguage{spanish}{global}}\foreignlanguage{spanish}{, y el atributo
}\textstyleSourceText{\foreignlanguage{spanish}{name}}\foreignlanguage{spanish}{ es
}\textstyleSourceText{\foreignlanguage{spanish}{map}}\foreignlanguage{spanish}{. También
}\textstyleSourceText{\foreignlanguage{spanish}{strings: weak}}\foreignlanguage{spanish}{ indica que se debe generar
constantes de cadena débiles para los nombres de los campos de miembros o cualquier constante de cadena.
}\textstyleSourceText{\foreignlanguage{spanish}{member\_fields}}\foreignlanguage{spanish}{ es la lista de dominios
miembros de objetos constantes. Un miembro se compone de nombre y valor, separados por comas. Cada línea puede declarar
un miembro y varios miembros deben declararse en varias líneas.}

\foreignlanguage{spanish}{La herramienta }\foreignlanguage{spanish}{\textbf{coc}}\foreignlanguage{spanish}{ utiliza
expresiones regulares para analizar el bloque de declaración de objetos. En el proceso de análisis, primero se
comparará todo el bloque de declaración del objeto y se comparará la información {\textquotedbl}tipo{\textquotedbl} y
{\textquotedbl}nombre\_del\_objeto{\textquotedbl}. Para la información de
}\textstyleSourceText{\foreignlanguage{spanish}{atributos}}\foreignlanguage{spanish}{ y
}\textstyleSourceText{\foreignlanguage{spanish}{member\_fields}}\foreignlanguage{spanish}{, sae hará un análisis
adicional. Para facilitar la implementación, la herramienta no tiene requisitos estrictos sobre la sintaxis del bloque
de declaración de objetos y carece de un mecanismo completo de manejo de errores, por lo que debe asegurarse de que la
sintaxis sea correcta al escribir el bloque de declaración de objetos.}

{\selectlanguage{spanish}
Para facilitar la comprensión, ilustramos con una clase constante simple:}


\bigskip

{\selectlanguage{spanish}\ttfamily
/* @const\_object\_info\_begin}

{\selectlanguage{spanish}\ttfamily
class be\_class\_map (scope: global, name: map) \{}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ .data, var}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ init, func(m\_init)}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ tostring, func(m\_tostring)}

{\selectlanguage{spanish}\ttfamily
\}}

{\selectlanguage{spanish}\ttfamily
@const\_object\_info\_end */}

{\selectlanguage{spanish}\ttfamily
\#include {\textquotedbl}../generate/be\_fixed\_be\_class\_map.h{\textquotedbl}}


\bigskip

\foreignlanguage{spanish}{En este ejemplo, la información de declaración de toda la clase constante está en el
comentario del lenguaje C, por lo que no afectará la compilación del código C. El bloque de declaración de objetos se
coloca entre }\textstyleSourceText{\foreignlanguage{spanish}{@const\_object\_info\_begin}}\foreignlanguage{spanish}{ y
}\textstyleSourceText{\foreignlanguage{spanish}{@const\_object\_info\_end}}\foreignlanguage{spanish}{ para garantizar
que la herramienta }\foreignlanguage{spanish}{\textbf{coc}}\foreignlanguage{spanish}{ detecte el bloque de declaración
de objetos.}

\foreignlanguage{spanish}{Dado que es una declaración de clase constante, el valor de
}\foreignlanguage{spanish}{\textit{tipo}}\foreignlanguage{spanish}{ en el bloque de declaración de objeto es
}\textstyleSourceText{\foreignlanguage{spanish}{class}}\foreignlanguage{spanish}{, y
}\textstyleSourceText{\foreignlanguage{spanish}{be\_class\_map}}\foreignlanguage{spanish}{ es el nombre de variable del
objeto constante en el código C. Se declaran dos atributos en la lista de atributos del objeto (la parte encerrada
entre paréntesis), y el significado de estos atributos se presentará en la sección {\textquotedbl}Clase de construcción
en tiempo de compilación{\textquotedbl} de esta sección. Tres miembros están definidos en la lista de miembros entre
llaves, varios miembros están separados por saltos de línea y el nombre del miembro y el valor del miembro están
separados por una coma. Existen varios formatos legales para los nombres de miembros:}

\liststyleLxviii
\begin{itemize}
\item {\selectlanguage{spanish}
Formato de nombre de variable Berry: comienza con una letra o guión bajo, seguido de varias letras, guiones bajos o
números.}
\item \foreignlanguage{spanish}{Utilice
``}\textstyleSourceText{\foreignlanguage{spanish}{.}}\foreignlanguage{spanish}{{}'' como primer carácter, seguido de
letras, guiones bajos o números.}
\item \foreignlanguage{spanish}{Operadores sobrecargables, como
``}\textstyleSourceText{\foreignlanguage{spanish}{+}}\foreignlanguage{spanish}{{}'',
``}\textstyleSourceText{\foreignlanguage{spanish}{{}-}}\foreignlanguage{spanish}{{}'' y
``}\textstyleSourceText{\foreignlanguage{spanish}{{\textless}{\textless}}}\foreignlanguage{spanish}{{}'', etc.}


\bigskip
\end{itemize}
{\selectlanguage{spanish}
El valor de un miembro puede ser de los siguientes tipos:}

\liststyleLxix
\begin{itemize}
\item \textstyleSourceText{\foreignlanguage{spanish}{var}}\foreignlanguage{spanish}{: Este símbolo se compilará en un
objeto entero (}\textstyleSourceText{\foreignlanguage{spanish}{be\_const\_var}}\foreignlanguage{spanish}{), y el valor
del objeto entero se incrementa automáticamente desde
}\textstyleSourceText{\foreignlanguage{spanish}{0}}\foreignlanguage{spanish}{.
}\textstyleSourceText{\foreignlanguage{spanish}{var}}\foreignlanguage{spanish}{ está diseñado para la declaración de
variables miembro en la clase, y es automática La función de numeración se utiliza para realizar el número de serie de
las variables miembro.}
\item \textstyleSourceText{\foreignlanguage{spanish}{func(símbolo)}}\foreignlanguage{spanish}{: Declara funciones
miembro nativas o métodos de objetos constantes. El símbolo se compilará en una función nativa con el valor
(}\textstyleSourceText{\foreignlanguage{spanish}{be\_const\_func}}\foreignlanguage{spanish}{),
}\textstyleSourceText{\foreignlanguage{spanish}{symbol}}\foreignlanguage{spanish}{ es el puntero de función nativo
correspondiente al miembro. }\textstyleSourceText{\foreignlanguage{spanish}{m\_init}}\foreignlanguage{spanish}{ y
}\textstyleSourceText{\foreignlanguage{spanish}{m\_tostring}}\foreignlanguage{spanish}{ en el ejemplo son dos funciones
nativas.}
\item \textstyleSourceText{\foreignlanguage{spanish}{closure (símbolo)}}\foreignlanguage{spanish}{: Declara funciones o
métodos miembro de bytecode precompilados de objetos constantes. El símbolo se compilará en una función nativa con el
valor (}\textstyleSourceText{\foreignlanguage{spanish}{be\_const\_closure}}\foreignlanguage{spanish}{),
}\textstyleSourceText{\foreignlanguage{spanish}{símbolo}}\foreignlanguage{spanish}{ es el nombre de la función
solidificada. Ver }\textstyleSourceText{\foreignlanguage{spanish}{módulo solidificar}}\foreignlanguage{spanish}{ para
saber cómo solidificar objetos.}
\item \textstyleSourceText{\foreignlanguage{spanish}{nil()}}\foreignlanguage{spanish}{: este símbolo se compilará en un
valor nulo (}\textstyleSourceText{\foreignlanguage{spanish}{be\_const\_nil}}\foreignlanguage{spanish}{).}
\item \textstyleSourceText{\foreignlanguage{spanish}{int(valor)}}\foreignlanguage{spanish}{: este símbolo se compilará
en un objeto entero (}\textstyleSourceText{\foreignlanguage{spanish}{be\_const\_int}}\foreignlanguage{spanish}{), el
valor del objeto entero es }\textstyleSourceText{\foreignlanguage{spanish}{valor}}\foreignlanguage{spanish}{.}
\item \textstyleSourceText{\foreignlanguage{spanish}{real(valor)}}\foreignlanguage{spanish}{: Este símbolo se compilará
en un número real (}\textstyleSourceText{\foreignlanguage{spanish}{be\_const\_real}}\foreignlanguage{spanish}{), el
valor del objeto de número real es }\textstyleSourceText{\foreignlanguage{spanish}{valor}}\foreignlanguage{spanish}{.}
\item \textstyleSourceText{\foreignlanguage{spanish}{comptr(valor)}}\foreignlanguage{spanish}{: Este símbolo se
compilará en un puntero objeto
}\foreignlanguage{spanish}{(}\textstyleSourceText{\foreignlanguage{spanish}{be\_const\_comptr}}\foreignlanguage{spanish}{),
el valor del puntero es }\textstyleSourceText{\foreignlanguage{spanish}{valor}}\foreignlanguage{spanish}{ y se puede
utilizar para pasar la dirección de una estructura global de C.}
\item \textstyleSourceText{\foreignlanguage{spanish}{class (símbolo)}}\foreignlanguage{spanish}{: este símbolo se
compilará en un objeto de clase
(}\textstyleSourceText{\foreignlanguage{spanish}{be\_const\_class}}\foreignlanguage{spanish}{).
}\textstyleSourceText{\foreignlanguage{spanish}{símbolo}}\foreignlanguage{spanish}{ es un puntero a este tipo de
objeto, y el puntero debe apuntar a un objeto de tipo constante.}
\item \textstyleSourceText{\foreignlanguage{spanish}{module (símbolo)}}\foreignlanguage{spanish}{: este símbolo se
compilará en un objeto de módulo
(}\textstyleSourceText{\foreignlanguage{spanish}{be\_const\_module}}\foreignlanguage{spanish}{).
}\textstyleSourceText{\foreignlanguage{spanish}{símbolo}}\foreignlanguage{spanish}{ es un puntero al objeto del módulo,
y el puntero debe apuntar a un objeto de módulo constante.}
\item \textstyleSourceText{\foreignlanguage{spanish}{ctype\_func(símbolo)}}\foreignlanguage{spanish}{: Este símbolo se
compilará en una función nativa
(}\textstyleSourceText{\foreignlanguage{spanish}{be\_const\_ctype\_func}}\foreignlanguage{spanish}{).
}\textstyleSourceText{\foreignlanguage{spanish}{símbolo}}\foreignlanguage{spanish}{ es un puntero al mapeo C
definición. Esta característica es utilizada por }\textstyleDefinition{\foreignlanguage{spanish}{berry\_mapping}}


\bigskip
\end{itemize}
\foreignlanguage{spanish}{Para usar el objeto
}\textstyleSourceText{\foreignlanguage{spanish}{be\_class\_map}}\foreignlanguage{spanish}{, debemos incluir el archivo
de encabezado correspondiente en el código C para garantizar que el objeto se compilará. La práctica habitual es
incluir el archivo de cabecera correspondiente cerca del bloque de declaración del objeto. En el ejemplo, la línea 8 lo
contiene. El archivo de encabezado correspondiente se puede usar para construir objetos
}\textstyleSourceText{\foreignlanguage{spanish}{be\_class\_map}}\foreignlanguage{spanish}{ en tiempo de compilación.}

\foreignlanguage{spanish}{Después de procesarlo con la herramienta
}\foreignlanguage{spanish}{\textbf{coc}}\foreignlanguage{spanish}{, cada bloque de declaración de objeto se compilará
en un archivo de encabezado llamado
}\foreignlanguage{spanish}{\textit{be\_fixed\_be\_xxx.h}}\foreignlanguage{spanish}{, donde
}\foreignlanguage{spanish}{\textit{xxx}}\foreignlanguage{spanish}{ es el nombre de la variable C del objeto. Para
compilar objetos constantes en código C, debemos incluir los archivos de encabezado correspondientes. Por lo general,
se recomienda incluir los archivos de encabezado correspondientes cerca del bloque de declaración de objetos. La octava
línea del ejemplo contiene }\foreignlanguage{spanish}{\textit{be\_fixed\_be\_class\_map.h}}\foreignlanguage{spanish}{
para construir el objeto }\textstyleSourceText{\foreignlanguage{spanish}{be\_class\_map}}\foreignlanguage{spanish}{ en
tiempo de compilación.}

\paragraph[Construir mapa en tiempo de compilación]{\selectlanguage{spanish} Construir mapa en tiempo de compilación}
\hypertarget{RefHeadingToc360113639824055}{}\foreignlanguage{spanish}{Los mapas construidos en tiempo de compilación
también son objetos }\textstyleSourceText{\foreignlanguage{spanish}{map}}\foreignlanguage{spanish}{ constantes. Por lo
general, no se declaran directamente mediante bloques de declaración de objetos, sino que se declaran en otras
estructuras de construcción en tiempo de compilación. Al construir el
}\textstyleSourceText{\foreignlanguage{spanish}{map}}\foreignlanguage{spanish}{ constante, la información del tipo de
objeto constante debe ser }\textstyleSourceText{\foreignlanguage{spanish}{map}}\foreignlanguage{spanish}{, que admite
un atributo }\textstyleSourceText{\foreignlanguage{spanish}{scope}}\foreignlanguage{spanish}{. Cuando el valor del
atributo 'scope' es 'local', el objeto constante es 'estático', cuando el atributo es 'global', es 'externo', y el
valor de este atributo es 'local' por defecto. Los
}\textstyleSourceText{\foreignlanguage{spanish}{member\_fields}}\foreignlanguage{spanish}{ del objeto
}\textstyleSourceText{\foreignlanguage{spanish}{map}}\foreignlanguage{spanish}{ constante admiten especificaciones
comunes de nombre de miembro/valo, y los valores de miembro solo se almacenan como datos sin una interpretación
especial. El siguiente es un ejemplo del uso del bloque de declaración de objetos para declarar directamente un objeto
}\textstyleSourceText{\foreignlanguage{spanish}{map}}\foreignlanguage{spanish}{ constante:}


\bigskip

{\selectlanguage{spanish}\ttfamily
map map\_name (scope: local/global) \{}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ init, func(m\_init)}

{\selectlanguage{spanish}\ttfamily
\}}

\paragraph[Construcción de Clases en tiempo de compilación]{\selectlanguage{spanish} Construcción de Clases en tiempo de
compilación}
\hypertarget{RefHeadingToc360133639824055}{}\foreignlanguage{spanish}{Para construir una clase en tiempo de compilación,
use el bloque de declaración de objetos }\foreignlanguage{spanish}{para declarar, y la información de tipo del objeto
es }\textstyleSourceText{\foreignlanguage{spanish}{class}}\foreignlanguage{spanish}{. Las propiedades declaradas de
este objeto son }\textstyleSourceText{\foreignlanguage{spanish}{scope}}\foreignlanguage{spanish}{ y
}\textstyleSourceText{\foreignlanguage{spanish}{name}}\foreignlanguage{spanish}{.
}\textstyleSourceText{\foreignlanguage{spanish}{scope}}\foreignlanguage{spanish}{ es el alcance de la variable C del
objeto de declaración de atributos, cuando el valor es
}\textstyleSourceText{\foreignlanguage{spanish}{local}}\foreignlanguage{spanish}{ (predeterminado), el alcance es
}\textstyleSourceText{\foreignlanguage{spanish}{static}}\foreignlanguage{spanish}{, cuando es
}\textstyleSourceText{\foreignlanguage{spanish}{global}}\foreignlanguage{spanish}{, el alcance es
}\textstyleSourceText{\foreignlanguage{spanish}{extern}}\foreignlanguage{spanish}{;
}\textstyleSourceText{\foreignlanguage{spanish}{name}}\foreignlanguage{spanish}{ es el valor del atributo es ese nombre
de clase, la clase anónima puede omitir este parámetro. Dado que la lista de atributos de una clase solo almacena
métodos e índices de variables miembro, los
}\textstyleSourceText{\foreignlanguage{spanish}{member\_fields}}\foreignlanguage{spanish}{ de la clase construida en
tiempo de compilación solo pueden usar los valores
}\textstyleSourceText{\foreignlanguage{spanish}{var}}\foreignlanguage{spanish}{ y
}\textstyleSourceText{\foreignlanguage{spanish}{func()}}\foreignlanguage{spanish}{. Un bloque de declaración de clase
de construcción simple en tiempo de compilación es:}


\bigskip

{\selectlanguage{spanish}\ttfamily
class be\_class\_map (scope: global, name: map) \{}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ .data, var}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ init, func(m\_init)}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ tostring, func(m\_tostring)}

{\selectlanguage{spanish}\ttfamily
\}}

\paragraph[Construcción de Módulos en tiempo de compilación]{\selectlanguage{spanish} Construcción de Módulos en tiempo
de compilación}
\hypertarget{RefHeadingToc360153639824055}{}\foreignlanguage{spanish}{La información de tipo del bloque de declaración
del bloque de construcción en tiempo de compilación es
}\textstyleSourceText{\foreignlanguage{spanish}{module}}\foreignlanguage{spanish}{.}


\bigskip

{\selectlanguage{spanish}\ttfamily
module math (scope: global) \{}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ sin, func(m\_sin)}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ cos, func(m\_cos)}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ pi, real(M\_PI)}

{\selectlanguage{spanish}\ttfamily
\}}

\paragraph[Construcción de un dominio integrado en tiempo de compilación]{\selectlanguage{spanish} Construcción de un
dominio integrado en tiempo de compilación}
\hypertarget{RefHeadingToc360173639824055}{}{\selectlanguage{spanish}\ttfamily
vartab m\_builtin (scope: local) \{}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ assert, func(l\_assert)}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ print, func(l\_print)}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ list, class(be\_class\_list)}

{\selectlanguage{spanish}\ttfamily
\}}

\clearpage\section[Apéndice A: Definición de la gramática]{Apéndice A: \foreignlanguage{spanish}{Definición de la
gramática}}
\hypertarget{RefHeadingToc360193639824055}{}
\bigskip

{\selectlanguage{spanish}
Este capítulo dará algunas definiciones gramaticales relacionadas con Berry. Usamos \textbf{Extended Backus Normal Form}
(EBNF) para definir o expresar la gramática. No usamos la gramática EBNF estricta para definir, pero hicimos muchas
simplificaciones, pero estas simplificaciones no afectarán la comprensión de la gramática por parte de los lectores.}

{\selectlanguage{spanish}
La definición EBNF de la gramática del lenguaje Berry es la siguiente:}


\bigskip

{\selectlanguage{spanish}\ttfamily
(* program define *)}

{\selectlanguage{spanish}\ttfamily
program = block;}

{\selectlanguage{spanish}\ttfamily
(* block define *)}

{\selectlanguage{spanish}\ttfamily
block = \{statement\};}

{\selectlanguage{spanish}\ttfamily
(* statement define *)}

{\selectlanguage{spanish}\ttfamily
statement = class\_stmt {\textbar} func\_stmt {\textbar} var\_stmt {\textbar} if\_stmt {\textbar} while\_stmt
{\textbar}}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ \ for\_stmt {\textbar} break\_stmt {\textbar} return\_stmt {\textbar} expr\_stmt {\textbar} import\_stmt
{\textbar}}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ \ try\_stmt {\textbar} throw\_stmt {\textbar} ';';}

{\selectlanguage{spanish}\ttfamily
if\_stmt = 'if' expr block \{'elif' expr block\} ['else' block] 'end';}

{\selectlanguage{spanish}\ttfamily
while\_stmt = 'while' expr block 'end';}

{\selectlanguage{spanish}\ttfamily
for\_stmt = 'for' ID ':' expr block 'end';}

{\selectlanguage{spanish}\ttfamily
break\_stmt = 'break' {\textbar} 'continue';}

{\selectlanguage{spanish}\ttfamily
return\_stmt = 'return' [expr];}

{\selectlanguage{spanish}\ttfamily
(* function define statement *)}

{\selectlanguage{spanish}\ttfamily
func\_stmt = 'def' ID func\_body;}

{\selectlanguage{spanish}\ttfamily
func\_body = '(' [arg\_field \{',' arg\_field\}] ')' block 'end';}

{\selectlanguage{spanish}\ttfamily
arg\_field = ['*'] ID;}

{\selectlanguage{spanish}\ttfamily
(* class define statement *)}

{\selectlanguage{spanish}\ttfamily
class\_stmt = 'class' ID [':' ID] class\_block 'end';}

{\selectlanguage{spanish}\ttfamily
class\_block = \{'var' ID \{',' ID\} {\textbar} 'static' ['var'] ID ['=' expr] \{',' ID ['=' expr] \} {\textbar}
'static' func\_stmt {\textbar} func\_stmt\};}

{\selectlanguage{spanish}\ttfamily
import\_stmt = 'import' (ID (['as' ID] {\textbar} \{',' ID\}) {\textbar} STRING 'as' ID);}

{\selectlanguage{spanish}\ttfamily
(* exceptional handling statement *)}

{\selectlanguage{spanish}\ttfamily
try\_stmt = 'try' block except\_block \{except\_block\} 'end';}

{\selectlanguage{spanish}\ttfamily
except\_block = except\_stmt block;}

{\selectlanguage{spanish}\ttfamily
except\_stmt = 'except' (expr \{',' expr\} {\textbar} '..') ['as' ID [',' ID]];}

{\selectlanguage{spanish}\ttfamily
throw\_stmt = 'raise' expr [',' expr];}

{\selectlanguage{spanish}\ttfamily
(* variable define statement *)}

{\selectlanguage{spanish}\ttfamily
var\_stmt = 'var' ID ['=' expr] \{',' ID ['=' expr]\};}

{\selectlanguage{spanish}\ttfamily
(* expression define *)}

{\selectlanguage{spanish}\ttfamily
expr\_stmt = expr [assign\_op expr];}

{\selectlanguage{spanish}\ttfamily
expr = suffix\_expr {\textbar} unop expr {\textbar} expr binop expr {\textbar} range\_expr {\textbar} cond\_expr;}

{\selectlanguage{spanish}\ttfamily
cond\_expr = expr '?' expr ':' expr; (* conditional expression *)}

{\selectlanguage{spanish}\ttfamily
assign\_op = '=' {\textbar} '+=' {\textbar} '-=' {\textbar} '*=' {\textbar} '/=' {\textbar}}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ \ \ \ \ {}'\%=' {\textbar} '\&=' {\textbar} '{\textbar}=' {\textbar} '\^{}=' {\textbar}
'{\textless}{\textless}=' {\textbar} '{\textgreater}{\textgreater}=';}

{\selectlanguage{spanish}\ttfamily
binop = '{\textless}' {\textbar} '{\textless}=' {\textbar} '==' {\textbar} '!=' {\textbar} '{\textgreater}' {\textbar}
'{\textgreater}=' {\textbar} '{\textbar}{\textbar}' {\textbar} '\&\&' {\textbar}}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ {}'{\textless}{\textless}' {\textbar} '{\textgreater}{\textgreater}' {\textbar} '\&' {\textbar}
'{\textbar}' {\textbar} '\^{}' {\textbar} '+' {\textbar} '-' {\textbar} '*' {\textbar} '/' {\textbar} '\%';}

{\selectlanguage{spanish}\ttfamily
range\_expr = expr '..' [expr]}

{\selectlanguage{spanish}\ttfamily
unop = '-' {\textbar} '!' {\textbar} '\~{}';}

{\selectlanguage{spanish}\ttfamily
suffix\_expr = primary\_expr \{call\_expr {\textbar} ('.' ID) {\textbar} '[' expr ']'\};}

{\selectlanguage{spanish}\ttfamily
primary\_expr = '(' expr ')' {\textbar} simple\_expr {\textbar} list\_expr {\textbar} map\_expr {\textbar} anon\_func
{\textbar} lambda\_expr;}

{\selectlanguage{spanish}\ttfamily
simple\_expr = \ INTEGER {\textbar} REAL {\textbar} STRING {\textbar} ID {\textbar} 'true' {\textbar} 'false' {\textbar}
'nil';}

{\selectlanguage{spanish}\ttfamily
call\_expr = '(' [expr \{',' expr\}] ')';}

{\selectlanguage{spanish}\ttfamily
list\_expr = '[' \{expr ','\} [expr] ']';}

{\selectlanguage{spanish}\ttfamily
map\_expr = '\{' \{expr ':' expr ','\} [expr ':' expr] '\}';}

{\selectlanguage{spanish}\ttfamily
anon\_func = 'def' func\_body; (* anonymous function *)}

{\selectlanguage{spanish}\ttfamily
lambda\_expr = '/' [arg\_field \{',' arg\_field\}] {\textbar} \{arg\_field\}] '-{\textgreater}' expr;}


\bigskip

\foreignlanguage{spanish}{El formato EBNF estándar se puede encontrar en materiales relacionados. Aquí hay una
explicación de los detalles que necesitan atención al leer la gramática anterior. Los símbolos que han aparecido a la
izquierda del signo igual son símbolos no terminales, y los demás son símbolos terminales. El terminador encerrado
entre comillas }\textstyleSourceText{\foreignlanguage{spanish}{{}'}}\foreignlanguage{spanish}{ es una cadena fija, que
suele ser una palabra clave u operador de idioma. Hay varios terminadores que son inconvenientes para describir
directamente en EBNF: }\textstyleSourceText{\foreignlanguage{spanish}{INTEGER}}\foreignlanguage{spanish}{ representa el
valor nominal del entero; }\textstyleSourceText{\foreignlanguage{spanish}{REAL}}\foreignlanguage{spanish}{ representa
el valor nominal del número real; }\textstyleSourceText{\foreignlanguage{spanish}{STRING}}\foreignlanguage{spanish}{
representa el valor literal de cadena; }\textstyleSourceText{\foreignlanguage{spanish}{ID}}\foreignlanguage{spanish}{
representa el identificador. Estos terminadores se pueden definir mediante expresiones regulares:}

\liststyleLxx
\begin{itemize}
\item \textstyleSourceText{\foreignlanguage{spanish}{ENTERO}}\foreignlanguage{spanish}{:
}\textstyleSourceText{\foreignlanguage{spanish}{0x[a-fA-F0-9]+{\textbar}{\textbackslash}d+}}\foreignlanguage{spanish}{.}
\item \textstyleSourceText{\foreignlanguage{spanish}{REAL}}\foreignlanguage{spanish}{:
}\textstyleSourceText{\foreignlanguage{spanish}{({\textbackslash}d+{\textbackslash}.?{\textbar}{\textbackslash}.{\textbackslash}d){\textbackslash}d*([eE][+-]?{\textbackslash}d+)?}}\foreignlanguage{spanish}{.}
\item \textstyleSourceText{\foreignlanguage{spanish}{CADENA}}\foreignlanguage{spanish}{:
}\textstyleSourceText{\foreignlanguage{spanish}{{\textquotedbl}({\textbackslash}{\textbackslash}.{\textbar}[\^{}{\textquotedbl}])*{\textquotedbl}{\textbar}'({\textbackslash}{\textbackslash}.{\textbar}[\^{}'])*'}}\foreignlanguage{spanish}{.}
\item \textstyleSourceText{\foreignlanguage{spanish}{ID}}\foreignlanguage{spanish}{:
}\textstyleSourceText{\foreignlanguage{spanish}{[\_a-zA-Z]{\textbackslash}w*}}


\bigskip
\end{itemize}
{\selectlanguage{spanish}
Los símbolos que aparecen secuencialmente en el EBNF estándar están separados por comas. Por intuición, uso espacios
para implementar la función de coma. El símbolo de barra vertical ``{\textbar}'' se pronuncia como
{\textquotedbl}o{\textquotedbl}, significa que los patrones izquierdo y derecho solo pueden coincidir con uno de ellos,
o tiene la prioridad más baja. Por ejemplo, la gramática \textit{a} 0 \textit{a} 1 {\textbar}\textit{a} 2 significa la
fórmula correspondiente \textit{a} 0 \textit{a} 1 o la combinación \textit{a} 2 . Los corchetes indican que la
subexpresión dentro de los paréntesis coincide 0 o 1 veces, las llaves indican que la subexpresión interna coincide 0 o
más veces, y los paréntesis solo tienen la función de tomar la subexpresión interna como un todo.}

{\selectlanguage{spanish}
La siguiente es la definición de gramática JSON admitida por el módulo JSON en la biblioteca estándar de Berry. El uso
de EBNF aún cumple con las convenciones anteriores:}


\bigskip

{\selectlanguage{spanish}\ttfamily
json = value;}

{\selectlanguage{spanish}\ttfamily
value = object {\textbar} array {\textbar}}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ string {\textbar} number {\textbar} 'true' {\textbar} 'false' {\textbar} 'null';}

{\selectlanguage{spanish}\ttfamily
object = '\{' [ string ':' value ] \{ ',' string ':' value \} '\}';}

{\selectlanguage{spanish}\ttfamily
array = '[' [json] \{ ',' json \} ']';}


\bigskip

\foreignlanguage{spanish}{Los símbolos no terminales
}\textstyleSourceText{\foreignlanguage{spanish}{cadena}}\foreignlanguage{spanish}{ y
}\textstyleSourceText{\foreignlanguage{spanish}{número}}\foreignlanguage{spanish}{ también se pueden definir mediante
expresiones regulares.
}\href{http://www.json.org/}{\textstyleDefinition{\foreignlanguage{spanish}{http://www.json.org}}}\textstyleDefinition{\foreignlanguage{spanish}{
}}\foreignlanguage{spanish}{proporciona la gramática estándar de JSON, que también incluye las definiciones de
}\textstyleSourceText{\foreignlanguage{spanish}{cadena}}\foreignlanguage{spanish}{ y
}\textstyleSourceText{\foreignlanguage{spanish}{número}}\foreignlanguage{spanish}{. El soporte para números de la
biblioteca Berry JSON es diferente del estándar. Los números JSON estándar deben comenzar con
{\textquotedbl}-{\textquotedbl} o el número {\textquotedbl}0-9{\textquotedbl}, mientras que la biblioteca Berry JSON
también acepta números que comienzan con un punto decimal.}

\clearpage\section[Apéndice B: Intérprete del compilador]{Apéndice B: \foreignlanguage{spanish}{Intérprete del
compilador}}
\hypertarget{RefHeadingToc360213639824055}{}
\bigskip

\subsection[1. Visión general]{\selectlanguage{spanish} 1. Visión general}
\hypertarget{RefHeadingToc360233639824055}{}{\selectlanguage{spanish}
El código fuente del intérprete de Berry está escrito con el estándar ISO C99 y el código central no depende de
bibliotecas de terceros, por lo que tiene una gran versatilidad. Tome el sistema Ubuntu como ejemplo, ejecute el
siguiente comando en la terminal para instalar el intérprete de Berry:}


\bigskip

{\selectlanguage{spanish}\ttfamily
apt install git gcc g++ make libreadline-dev}

{\selectlanguage{spanish}\ttfamily
git clone https://github.com/berry-lang/berry}

{\selectlanguage{spanish}\ttfamily
cd berry}

{\selectlanguage{spanish}\ttfamily
make}

{\selectlanguage{spanish}\ttfamily
make install}


\bigskip

{\selectlanguage{spanish}
El Makefile proporcionado en el repositorio de GitHub se crea con el compilador GCC. Otros compiladores también pueden
compilar correctamente el intérprete de Berry. Los compiladores actualmente probados y disponibles incluyen GCC, Clang,
MSVC, ARMCC e ICCARM. El compilador que compila el intérprete de Berry debe tener las siguientes características:}

\liststyleLxxi
\begin{itemize}
\item {\selectlanguage{spanish}
Compilador C que soporta el estándar C99}
\item {\selectlanguage{spanish}
Compilador C++ compatible con el estándar C++11 (solo para compilación nativa)}
\item {\selectlanguage{spanish}
Plataforma de destino de 32 o 64 bits}
\end{itemize}
{\selectlanguage{spanish}
El compilador de C++ solo se usa para compilar las herramientas \textit{map\_build}, por lo que no es necesario
proporcionar un compilador cruzado de C++ para el intérprete de Berry al realizar la compilación cruzada, pero el
usuario debe preparar un compilador nativo de C++ (a menos que el usuario pueda obtener el * archivo ejecutable de la
herramienta map\_build*).}

\subsection[2. Portabilidad]{\selectlanguage{spanish} 2. Portabilidad}
\hypertarget{RefHeadingToc360253639824055}{}{\selectlanguage{spanish}
Lo siguiente es cómo portar el intérprete de Berry al proyecto del usuario:}

\liststyleLxxii
\begin{enumerate}
\item {\selectlanguage{spanish}
Agregue todos los archivos fuente en el directorio \textit{src} al proyecto de usuario y el directorio debe agregarse a
la ruta de inclusión}
\item {\selectlanguage{spanish}
Los usuarios deben implementar por sí mismos archivos \textit{predeterminados} que no sean \textit{berry.c} en el
directorio. Si las condiciones lo permiten, no necesitan modificarlos}
\item {\selectlanguage{spanish}
Utilice la herramienta \textit{map\_build} para generar código de objeto constante y luego compilar}
\end{enumerate}
\subsection[3. Soporte de plataforma]{\selectlanguage{spanish} 3. Soporte de plataforma}
\hypertarget{RefHeadingToc360273639824055}{}{\selectlanguage{spanish}
Actualmente, el intérprete de Berry ha sido probado en algunas plataformas. Los sistemas operativos Windows, Linux y
MacOS que se ejecutan en CPU X86 pueden funcionar normalmente. Las plataformas integradas que se han probado incluyen
Cortex M3/M0/M4/M7. El intérprete de Berry debería poder funcionar bien sobre la base de la biblioteca de tiempo de
ejecución C necesaria. En la actualidad, cuando solo se compila el núcleo del lenguaje Berry, el código del intérprete
generado por el compilador ARMCC tiene solo alrededor de 40 KiB, y el intérprete puede ejecutarse en un dispositivo con
solo 8 KiB de RAM.}

\clearpage\section{Apéndice C: Guía de portabilidad}
\hypertarget{RefHeadingToc360293639824055}{}
\bigskip

\subsection[Archivo de configuración]{\selectlanguage{spanish} Archivo de configuración}
\hypertarget{RefHeadingToc360313639824055}{}{\selectlanguage{spanish}
El archivo de encabezado de configuración del intérprete de Berry es \textit{berry\_conf.h}. Este archivo incluye un
lote de macros para la configuración y define algunos contenidos relacionados con la plataforma.}

\subsubsection[Archivo berry\_conf.h]{\selectlanguage{spanish} \textit{Archivo }\textit{berry\_conf.h}}
\hypertarget{RefHeadingToc360333639824055}{}\paragraph[Interruptor de macro de configuración]{\selectlanguage{spanish}
Interruptor de macro de configuración}
\hypertarget{RefHeadingToc360353639824055}{}\foreignlanguage{spanish}{Las macros de configuración presentadas en esta
sección generalmente se usan para compilar conmutadores de algunos códigos fuente. Para facilitar la descripción,
llamamos a esta macro {\textquotedbl}cambio de macro{\textquotedbl}. Para el interruptor de macro,
{\textquotedbl}on{\textquotedbl} se refiere a establecer el interruptor de macro en un valor distinto de cero, y
{\textquotedbl}off{\textquotedbl} se refiere a establecer el valor del interruptor de macro en
}\textstyleSourceText{\foreignlanguage{spanish}{0}}\foreignlanguage{spanish}{.}

{\selectlanguage{spanish}
Algunos interruptores macro tienen varios estados, no solo {\textquotedbl}encendido{\textquotedbl} o
{\textquotedbl}apagado{\textquotedbl}. Estos interruptores macro se usan generalmente para configuraciones con
múltiples opciones. También hay algunas macros de configuración que no son conmutadores de macro. No importa cuál sea
el valor de estas macros, no habrá código y, por lo tanto, no participará en la compilación. Estas macros se utilizan
generalmente para configurar el valor de la cantidad.}

{\selectlanguage{spanish}
[sección::BE\_DEBUG]}

\foreignlanguage{spanish}{Este conmutador de macro se utiliza para activar o desactivar la función de depuración del
propio intérprete. Cuando el valor de
}\textstyleSourceText{\foreignlanguage{spanish}{BE\_DEBUG}}\foreignlanguage{spanish}{ es
}\textstyleSourceText{\foreignlanguage{spanish}{0}}\foreignlanguage{spanish}{, la depuración se desactiva; de lo
contrario, se activará. La función de depuración mencionada aquí se refiere a la depuración del intérprete, no a la
función de depuración del programa Berry. El valor predeterminado de
}\textstyleSourceText{\foreignlanguage{spanish}{BE\_DEBUG}}\foreignlanguage{spanish}{ es
}\textstyleSourceText{\foreignlanguage{spanish}{0}}\foreignlanguage{spanish}{. Si usa
}\foreignlanguage{spanish}{\textit{Makefile}}\foreignlanguage{spanish}{ que viene con el proyecto del intérprete para
compilar, este interruptor de macro se activará automáticamente cuando use el comando
}\textstyleSourceText{\foreignlanguage{spanish}{make debug}}\foreignlanguage{spanish}{.}

\foreignlanguage{spanish}{Cuando se abre esta macro, se activarán algunas aserciones y se generará un mensaje de error
cuando el intérprete encuentre un error que la aserción pueda detectar. Puede abrir
}\textstyleSourceText{\foreignlanguage{spanish}{BE\_DEBUG}}\foreignlanguage{spanish}{ al depurar el intérprete y
cerrarlo al compilar la versión.}

\foreignlanguage{spanish}{Este conmutador de macro configura el tipo de punto flotante utilizado por el tipo
}\textstyleSourceText{\foreignlanguage{spanish}{breal}}\foreignlanguage{spanish}{. Cuando el valor de la macro es
}\textstyleSourceText{\foreignlanguage{spanish}{0}}\foreignlanguage{spanish}{, se usará el tipo
}\textstyleSourceText{\foreignlanguage{spanish}{doble}}\foreignlanguage{spanish}{ para implementar
}\textstyleSourceText{\foreignlanguage{spanish}{breal}}\foreignlanguage{spanish}{, de lo contrario, se usará el tipo
}\textstyleSourceText{\foreignlanguage{spanish}{float}}\foreignlanguage{spanish}{ para implementar
}\textstyleSourceText{\foreignlanguage{spanish}{breal}}\foreignlanguage{spanish}{. Este interruptor de macro se puede
activar en algunos entornos con bajo rendimiento o configuración de memoria. En la implementación predeterminada, este
interruptor de macro está desactivado.}

\foreignlanguage{spanish}{Esta macro configura la implementación del tipo
}\textstyleSourceText{\foreignlanguage{spanish}{bint}}\foreignlanguage{spanish}{. Cuando el valor de la macro es
}\textstyleSourceText{\foreignlanguage{spanish}{0}}\foreignlanguage{spanish}{, se usará el tipo
}\textstyleSourceText{\foreignlanguage{spanish}{int}}\foreignlanguage{spanish}{ para implementar
}\textstyleSourceText{\foreignlanguage{spanish}{bint}}\foreignlanguage{spanish}{, cuando el valor sea
}\textstyleSourceText{\foreignlanguage{spanish}{1}}\foreignlanguage{spanish}{, se usará el tipo
}\textstyleSourceText{\foreignlanguage{spanish}{long}}\foreignlanguage{spanish}{ para implementar
}\textstyleSourceText{\foreignlanguage{spanish}{bint}}\foreignlanguage{spanish}{, y cuando el el valor es
}\textstyleSourceText{\foreignlanguage{spanish}{2}}\foreignlanguage{spanish}{, se usará 64 ] Tipo de entero con signo
de bit (}\textstyleSourceText{\foreignlanguage{spanish}{\_\_int64}}\foreignlanguage{spanish}{ en Windows,
}\textstyleSourceText{\foreignlanguage{spanish}{long long}}\foreignlanguage{spanish}{ en otras plataformas) implementa
}\textstyleSourceText{\foreignlanguage{spanish}{bint}}\foreignlanguage{spanish}{. El valor predeterminado de esta macro
es }\textstyleSourceText{\foreignlanguage{spanish}{2}}\foreignlanguage{spanish}{. Si desea reducir el uso de la
memoria, puede establecer }\foreignlanguage{spanish}{esta macro en
}\textstyleSourceText{\foreignlanguage{spanish}{0}}\foreignlanguage{spanish}{ o
}\textstyleSourceText{\foreignlanguage{spanish}{1}}\foreignlanguage{spanish}{ para habilitar el tipo de entero de 32
bits.}

\foreignlanguage{spanish}{Esta macro se usa para configurar la información de depuración en tiempo de ejecución del
código Berry. Tiene 3 valores disponibles: establecer en
}\textstyleSourceText{\foreignlanguage{spanish}{0}}\foreignlanguage{spanish}{ para desactivar la salida del nombre de
archivo y el número de línea de la información de depuración en tiempo de ejecución, y establecer en
}\textstyleSourceText{\foreignlanguage{spanish}{1}}\foreignlanguage{spanish}{ para mostrar el nombre de archivo y el
número de línea en la información de depuración en tiempo de ejecución, establecer a
}\textstyleSourceText{\foreignlanguage{spanish}{2}}\foreignlanguage{spanish}{ Al usar
}\textstyleSourceText{\foreignlanguage{spanish}{uint16\_t}}\foreignlanguage{spanish}{ (entero de 16 bits) escriba para
almacenar la información del número de fila. Su valor por defecto es
}\textstyleSourceText{\foreignlanguage{spanish}{1}}\foreignlanguage{spanish}{.}

\foreignlanguage{spanish}{Establecer esta macro en
}\textstyleSourceText{\foreignlanguage{spanish}{0}}\foreignlanguage{spanish}{ no almacenará el nombre del archivo ni la
información del número de línea, por lo que el consumo de memoria es mínimo. Cuando se establece en
}\textstyleSourceText{\foreignlanguage{spanish}{2}}\foreignlanguage{spanish}{, consume menos memoria, pero si el
programa es demasiado largo, }\textstyleSourceText{\foreignlanguage{spanish}{uint16\_t}}\foreignlanguage{spanish}{ se
desbordará.}

{\selectlanguage{spanish}
Este modificador de macro configura la función de construir objetos en tiempo de compilación. Activar esta macro
significa que la construcción de objetos en tiempo de compilación está habilitada. Esta macro está activada de forma
predeterminada. Cuando esta macro está activada, los objetos nativos de la biblioteca estándar se generarán en tiempo
de compilación y cuando esta macro está desactivada, los objetos de la biblioteca estándar se generarán en tiempo de
ejecución.}

\foreignlanguage{spanish}{Las funciones
}\textstyleSourceText{\foreignlanguage{spanish}{be\_regfunc}}\foreignlanguage{spanish}{ y
}\textstyleSourceText{\foreignlanguage{spanish}{be\_regclass}}\foreignlanguage{spanish}{ se verán afectadas por esta
macro. La tabla de objetos integrada no se puede modificar cuando se utiliza la construcción de objetos en tiempo de
compilación. En este momento, estas dos funciones no pueden registrar objetos en el ámbito integrado, pero registran
objetos en el ámbito global.}

{\selectlanguage{spanish}
Los objetos construidos durante el tiempo de compilación se almacenan junto con el código y no ocuparán recursos de RAM
(o el área de lectura y escritura en la memoria). La tecnología de construcción durante el tiempo de compilación
también puede reducir el tiempo de inicio del intérprete, por lo que se recomienda abrir esta macro. Consulte la
sección [section::precompiled\_build] para obtener más detalles sobre las técnicas de construcción en tiempo de
compilación.}

\foreignlanguage{spanish}{Esta macro define la capacidad máxima de pila de Berry, que se refiere a la cantidad de
objetos de Berry. Cuando el código Berry usa más de esta cantidad de pila, dejará de ejecutar el programa y devolverá
un mensaje de error. El valor predeterminado de esta macro es
}\textstyleSourceText{\foreignlanguage{spanish}{2000}}\foreignlanguage{spanish}{, que puede modificarse según la
capacidad de memoria del sistema.}

{\selectlanguage{spanish}
Este valor no afecta el uso de memoria de la pila Berry, porque la capacidad de la pila Berry se ajusta dinámicamente,
por lo que no importa cuánto se establezca, no puede ayudar a reducir el uso de memoria. Su función principal es
terminar la ejecución cuando el programa Berry consume demasiada pila. Es muy probable que estos programas sean
incorrectos, por ejemplo, las llamadas a funciones recursivas sin condiciones de devolución seguirán consumiendo la
pila.}

\foreignlanguage{spanish}{Esta macro define el espacio mínimo disponible en la pila de Berry y su valor predeterminado
es }\textstyleSourceText{\foreignlanguage{spanish}{10}}\foreignlanguage{spanish}{. La función nativa puede insertar un
valor en la pila de Berry. En este momento, la pila no crecerá automáticamente, así que asegúrese de que haya
suficiente espacio en la pila para que la use la función nativa. No se recomienda modificar este valor, sino usar la
función }\textstyleSourceText{\foreignlanguage{spanish}{be\_stack\_require}}\foreignlanguage{spanish}{ donde realmente
se necesita más espacio de pila.}

\foreignlanguage{spanish}{Para detectar errores de desbordamiento de pila al depurar el intérprete, puede abrir la macro
}\textstyleSourceText{\foreignlanguage{spanish}{BE\_DEBUG}}\foreignlanguage{spanish}{ (sección [sección::BE\_DEBUG] ).}

{\selectlanguage{spanish}
Cuando se abre esta macro, el objeto de cadena corta guardará el valor hash de la cadena para mejorar la velocidad de
ejecución, pero el tamaño de cada objeto de cadena aumentará en 4 bytes. Esta macro está desactivada de forma
predeterminada y las pruebas actuales no han encontrado que abrir esta macro traiga una mejora significativa.}

\foreignlanguage{spanish}{Este conmutador de macro se utiliza para activar o desactivar el módulo
}\textstyleSourceText{\foreignlanguage{spanish}{string}}\foreignlanguage{spanish}{, que está activado de forma
predeterminada.}

\foreignlanguage{spanish}{Este interruptor de macro se usa para habilitar o deshabilitar el módulo
}\textstyleSourceText{\foreignlanguage{spanish}{json}}\foreignlanguage{spanish}{, que está activado de forma
predeterminada.}

{\selectlanguage{spanish}
Este conmutador de macro se utiliza para habilitar o deshabilitar el módulo {\textquotedbl}matemático{\textquotedbl},
que está activado de forma predeterminada.}

\foreignlanguage{spanish}{Este interruptor de macro se usa para habilitar o deshabilitar el módulo
}\textstyleSourceText{\foreignlanguage{spanish}{time}}\foreignlanguage{spanish}{, que está activado de forma
predeterminada.}

\foreignlanguage{spanish}{Este conmutador de macro se utiliza para activar o desactivar el módulo
}\textstyleSourceText{\foreignlanguage{spanish}{os}}\foreignlanguage{spanish}{, que está activado de forma
predeterminada.}

\foreignlanguage{spanish}{Esta macro determina la función
}\textstyleSourceText{\foreignlanguage{spanish}{abortar}}\foreignlanguage{spanish}{ utilizada internamente por el
intérprete de Berry. Por defecto o cuando la macro no está definida, se utilizará la función
}\textstyleSourceText{\foreignlanguage{spanish}{abortar}}\foreignlanguage{spanish}{ en la biblioteca estándar de C.
Esta macro se define como }\textstyleSourceText{\foreignlanguage{spanish}{abortar}}\foreignlanguage{spanish}{ por
defecto. Si el usuario necesita especificar explícitamente la función
}\textstyleSourceText{\foreignlanguage{spanish}{abortar}}\foreignlanguage{spanish}{ utilizada por el intérprete,
reemplace la definición de macro con la función requerida por el usuario. Esta función debe tener la misma forma que la
declaración de la función }\textstyleSourceText{\foreignlanguage{spanish}{abortar}}\foreignlanguage{spanish}{ en la
biblioteca estándar.}

\foreignlanguage{spanish}{Esta macro determina la función
}\textstyleSourceText{\foreignlanguage{spanish}{exit}}\foreignlanguage{spanish}{ utilizada internamente por el
intérprete de Berry. Por defecto o cuando la macro no está definida, se utilizará la función
}\textstyleSourceText{\foreignlanguage{spanish}{exit}}\foreignlanguage{spanish}{ en la biblioteca estándar de C. Esta
macro se define como }\textstyleSourceText{\foreignlanguage{spanish}{salir}}\foreignlanguage{spanish}{ por defecto. Si
el usuario necesita especificar explícitamente la función
}\textstyleSourceText{\foreignlanguage{spanish}{salir}}\foreignlanguage{spanish}{ utilizada por el intérprete,
reemplace la definición de macro con la función requerida por el usuario. Esta función debe tener la misma forma que la
declaración de la función }\textstyleSourceText{\foreignlanguage{spanish}{exit}}\foreignlanguage{spanish}{ en la
biblioteca estándar.}

\foreignlanguage{spanish}{Esta macro determina la función
}\textstyleSourceText{\foreignlanguage{spanish}{malloc}}\foreignlanguage{spanish}{ utilizada internamente por el
intérprete de Berry. Por defecto o cuando la macro no está definida, se utilizará la función
}\textstyleSourceText{\foreignlanguage{spanish}{malloc}}\foreignlanguage{spanish}{ en la biblioteca estándar de C. Esta
macro se define como }\textstyleSourceText{\foreignlanguage{spanish}{malloc}}\foreignlanguage{spanish}{ por defecto. Si
el usuario necesita especificar explícitamente la función
}\textstyleSourceText{\foreignlanguage{spanish}{malloc}}\foreignlanguage{spanish}{ utilizada por el intérprete,
reemplace la definición de macro con la función requerida por el usuario. Esta función debe tener la misma forma que la
declaración de la función }\textstyleSourceText{\foreignlanguage{spanish}{malloc}}\foreignlanguage{spanish}{ en la
biblioteca estándar.}

\foreignlanguage{spanish}{Esta macro determina la función
}\textstyleSourceText{\foreignlanguage{spanish}{libre}}\foreignlanguage{spanish}{ utilizada internamente por el
intérprete de Berry. Por defecto o cuando la macro no está definida, se utilizará la función
}\textstyleSourceText{\foreignlanguage{spanish}{free}}\foreignlanguage{spanish}{ en la biblioteca estándar de C. Esta
macro se define como {\textquotedbl}gratis{\textquotedbl} por defecto. Si el usuario necesita especificar
explícitamente la función {\textquotedbl}libre{\textquotedbl} utilizada por el intérprete, reemplace la definición de
macro con la función requerida por el usuario. Esta función debe tener la misma forma que la declaración de la función
{\textquotedbl}libre{\textquotedbl} en la biblioteca estándar.}

\foreignlanguage{spanish}{Esta macro determina la función
}\textstyleSourceText{\foreignlanguage{spanish}{realloc}}\foreignlanguage{spanish}{ utilizada internamente por el
intérprete de Berry. Por defecto o cuando la macro no está definida, se utilizará la función
}\textstyleSourceText{\foreignlanguage{spanish}{realloc}}\foreignlanguage{spanish}{ en la biblioteca estándar de C.
Esta macro se define como }\textstyleSourceText{\foreignlanguage{spanish}{realloc}}\foreignlanguage{spanish}{ por
defecto. Si el usuario necesita especificar explícitamente la función
}\textstyleSourceText{\foreignlanguage{spanish}{realloc}}\foreignlanguage{spanish}{ utilizada por el intérprete,
reemplace la definición de macro con la función requerida por el usuario. Esta función debe tener la misma forma que la
declaración de la función }\textstyleSourceText{\foreignlanguage{spanish}{realloc}}\foreignlanguage{spanish}{ en la
biblioteca estándar.}

\foreignlanguage{spanish}{Esta macro se utiliza para definir la implementación de la función de aserción. De forma
predeterminada, la función }\textstyleSourceText{\foreignlanguage{spanish}{assert}}\foreignlanguage{spanish}{ en la
biblioteca estándar de C se usa para implementar la afirmación. Si el sistema de destino tiene inconvenientes para usar
la función }\textstyleSourceText{\foreignlanguage{spanish}{assert()}}\foreignlanguage{spanish}{ en la biblioteca
estándar para hacer una afirmación, puede modificar la definición de la macro
}\textstyleSourceText{\foreignlanguage{spanish}{be\_assert}}\foreignlanguage{spanish}{. Una función de aserción
correcta debe usar la siguiente declaración:}

{\selectlanguage{spanish}\ttfamily
void assert(int condition);}

\foreignlanguage{spanish}{Entre ellos,
}\textstyleSourceText{\foreignlanguage{spanish}{condición}}\foreignlanguage{spanish}{ es la condición de afirmación. Si
no se cumple la condición, se emitirá un mensaje de error y el programa finalizará. Por supuesto, la función
{\textquotedbl}afirmar{\textquotedbl} generalmente se implementa mediante una macro.}

\subsection[Archivo berry\_port.c]{\selectlanguage{spanish} Archivo berry\_port.c}
\hypertarget{RefHeadingToc360373639824055}{}{\selectlanguage{spanish}
Este archivo implementa las funciones de E/S de bajo nivel del intérprete de Berry, incluida la entrada y salida
estándar y la compatibilidad con el sistema de archivos. El archivo \textit{berry\_port.c} en el directorio
\textit{predeterminado} contiene un conjunto de soporte de E/S portátil. Las operaciones de archivo y la entrada y
salida estándar se implementan mediante API en la biblioteca estándar de C. Las operaciones de ruta y carpeta son
compatibles con las API estándar de Windows y POSIX. Este archivo también implementa un conjunto de funciones de
operación de E/S basadas en FatFs para que los usuarios las usen directamente. Si necesita usar el intérprete de Berry
en otros entornos, estas funciones deben implementarse por separado (es posible que solo deban implementarse
parcialmente).}

{\selectlanguage{spanish}
Esta sección presentará las funciones de las funciones implementadas en el archivo \textit{berry\_port.c} y guiará a los
usuarios para implementar su propia versión.}


\bigskip

{\selectlanguage{spanish}\ttfamily
void be\_writebuffer(const char *buffer, size\_t length);}


\bigskip

\foreignlanguage{spanish}{Envíe un dato al dispositivo de salida estándar, el parámetro
{\textquotedbl}búfer{\textquotedbl} es la primera dirección del bloque de datos de salida y
{\textquotedbl}longitud{\textquotedbl} es la longitud del bloque de datos de salida. Esta función genera el archivo
}\textstyleSourceText{\foreignlanguage{spanish}{stdout}}\foreignlanguage{spanish}{ de forma predeterminada. Dentro del
intérprete, esta función generalmente se usa como una salida de flujo de caracteres, no como un flujo binario.}

\foreignlanguage{spanish}{Las funciones
}\textstyleSourceText{\foreignlanguage{spanish}{be\_writebuffer}}\foreignlanguage{spanish}{ son muy versátiles y deben
implementarse.}


\bigskip

{\selectlanguage{spanish}\ttfamily
char* be\_readstring(char *buffer, size\_t size);}


\bigskip

\foreignlanguage{spanish}{Ingrese un dato del dispositivo de entrada estándar y lea como máximo una fila de datos cada
vez que se llame a esta función. El parámetro
}\textstyleSourceText{\foreignlanguage{spanish}{buffer}}\foreignlanguage{spanish}{ es el búfer de datos pasado por la
persona que llama, y la capacidad del búfer es
}\textstyleSourceText{\foreignlanguage{spanish}{tamaño}}\foreignlanguage{spanish}{. Esta función dejará de leer y
regresará cuando se agote la capacidad del búfer; de lo contrario, regresará cuando se lea un carácter de nueva línea o
un carácter de fin de archivo. Si la función se ejecuta con éxito, usará directamente el parámetro
}\textstyleSourceText{\foreignlanguage{spanish}{buffer}}\foreignlanguage{spanish}{ como valor de retorno, de lo
contrario devolverá }\textstyleSourceText{\foreignlanguage{spanish}{NULL}}\foreignlanguage{spanish}{.}

\foreignlanguage{spanish}{Esta función agregará los saltos de línea de lectura a los datos leídos, y cada vez que se
llame a la función }\textstyleSourceText{\foreignlanguage{spanish}{be\_readstring}}\foreignlanguage{spanish}{,
continuará leyendo desde la posición actual. Esta función solo se llama en la implementación de la función nativa
}\textstyleSourceText{\foreignlanguage{spanish}{input}}\foreignlanguage{spanish}{, y es posible que la función
}\textstyleSourceText{\foreignlanguage{spanish}{be\_readstring}}\foreignlanguage{spanish}{ no se implemente cuando no
sea necesaria.}


\bigskip

{\selectlanguage{spanish}\ttfamily
void* be\_fopen(const char *filename, const char *modes);}


\bigskip

\foreignlanguage{spanish}{Para abrir un archivo,
}\textstyleSourceText{\foreignlanguage{spanish}{filename}}\foreignlanguage{spanish}{ es el nombre del archivo que se
abrirá y }\textstyleSourceText{\foreignlanguage{spanish}{modos}}\foreignlanguage{spanish}{ es el método de apertura. La
función devolverá un identificador de archivo o un puntero a la estructura de operación del archivo. El uso de esta
función es similar a la función }\textstyleSourceText{\foreignlanguage{spanish}{fopen}}\foreignlanguage{spanish}{ en la
biblioteca estándar de C. El nombre del archivo es una cadena de estilo C (que termina con un carácter
}\textstyleSourceText{\foreignlanguage{spanish}{{\textbackslash}0}}\foreignlanguage{spanish}{), y el patrón debe
admitir al menos las siguientes condiciones:}

\liststyleLxxiii
\begin{itemize}
\item \textstyleSourceText{\foreignlanguage{spanish}{r}}\foreignlanguage{spanish}{,
}\textstyleSourceText{\foreignlanguage{spanish}{rt}}\foreignlanguage{spanish}{: Para abrir un archivo de texto en modo
de solo lectura, el archivo debe existir.}
\item \textstyleSourceText{\foreignlanguage{spanish}{r+}}\foreignlanguage{spanish}{,
}\textstyleSourceText{\foreignlanguage{spanish}{rt+}}\foreignlanguage{spanish}{: Abre un archivo de texto en modo
lectura-escritura y crea un nuevo archivo si el archivo no existe.}
\item \textstyleSourceText{\foreignlanguage{spanish}{rb}}\foreignlanguage{spanish}{: abre un archivo binario en modo de
solo lectura, el archivo debe existir.}
\item \textstyleSourceText{\foreignlanguage{spanish}{rb+}}\foreignlanguage{spanish}{: abre un archivo binario en modo de
lectura y escritura y crea un nuevo archivo si el archivo no existe.}
\item \textstyleSourceText{\foreignlanguage{spanish}{w}}\foreignlanguage{spanish}{,
}\textstyleSourceText{\foreignlanguage{spanish}{wt}}\foreignlanguage{spanish}{: Crear y abrir un archivo de texto en
modo de solo escritura, y el el archivo existente será eliminado.}
\item \textstyleSourceText{\foreignlanguage{spanish}{w+}}\foreignlanguage{spanish}{,
}\textstyleSourceText{\foreignlanguage{spanish}{wt+}}\foreignlanguage{spanish}{: Crea y abre un archivo de texto en
modo lectura-escritura, y el el archivo existente será eliminado.}
\item \textstyleSourceText{\foreignlanguage{spanish}{wb}}\foreignlanguage{spanish}{: crea y abre un archivo binario en
modo de solo escritura, y el el archivo existente será eliminado.}
\item \textstyleSourceText{\foreignlanguage{spanish}{wb+}}\foreignlanguage{spanish}{: Crea y abre un archivo binario en
modo lectura-escritura, y el el archivo existente será eliminado.}
\end{itemize}
\foreignlanguage{spanish}{De forma predeterminada, la función
}\textstyleSourceText{\foreignlanguage{spanish}{fopen}}\foreignlanguage{spanish}{ en la biblioteca estándar de C se usa
para implementar }\textstyleSourceText{\foreignlanguage{spanish}{be\_fopen}}\foreignlanguage{spanish}{. Si utiliza
otros métodos para lograrlo, debe asegurarse de que se puedan lograr los modos de funcionamiento anteriores. Si no se
requieren operaciones de archivo, esta función se puede dejar en blanco. Las operaciones de archivos aquí incluyen
todos los escenarios, como usar la función
}\textstyleSourceText{\foreignlanguage{spanish}{abrir}}\foreignlanguage{spanish}{ en el script, cargar el script desde
un archivo (usando la función
}\textstyleSourceText{\foreignlanguage{spanish}{be\_loadfile}}\foreignlanguage{spanish}{), etc.}


\bigskip

{\selectlanguage{spanish}\ttfamily
int be\_fclose(void *hfile);}


\bigskip

\foreignlanguage{spanish}{Cierra un archivo,
}\textstyleSourceText{\foreignlanguage{spanish}{hfile}}\foreignlanguage{spanish}{ es el identificador de archivo
cerrado. La función de esta función es similar a la función
}\textstyleSourceText{\foreignlanguage{spanish}{fclose}}\foreignlanguage{spanish}{ en la biblioteca estándar de C.}


\bigskip

{\selectlanguage{spanish}\ttfamily
size\_t be\_fwrite(void *hfile, const void *buffer, size\_t length);}


\bigskip

\foreignlanguage{spanish}{Escribe un dato en el archivo especificado. El parámetro
}\textstyleSourceText{\foreignlanguage{spanish}{hfile}}\foreignlanguage{spanish}{ es el identificador del archivo
}\foreignlanguage{spanish}{que se escribirá,
}\textstyleSourceText{\foreignlanguage{spanish}{buffer}}\foreignlanguage{spanish}{ es el puntero de los datos que se
escribirán, }\textstyleSourceText{\foreignlanguage{spanish}{length}}\foreignlanguage{spanish}{ es el número de datos
que se escribirán (en bytes).}


\bigskip

{\selectlanguage{spanish}\ttfamily
size\_t be\_fread(void *hfile, void *buffer, size\_t length);}


\bigskip

\foreignlanguage{spanish}{Leer un fragmento de datos del archivo especificado. El parámetro
}\textstyleSourceText{\foreignlanguage{spanish}{hfile}}\foreignlanguage{spanish}{ es el identificador del archivo que
se leerá, }\textstyleSourceText{\foreignlanguage{spanish}{buffer}}\foreignlanguage{spanish}{ es el puntero al búfer de
lectura y }\textstyleSourceText{\foreignlanguage{spanish}{length}}\foreignlanguage{spanish}{ es el número de bytes que
se leerán.}


\bigskip

{\selectlanguage{spanish}\ttfamily
char* be\_fgets(void *hfile, void *buffer, int size);}


\bigskip

\foreignlanguage{spanish}{Lea una línea del archivo, similar a la función
}\textstyleSourceText{\foreignlanguage{spanish}{fgets}}\foreignlanguage{spanish}{ en la biblioteca estándar de C. El
parámetro }\textstyleSourceText{\foreignlanguage{spanish}{hfile}}\foreignlanguage{spanish}{ es el identificador del
archivo que se va a leer, }\textstyleSourceText{\foreignlanguage{spanish}{buffer}}\foreignlanguage{spanish}{ es el
puntero del búfer de lectura y }\textstyleSourceText{\foreignlanguage{spanish}{size}}\foreignlanguage{spanish}{ es la
capacidad del búfer de lectura. Esta función regresará cuando se lean los bytes
}\textstyleSourceText{\foreignlanguage{spanish}{size - 1}}\foreignlanguage{spanish}{, los caracteres de nueva línea y
los caracteres de fin de archivo, y el valor de retorno sea
}\textstyleSourceText{\foreignlanguage{spanish}{buffer}}\foreignlanguage{spanish}{.}


\bigskip

{\selectlanguage{spanish}\ttfamily
int be\_fseek(void *hfile, long offset);}


\bigskip

\foreignlanguage{spanish}{Establezca la posición del puntero de lectura y escritura del archivo. El parámetro
}\textstyleSourceText{\foreignlanguage{spanish}{hfile}}\foreignlanguage{spanish}{ es el identificador de archivo que se
va a utilizar y }\textstyleSourceText{\foreignlanguage{spanish}{offset}}\foreignlanguage{spanish}{ es el valor que se
va a establecer.}


\bigskip

{\selectlanguage{spanish}\ttfamily
long int be\_ftell(void *hfile);}


\bigskip

\foreignlanguage{spanish}{Obtenga el puntero de lectura y escritura actual del archivo, el parámetro
}\textstyleSourceText{\foreignlanguage{spanish}{hfile}}\foreignlanguage{spanish}{ es el identificador del archivo que
se va a operar, y el valor de retorno de esta función es el puntero de lectura y escritura del archivo.}


\bigskip

{\selectlanguage{spanish}\ttfamily
long int be\_fflush(void *hfile);}


\bigskip

\foreignlanguage{spanish}{Escriba los datos del búfer de archivo en el archivo. El parámetro
}\textstyleSourceText{\foreignlanguage{spanish}{hfile}}\foreignlanguage{spanish}{ es el archivo a operar.}


\bigskip

{\selectlanguage{spanish}\ttfamily
size\_t be\_fsize(void *hfile);}


\bigskip

\foreignlanguage{spanish}{Obtenga el tamaño del archivo. El parámetro
}\textstyleSourceText{\foreignlanguage{spanish}{hfile}}\foreignlanguage{spanish}{ es el archivo a operar.}

\subsubsection{Hacer una función nativa}
\hypertarget{RefHeadingToc360393639824055}{}\foreignlanguage{spanish}{La FFI en C (interfaz de función externa) de Berry
opera en una pila virtual para interactuar con la máquina virtual. Si necesitamos hacer una función
}\textstyleSourceText{\foreignlanguage{spanish}{add}}\foreignlanguage{spanish}{ para sumar dos números y usarla en
Berry de esta manera:}


\bigskip

{\selectlanguage{spanish}\ttfamily
result = add(1, 2)}


\bigskip

{\selectlanguage{spanish}
Necesitamos saber cómo el código C obtiene los argumentos de la llamada a la función Berry y cómo devolver el valor.}

{\selectlanguage{spanish}
Los argumentos de la función se almacenan en una pila, y desde el primer argumento hasta el último argumento de la
función se almacenan desde la parte inferior de la pila hasta la parte superior de la pila. Si desea utilizar C para
obtener elementos de la pila, utilice el siguiente conjunto de FFI:}


\bigskip

{\selectlanguage{spanish}\ttfamily
int be\_toint(bvm *vm, int index);}

{\selectlanguage{spanish}\ttfamily
breal be\_toreal(bvm *vm, int index);}

{\selectlanguage{spanish}\ttfamily
int be\_tobool(bvm *vm, int index);}

{\selectlanguage{spanish}\ttfamily
const char* be\_tostring(bvm *vm, int index);}

{\selectlanguage{spanish}\ttfamily
void* be\_tocomptr(bvm *vm, int index);}


\bigskip

{\selectlanguage{spanish}
Si desea probar si un valor en la pila es de un tipo específico, use el siguiente conjunto de FFI:}


\bigskip

{\selectlanguage{spanish}\ttfamily
int be\_isnil(bvm *vm, int index);}

{\selectlanguage{spanish}\ttfamily
int be\_isbool(bvm *vm, int index);}

{\selectlanguage{spanish}\ttfamily
int be\_isint(bvm *vm, int index);}

{\selectlanguage{spanish}\ttfamily
int be\_isreal(bvm *vm, int index);}

{\selectlanguage{spanish}\ttfamily
int be\_isnumber(bvm *vm, int index);}

{\selectlanguage{spanish}\ttfamily
int be\_isstring(bvm *vm, int index);}

{\selectlanguage{spanish}\ttfamily
int be\_isclosure(bvm *vm, int index);}

{\selectlanguage{spanish}\ttfamily
int be\_isntvclos(bvm *vm, int index);}

{\selectlanguage{spanish}\ttfamily
int be\_isfunction(bvm *vm, int index);}

{\selectlanguage{spanish}\ttfamily
int be\_isproto(bvm *vm, int index);}

{\selectlanguage{spanish}\ttfamily
int be\_isclass(bvm *vm, int index);}

{\selectlanguage{spanish}\ttfamily
int be\_isinstance(bvm *vm, int index);}

{\selectlanguage{spanish}\ttfamily
int be\_islist(bvm *vm, int index);}

{\selectlanguage{spanish}\ttfamily
int be\_ismap(bvm *vm, int index);}

{\selectlanguage{spanish}\ttfamily
int be\_iscomptr(bvm *vm, int index);}


\bigskip

{\selectlanguage{spanish}
Si necesita enviar valores a la pila, use estos FFI:}


\bigskip

{\selectlanguage{spanish}\ttfamily
void be\_pushnil(bvm *vm);}

{\selectlanguage{spanish}\ttfamily
void be\_pushbool(bvm *vm, int b);}

{\selectlanguage{spanish}\ttfamily
void be\_pushint(bvm *vm, bint i);}

{\selectlanguage{spanish}\ttfamily
void be\_pushreal(bvm *vm, breal r);}

{\selectlanguage{spanish}\ttfamily
void be\_pushstring(bvm *vm, const char *str);}

{\selectlanguage{spanish}\ttfamily
void be\_pushnstring(bvm *vm, const char *str, size\_t n);}

{\selectlanguage{spanish}\ttfamily
const char* be\_pushfstring(bvm *vm, const char *format, ...);}

{\selectlanguage{spanish}\ttfamily
void be\_pushvalue(bvm *vm, int index);}

{\selectlanguage{spanish}\ttfamily
void be\_pushntvclosure(bvm *vm, bntvfunc f, int nupvals);}

{\selectlanguage{spanish}\ttfamily
void be\_pushntvfunction(bvm *vm, bntvfunc f);}

{\selectlanguage{spanish}\ttfamily
void be\_pushclass(bvm *vm, const char *name, const bnfuncinfo *lib);}

{\selectlanguage{spanish}\ttfamily
void be\_pushcomptr(bvm *vm, void *ptr);}


\bigskip

\textstyleSourceText{\foreignlanguage{spanish}{index}}\foreignlanguage{spanish}{ es la posición del elemento en la pila,
un valor positivo es el desplazamiento desde la parte inferior de la pila hasta la parte superior de la pila, y un
valor negativo es el desplazamiento desde la parte superior de la pila hasta la parte inferior de la pila.}

{\selectlanguage{spanish}
El valor de retorno utiliza dos FFI:}


\bigskip

{\selectlanguage{spanish}\ttfamily
be\_return(vm)}

{\selectlanguage{spanish}\ttfamily
be\_return\_nil(vm)}


\bigskip

\foreignlanguage{spanish}{Estos FFI son en realidad macros.
}\textstyleSourceText{\foreignlanguage{spanish}{be\_return}}\foreignlanguage{spanish}{ devuelve el objeto en la parte
superior de la pila, y }\textstyleSourceText{\foreignlanguage{spanish}{be\_return\_nil}}\foreignlanguage{spanish}{
devuelve }\textstyleSourceText{\foreignlanguage{spanish}{nil}}\foreignlanguage{spanish}{.}

{\selectlanguage{spanish}
Estas FFI se definen en berry.h.}

\foreignlanguage{spanish}{Ahora implementemos la función
}\textstyleSourceText{\foreignlanguage{spanish}{add}}\foreignlanguage{spanish}{:}


\bigskip

{\selectlanguage{spanish}\ttfamily
int my\_add\_func(bvm *vm)}

{\selectlanguage{spanish}\ttfamily
\{}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ /* comprobar que los argumentos son todos enteros */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ if (be\_isint(vm, 1) \&\& be\_isint(vm, 2)) \{}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ bint a = be\_toint(vm, 1); /* obtener el primer argumento */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ bint b = be\_toint(vm, 2); /* obtener el segundo argumento */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ be\_pushint(vm, a + b); /* empuja el resultado a la pila */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \} else if (be\_isnumber(vm, 1) \&\& be\_isnumber(vm, 2)) \{ /* comprobar que los argumentos son todos números
*/}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ breal a = be\_toreal(vm, 1); /* obtener el primer argumento */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ breal b = be\_toreal(vm, 1); /* empuja el resultado a la pila */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ be\_pushreal(vm, a + b); /* empuja el resultado a la pila */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \} else \{ /* parámetros inaceptables */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \ \ \ \ be\_pushnil(vm); /* empuja nil a la pila */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ \}}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ be\_return(vm); /* devuelve el resultado del cálculo */}

{\selectlanguage{spanish}\ttfamily
\}}


\bigskip

{\selectlanguage{spanish}
Luego regístrelo en el lugar apropiado:}


\bigskip

{\selectlanguage{spanish}\ttfamily
be\_regcfunc(vm, {\textquotedbl}add{\textquotedbl}, my\_add\_func);}

\subsubsection[Crear una instancia de un objeto list en una función nativa]{\foreignlanguage{spanish}{Crear una
instancia de un objeto }\textstyleSourceText{\foreignlanguage{spanish}{list}}\foreignlanguage{spanish}{ en una función
nativa}}
\hypertarget{RefHeadingToc360413639824055}{}\foreignlanguage{spanish}{La generación de clases nativas instanciadas en C
puede ser engorrosa en comparación con los tipos simples. Esta sección guiará al lector a instanciar la clase
}\textstyleSourceText{\foreignlanguage{spanish}{list}}\foreignlanguage{spanish}{.}

\foreignlanguage{spanish}{La clase }\textstyleSourceText{\foreignlanguage{spanish}{list}}\foreignlanguage{spanish}{ es
un contenedor alrededor de la estructura de la lista, que tiene una propiedad
}\textstyleSourceText{\foreignlanguage{spanish}{.data}}\foreignlanguage{spanish}{ para la estructura de la lista. Por
lo tanto, primero necesitamos construir una estructura de lista:}


\bigskip

{\selectlanguage{spanish}\ttfamily
be\_newlist(vm);}


\bigskip

\foreignlanguage{spanish}{La función
}\textstyleSourceText{\foreignlanguage{spanish}{be\_newlist}}\foreignlanguage{spanish}{ construye un valor de tipo
}\textstyleSourceText{\foreignlanguage{spanish}{BE\_LIST}}\foreignlanguage{spanish}{. Entonces podemos operar sobre los
datos:}


\bigskip

{\selectlanguage{spanish}\ttfamily
be\_pushint(vm, 100);}

{\selectlanguage{spanish}\ttfamily
be\_data\_append(vm, -2);}

{\selectlanguage{spanish}\ttfamily
be\_pop(vm, 1); /* extraer el entero 100 */}


\bigskip

\foreignlanguage{spanish}{Las dos primeras líneas de código se utilizan para añadir el entero
}\textstyleSourceText{\foreignlanguage{spanish}{100}}\foreignlanguage{spanish}{ a la lista, y la tercera línea del
entero }\textstyleSourceText{\foreignlanguage{spanish}{100}}\foreignlanguage{spanish}{ se extrae para facilitar las
operaciones posteriores.}

\foreignlanguage{spanish}{Dado que el tipo
}\textstyleSourceText{\foreignlanguage{spanish}{BE\_LIST}}\foreignlanguage{spanish}{ no se puede usar directamente en
Berry, pero lo usa la clase }\textstyleSourceText{\foreignlanguage{spanish}{list}}\foreignlanguage{spanish}{, tenemos
que construir la clase }\textstyleSourceText{\foreignlanguage{spanish}{list}}\foreignlanguage{spanish}{ para él:}


\bigskip

{\selectlanguage{spanish}\ttfamily
be\_getglobal(vm, {\textquotedbl}list{\textquotedbl});}

{\selectlanguage{spanish}\ttfamily
be\_pushvalue(vm, -2); /* empuja los datos de la lista al principio */}

{\selectlanguage{spanish}\ttfamily
be\_call(vm, 1); /* llama al constructor */}


\bigskip

\foreignlanguage{spanish}{El constructor de la clase
}\textstyleSourceText{\foreignlanguage{spanish}{list}}\foreignlanguage{spanish}{ permite el uso del parámetro de tipo
}\textstyleSourceText{\foreignlanguage{spanish}{BE\_LIST}}\foreignlanguage{spanish}{, que toma el argumento como datos
de lista.}

{\selectlanguage{spanish}
El código completo es el siguiente:}


\bigskip

{\selectlanguage{spanish}\ttfamily
int m\_listtest(bvm *vm)}

{\selectlanguage{spanish}\ttfamily
\{}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ be\_getglobal(vm, {\textquotedbl}list{\textquotedbl});}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ be\_newlist(vm);}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ be\_pushint(vm, 100);}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ be\_data\_append(vm, -2);}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ be\_pop(vm, 1);}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ be\_call(vm, 1);}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ be\_pop(vm, 1); /* pop the arguments */}

{\selectlanguage{spanish}\ttfamily
\ \ \ \ be\_return(vm);}

{\selectlanguage{spanish}\ttfamily
\}}


\bigskip

{\selectlanguage{spanish}
Registre la función nativa en el lugar apropiado:}


\bigskip

{\selectlanguage{spanish}\ttfamily
be\_regcfunc(vm, {\textquotedbl}listtest{\textquotedbl}, m\_listtest);}

\clearpage\section{Requerimientos de Memoria}
\hypertarget{RefHeadingToc360433639824055}{}
\bigskip

{\selectlanguage{spanish}\ttfamily
\#\#\# RAM requerida}


\bigskip

{\selectlanguage{spanish}\ttfamily
{}- extrema: 4 KB}

{\selectlanguage{spanish}\ttfamily
{}- baja: 8 KB}

{\selectlanguage{spanish}\ttfamily
{}- recomendada: ${\geq}$16 KB}


\bigskip

{\selectlanguage{spanish}\ttfamily
\#\#\# ROM/Flash requerida}


\bigskip

{\selectlanguage{spanish}\ttfamily
{}- extrema: 64 KB}

{\selectlanguage{spanish}\ttfamily
{}- baja: 128 KB}

{\selectlanguage{spanish}\ttfamily
{}- recomendada: ${\geq}$256 KB}


\bigskip

{\selectlanguage{spanish}\ttfamily
\#\#\# Explicación}


\bigskip

{\selectlanguage{spanish}\ttfamily
{}- **extrema**: La capacidad de memoria requerida en la configuración mínima. Un valor inferior a este significa que es
casi imposible ejecutar Berry.}

{\selectlanguage{spanish}\ttfamily
{}- **baja**: la memoria mínima requerida para que el intérprete completo de Berry incluya algunos códigos de usuario y
de terceros.}

{\selectlanguage{spanish}\ttfamily
{}- **recomendado**: además del intérprete completo de Berry, se sportan muchos usuarios y código de terceros.}

\clearpage\section{Hoja de ruta}
\hypertarget{RefHeadingToc360453639824055}{}
\bigskip


\bigskip

{\selectlanguage{spanish}\ttfamily
* [x] Soporte multilínea REPL.}

{\selectlanguage{spanish}\ttfamily
* [x] Información de depuración en tiempo de ejecución.}

{\selectlanguage{spanish}\ttfamily
* [x] Protección de pila API.}

{\selectlanguage{spanish}\ttfamily
* [x] Soporte de operación de archivos.}

{\selectlanguage{spanish}\ttfamily
* [x] Tabla hash fija (basada en ROM).}

{\selectlanguage{spanish}\ttfamily
* [x] Soporte de destructor.}

{\selectlanguage{spanish}\ttfamily
* [x] Compatibilidad con módulos nativos (use {\textasciigrave}import xxx{\textasciigrave} para importar un módulo).}

{\selectlanguage{spanish}\ttfamily
* [x] Soporte de expresiones condicionales.}

{\selectlanguage{spanish}\ttfamily
* [x] Función anónima.}

{\selectlanguage{spanish}\ttfamily
* [x] Operación bit a bit.}

{\selectlanguage{spanish}\ttfamily
* [x] Sentencia de asignación compuesta.}

{\selectlanguage{spanish}\ttfamily
* [x] Alcance incorporado.}

{\selectlanguage{spanish}\ttfamily
* [x] Función de argumentos variables.}

{\selectlanguage{spanish}\ttfamily
* [x] Función nativa: {\textasciigrave}classof(obj){\textasciigrave}.}

{\selectlanguage{spanish}\ttfamily
* [ ] \~{}\~{}Función nativa: {\textasciigrave}copy(obj){\textasciigrave}\~{}\~{}.}

{\selectlanguage{spanish}\ttfamily
* [ ] Pila de llamadas de liberación automática.}

{\selectlanguage{spanish}\ttfamily
* [ ] Expresión regular.}

{\selectlanguage{spanish}\ttfamily
* [x] GC optimizado para el uso de la pila (sin recursividad).}

{\selectlanguage{spanish}\ttfamily
* [x] Simplifica los mensajes de error de desbordamiento de pila.}

{\selectlanguage{spanish}\ttfamily
* [x] Expresión lambda.}

{\selectlanguage{spanish}\ttfamily
* [x] Manejo excepcional.}

{\selectlanguage{spanish}\ttfamily
* [x] Compatibilidad con archivos de bytecode.}

{\selectlanguage{spanish}\ttfamily
* [x] Iterador optimizado y sentencia {\textasciigrave}for{\textasciigrave}.}

{\selectlanguage{spanish}\ttfamily
* [x] Operador de conexión (redefine el operador de rango {\textasciigrave}..{\textasciigrave}).}

{\selectlanguage{spanish}\ttfamily
\ \ \ * [x] Conexión de cadena, por ejemplo, {\textasciigrave}'cadena' .. expr{\textasciigrave}.}

{\selectlanguage{spanish}\ttfamily
\ \ \ * [x] Lista de conexiones, por ejemplo, {\textasciigrave}[] .. expr{\textasciigrave}.}

{\selectlanguage{spanish}\ttfamily
\ \ \ * [x] Método de serialización de lista (para conexión de cadena de alto rendimiento).}

{\selectlanguage{spanish}\ttfamily
* [x] Soporte de módulo completo.}

{\selectlanguage{spanish}\ttfamily
\ \ \ * [x] Exportación/importación del módulo de archivo de script.}

{\selectlanguage{spanish}\ttfamily
\ \ \ * [x] Compilación/importación del módulo de archivo de bytecode.}

{\selectlanguage{spanish}\ttfamily
\ \ \ * [x] Carga del módulo nativo compartido (como *.so, *.dll).}

{\selectlanguage{spanish}\ttfamily
* [x] API de verificación de igualdad universal (como el operador {\textasciigrave}=={\textasciigrave} pero se usa en
C).}

{\selectlanguage{spanish}\ttfamily
\ \ \ * [x] Coincidencia de clave de mapa completa.}

{\selectlanguage{spanish}\ttfamily
\ \ \ * [x] Coincidencia de valor de excepción completa.}

{\selectlanguage{spanish}\ttfamily
* [ ] Compatibilidad con el depurador.}

{\selectlanguage{spanish}\ttfamily
* [ ] Mecanismo completo de clases y objetos.}

{\selectlanguage{spanish}\ttfamily
* [ ] Mensaje de error de soporte para la herramienta *map\_build*.}

{\selectlanguage{spanish}\ttfamily
* [x] Llamada sobrecargada al operador {\textasciigrave}(){\textasciigrave}.}


\bigskip

{\selectlanguage{spanish}\ttfamily
\#\# Versión de lanzamiento}


\bigskip

{\selectlanguage{spanish}\ttfamily
\#\#\# V0.2.0}


\bigskip

{\selectlanguage{spanish}\ttfamily
* [ ] Documentación china completa.}

{\selectlanguage{spanish}\ttfamily
* [x] Manejo excepcional.}

{\selectlanguage{spanish}\ttfamily
* [x] Soporte de módulo completo.}


\bigskip

{\selectlanguage{spanish}\ttfamily
\#\#\# V0.1.0}


\bigskip

{\selectlanguage{spanish}\ttfamily
* [x] Interfaz de sistema de archivos portátil.}

{\selectlanguage{spanish}\ttfamily
* [x] Compatibilidad con objetos constantes precompilados.}

{\selectlanguage{spanish}\ttfamily
* [x] Módulo constante completo precompilado.}

{\selectlanguage{spanish}\ttfamily
* [ ] \~{}\~{}Documentación más completa (chino)\~{}\~{}.}

{\selectlanguage{spanish}\ttfamily
* [ ] \~{}\~{}Guía de portabilidad\~{}\~{}.}
\end{document}
